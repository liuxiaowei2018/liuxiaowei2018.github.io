<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>并发编程-AQS | doc</title>
    <meta name="description" content="在线文档">
    <link rel="preload stylesheet" href="/assets/style.edc773f7.css" as="style">
    
    <script type="module" src="/assets/app.e04742be.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.8048b864.js">
    <link rel="modulepreload" href="/assets/chunks/theme.8ad05ab5.js">
    <link rel="modulepreload" href="/assets/java_juc_AQS.md.792b15fd.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5a346dfe><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5a346dfe data-v-ae24b3ad><div class="VPNavBar has-sidebar" data-v-ae24b3ad data-v-a0fd61f4><div class="container" data-v-a0fd61f4><div class="title" data-v-a0fd61f4><div class="VPNavBarTitle has-sidebar" data-v-a0fd61f4 data-v-86d1bed8><a class="title" href="/" data-v-86d1bed8><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo.png" alt data-v-8426fc1a><!--]--><!--[-->TheWe1<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-a0fd61f4><div class="curtain" data-v-a0fd61f4></div><div class="content-body" data-v-a0fd61f4><!--[--><!--]--><div class="VPNavBarSearch search" data-v-a0fd61f4><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg class="DocSearch-Search-Icon" width="20" height="20" viewBox="0 0 20 20" aria-label="search icon"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-a0fd61f4 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-9c007e85><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-9c007e85><span class="text" data-v-9c007e85><!----><span data-v-9c007e85>研发提效</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-9c007e85><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-9c007e85><div class="VPMenu" data-v-9c007e85 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E8%A7%84%E8%8C%83/MySQL%E8%A7%84%E8%8C%83.html" data-v-43f1e123><!--[-->规范<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E7%AC%94%E8%AE%B0/dev.html" data-v-43f1e123><!--[-->笔记<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-9c007e85><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-9c007e85><span class="text" data-v-9c007e85><!----><span data-v-9c007e85>生产事件</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-9c007e85><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-9c007e85><div class="VPMenu" data-v-9c007e85 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E7%94%9F%E4%BA%A7%E4%BA%8B%E4%BB%B6/%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E6%8C%87%E6%A0%87%E5%AE%9A%E4%B9%89.html" data-v-43f1e123><!--[-->线上环境指标定义<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E7%94%9F%E4%BA%A7%E4%BA%8B%E4%BB%B6/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" data-v-43f1e123><!--[-->如何做好性能优化<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E7%94%9F%E4%BA%A7%E4%BA%8B%E4%BB%B6/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98.html" data-v-43f1e123><!--[-->如何排查生产问题<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-9c007e85><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-9c007e85><span class="text" data-v-9c007e85><!----><span data-v-9c007e85>系统设计</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-9c007e85><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-9c007e85><div class="VPMenu" data-v-9c007e85 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html" data-v-43f1e123><!--[-->如何做好架构设计<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/index.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>更新日志</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-a0fd61f4 data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-e6aabb21 data-v-ce54a7d1 data-v-b1685198><span class="check" data-v-b1685198><span class="icon" data-v-b1685198><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-ce54a7d1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-ce54a7d1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-a0fd61f4 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/liuxiaowei2018" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-f80f8133><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-a0fd61f4 data-v-40855f84 data-v-9c007e85><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-9c007e85><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-9c007e85><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-9c007e85><div class="VPMenu" data-v-9c007e85 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-40855f84 data-v-ce54a7d1 data-v-b1685198><span class="check" data-v-b1685198><span class="icon" data-v-b1685198><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-ce54a7d1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-ce54a7d1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-40855f84><div class="item social-links" data-v-40855f84><div class="VPSocialLinks social-links-list" data-v-40855f84 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/liuxiaowei2018" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-f80f8133><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-a0fd61f4 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav reached-top" data-v-5a346dfe data-v-79c8c1df><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-79c8c1df><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-79c8c1df><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-79c8c1df>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-79c8c1df data-v-1c15a60a><button data-v-1c15a60a>Return to top</button><!----></div></div><aside class="VPSidebar" data-v-5a346dfe data-v-b00e2fdd><div class="curtain" data-v-b00e2fdd></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-b00e2fdd><span class="visually-hidden" id="sidebar-aria-label" data-v-b00e2fdd> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-b00e2fdd><section class="VPSidebarItem level-0" data-v-b00e2fdd data-v-e31bd47b><div class="item" role="button" tabindex="0" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><h2 class="text" data-v-e31bd47b>并发编程基础</h2><!----></div><div class="items" data-v-e31bd47b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>1.多线程基础</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/%E5%8E%9F%E5%AD%90%E7%B1%BB.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>2.原子类</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/ThreadLocal.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>3.ThreadLocal</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-b00e2fdd><section class="VPSidebarItem level-0" data-v-b00e2fdd data-v-e31bd47b><div class="item" role="button" tabindex="0" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><h2 class="text" data-v-e31bd47b>并发容器</h2><!----></div><div class="items" data-v-e31bd47b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>1.并发容器</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>2.阻塞队列</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-b00e2fdd><section class="VPSidebarItem level-0 has-active" data-v-b00e2fdd data-v-e31bd47b><div class="item" role="button" tabindex="0" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><h2 class="text" data-v-e31bd47b>锁</h2><!----></div><div class="items" data-v-e31bd47b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/AQS.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>1.AQS</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/Synchronized.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>2.Synchronized</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/ReentrantLock.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>3.ReentrantLock</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/ReadWriteLock.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>4.ReadWriteLock</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-b00e2fdd><section class="VPSidebarItem level-0" data-v-b00e2fdd data-v-e31bd47b><div class="item" role="button" tabindex="0" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><h2 class="text" data-v-e31bd47b>并发工具类</h2><!----></div><div class="items" data-v-e31bd47b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/CountDownLatch.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>1.CountDownLatch</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/Semaphore.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>2.Semaphore</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/CyclicBarrier.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>3.CyclicBarrier</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/Exchanger.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>4.Exchanger</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/Condition.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>5.Condition</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/CompletableFuture.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>6.CompletableFuture</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-b00e2fdd><section class="VPSidebarItem level-0" data-v-b00e2fdd data-v-e31bd47b><div class="item" role="button" tabindex="0" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><h2 class="text" data-v-e31bd47b>线程池</h2><!----></div><div class="items" data-v-e31bd47b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/java/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>线程池</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5a346dfe data-v-669faec9><div class="VPDoc has-sidebar has-aside" data-v-669faec9 data-v-6b87e69f><!--[--><!--]--><div class="container" data-v-6b87e69f><div class="aside" data-v-6b87e69f><div class="aside-curtain" data-v-6b87e69f></div><div class="aside-container" data-v-6b87e69f><div class="aside-content" data-v-6b87e69f><div class="VPDocAside" data-v-6b87e69f data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-3f215769 data-v-d330b1bb><div class="content" data-v-d330b1bb><div class="outline-marker" data-v-d330b1bb></div><div class="outline-title" role="heading" aria-level="2" data-v-d330b1bb>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-d330b1bb><span class="visually-hidden" id="doc-outline-aria-label" data-v-d330b1bb> Table of Contents for current page </span><ul class="root" data-v-d330b1bb data-v-d0ee3533><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-6b87e69f><div class="content-container" data-v-6b87e69f><!--[--><!--]--><!----><main class="main" data-v-6b87e69f><div style="position:relative;" class="vp-doc _java_juc_AQS" data-v-6b87e69f><div><h1 id="并发编程-aqs" tabindex="-1">并发编程-AQS <a class="header-anchor" href="#并发编程-aqs" aria-label="Permalink to &quot;并发编程-AQS&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#aqs类源码">AQS类源码</a></li><li><a href="#aqs方法源码">AQS方法源码</a></li><li><a href="#aqs加锁流程">AQS加锁流程</a><ul><li><a href="#排他锁">排他锁</a></li><li><a href="#共享锁">共享锁</a></li></ul></li><li><a href="#q-a">Q&amp;A</a></li></ul></nav><p>AbstractQueuedSynchronizer，常见的同步锁 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>、<code>CyclicBarrier</code>等都是基于 <code>AQS</code> 实现的。</p><h2 id="aqs类源码" tabindex="-1">AQS类源码 <a class="header-anchor" href="#aqs类源码" aria-label="Permalink to &quot;AQS类源码&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// AQS继承自AbstractOwnableSynchronizer，为了记录哪个线程占用锁</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">abstract</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractQueuedSynchronizer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractOwnableSynchronizer</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 同步状态，0表示无锁，每次加锁+1，释放锁-1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> state;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 同步队列的头尾节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Node head;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Node tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Node节点，用来包装线程，放到队列中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 节点中的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Thread thread;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 节点状态</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> waitStatus;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 同步队列的前驱节点和后继节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Node prev;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Node next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 条件队列的后继节点或者同步队列的共享/排他模式</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node nextWaiter;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 条件队列</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ConditionObject</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Condition</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 条件队列的头尾节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> Node firstWaiter;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> Node lastWaiter;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// AQS继承自AbstractOwnableSynchronizer，为了记录哪个线程占用锁</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">abstract</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractQueuedSynchronizer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractOwnableSynchronizer</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 同步状态，0表示无锁，每次加锁+1，释放锁-1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> state;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 同步队列的头尾节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Node head;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Node tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Node节点，用来包装线程，放到队列中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 节点中的线程</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Thread thread;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 节点状态</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> waitStatus;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 同步队列的前驱节点和后继节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Node prev;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Node next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 条件队列的后继节点或者同步队列的共享/排他模式</span></span>
<span class="line"><span style="color:#24292E;">        Node nextWaiter;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 条件队列</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ConditionObject</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Condition</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 条件队列的头尾节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> Node firstWaiter;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> Node lastWaiter;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p><strong>AbstractOwnableSynchronizer</strong>.java</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">abstract</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractOwnableSynchronizer</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 正在占用锁的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> Thread exclusiveOwnerThread;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 设置占用锁的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setExclusiveOwnerThread</span><span style="color:#E1E4E8;">(Thread </span><span style="color:#FFAB70;">thread</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        exclusiveOwnerThread </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> thread;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Thread </span><span style="color:#B392F0;">getExclusiveOwnerThread</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> exclusiveOwnerThread;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">abstract</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractOwnableSynchronizer</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 正在占用锁的线程</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> Thread exclusiveOwnerThread;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 设置占用锁的线程</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setExclusiveOwnerThread</span><span style="color:#24292E;">(Thread </span><span style="color:#E36209;">thread</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        exclusiveOwnerThread </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> thread;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Thread </span><span style="color:#6F42C1;">getExclusiveOwnerThread</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> exclusiveOwnerThread;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>无论是同步队列还是条件队列中线程都需要包装成Node节点。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202406222115900.png" alt="image-20240622211532857"></p><p><strong>同步队列：</strong> 是带有头尾节点的双链表，由Node节点组成，使用prev和next组成双向链表，nextWaiter只用来表示是共享模式还是排他模式。</p><p><strong>条件队列：</strong> 是带有头尾节点的单链表。同样由Node节点组成，没有使用到Node中prev和next属性，而是使用nextWaiter组成单链表。</p><blockquote><p><strong>复用对象的设计思想</strong> (๑•̀ㅂ•́)و✧</p></blockquote><p>同步队列head节点是个哑节点，里面并没有存储线程对象。当然head节点也可看成是给当前持有锁的线程使用。</p><p>Node节点的<code>节点状态（waitStatus）</code>共有5种：</p><ul><li><strong>1 cancelled</strong>：表示节点的线程已经被取消</li><li><strong>0 初始化</strong>：Node节点的默认值</li><li><strong>-1 signal</strong>: 表示节点线程在释放锁后要唤醒同步队列中的后继节点</li><li><strong>-2 condition</strong>: 当前节点在条件队列中</li><li><strong>-3 propagate</strong>: 释放共享资源的时候会向后传播释放其他共享节点（用于共享模式）</li></ul><p><code>节点状态（waitStatus）</code>流转过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202406222117321.png" alt="image-20240622211718286"></p><h2 id="aqs方法源码" tabindex="-1">AQS方法源码 <a class="header-anchor" href="#aqs方法源码" aria-label="Permalink to &quot;AQS方法源码&quot;">​</a></h2><p><code>AQS</code>支持<code>排他模式</code>和<code>共享模式</code>两种访问资源的模式（排他模式又叫独占模式）。</p><p>排他模式的方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 加锁</span></span>
<span class="line"><span style="color:#B392F0;">acquire</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg);</span></span>
<span class="line"><span style="color:#6A737D;">// 加可中断的锁</span></span>
<span class="line"><span style="color:#B392F0;">acquireInterruptibly</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg);</span></span>
<span class="line"><span style="color:#6A737D;">// 加锁，带超时时间（如果指定时间内加锁不成功，就返回false）</span></span>
<span class="line"><span style="color:#B392F0;">tryAcquireNanos</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> nanosTimeout);</span></span>
<span class="line"><span style="color:#6A737D;">// 释放锁</span></span>
<span class="line"><span style="color:#B392F0;">release</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 加锁</span></span>
<span class="line"><span style="color:#6F42C1;">acquire</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg);</span></span>
<span class="line"><span style="color:#6A737D;">// 加可中断的锁</span></span>
<span class="line"><span style="color:#6F42C1;">acquireInterruptibly</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg);</span></span>
<span class="line"><span style="color:#6A737D;">// 加锁，带超时时间（如果指定时间内加锁不成功，就返回false）</span></span>
<span class="line"><span style="color:#6F42C1;">tryAcquireNanos</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg, </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> nanosTimeout);</span></span>
<span class="line"><span style="color:#6A737D;">// 释放锁</span></span>
<span class="line"><span style="color:#6F42C1;">release</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg);</span></span></code></pre></div><p>共享模式的方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 加锁</span></span>
<span class="line"><span style="color:#B392F0;">acquireShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg);</span></span>
<span class="line"><span style="color:#6A737D;">// 加可中断的锁</span></span>
<span class="line"><span style="color:#B392F0;">acquireSharedInterruptibly</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg);</span></span>
<span class="line"><span style="color:#6A737D;">// 加锁，带超时时间（如果指定时间内加锁不成功，就返回false）</span></span>
<span class="line"><span style="color:#B392F0;">tryAcquireSharedNanos</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> nanosTimeout);</span></span>
<span class="line"><span style="color:#6A737D;">// 释放锁</span></span>
<span class="line"><span style="color:#B392F0;">releaseShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 加锁</span></span>
<span class="line"><span style="color:#6F42C1;">acquireShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg);</span></span>
<span class="line"><span style="color:#6A737D;">// 加可中断的锁</span></span>
<span class="line"><span style="color:#6F42C1;">acquireSharedInterruptibly</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg);</span></span>
<span class="line"><span style="color:#6A737D;">// 加锁，带超时时间（如果指定时间内加锁不成功，就返回false）</span></span>
<span class="line"><span style="color:#6F42C1;">tryAcquireSharedNanos</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg, </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> nanosTimeout);</span></span>
<span class="line"><span style="color:#6A737D;">// 释放锁</span></span>
<span class="line"><span style="color:#6F42C1;">releaseShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg);</span></span></code></pre></div><p>排他模式和共享模式的方法并没有实现具体的加锁、释放锁逻辑，AQS中只是定义了加锁、释放锁的抽象方法。 留给子类实现的抽象方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">abstract</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractQueuedSynchronizer</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractOwnableSynchronizer</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> java.io.</span><span style="color:#B392F0;">Serializable</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 加排他锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">arg</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 释放排他锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryRelease</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">arg</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 加共享锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquireShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">arg</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 释放共享锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryReleaseShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">arg</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 判断是否是当前线程正在持有锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isHeldExclusively</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">abstract</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractQueuedSynchronizer</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractOwnableSynchronizer</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> java.io.</span><span style="color:#6F42C1;">Serializable</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 加排他锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">arg</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 释放排他锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryRelease</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">arg</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 加共享锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquireShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">arg</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 释放共享锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryReleaseShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">arg</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 判断是否是当前线程正在持有锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isHeldExclusively</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>这里用到了设计模式中的模板方法。</p><p>父类<code>AQS</code>定义了加锁、释放锁的流程，子类ReentrantLock、CountDownLatch、Semaphore、CyclicBarrier负责实现具体的加锁、释放锁逻辑。</p></blockquote><p><strong>条件队列中常用方法</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 等待方法，并释放锁</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">	……</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 等待指定时间</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> time, TimeUnit unit) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">	……</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 唤醒条件队列中的单个线程</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">signal</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">	……</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 唤醒条件队列中的所有线程</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">signalAll</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">	……</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 等待方法，并释放锁</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">	……</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 等待指定时间</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> time, TimeUnit unit) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">	……</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 唤醒条件队列中的单个线程</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">	……</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 唤醒条件队列中的所有线程</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">signalAll</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">	……</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="aqs加锁流程" tabindex="-1">AQS加锁流程 <a class="header-anchor" href="#aqs加锁流程" aria-label="Permalink to &quot;AQS加锁流程&quot;">​</a></h2><h3 id="排他锁" tabindex="-1">排他锁 <a class="header-anchor" href="#排他锁" aria-label="Permalink to &quot;排他锁&quot;">​</a></h3><h4 id="加锁" tabindex="-1">加锁 <a class="header-anchor" href="#加锁" aria-label="Permalink to &quot;加锁&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202406222125565.png" alt="image-20240622212548531"></p><p>部分源码解析：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 加锁方法，传参是1，表示加锁一次</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">acquire</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 首先尝试获取锁，如果获取成功，则设置state+1，exclusiveOwnerThread=currentThread（留给子类实现）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(arg) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 2. 如果没有获取成功，把线程组装成Node节点，追加到同步队列末尾</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">acquireQueued</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">addWaiter</span><span style="color:#E1E4E8;">(Node.EXCLUSIVE), arg)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 3. 加入同步队列后，将自己挂起</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">selfInterrupt</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 加锁方法，传参是1，表示加锁一次</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">acquire</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 首先尝试获取锁，如果获取成功，则设置state+1，exclusiveOwnerThread=currentThread（留给子类实现）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(arg) </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 2. 如果没有获取成功，把线程组装成Node节点，追加到同步队列末尾</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">acquireQueued</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">addWaiter</span><span style="color:#24292E;">(Node.EXCLUSIVE), arg)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 3. 加入同步队列后，将自己挂起</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">selfInterrupt</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>进入<code>addWaiter()</code>方法源码，作用就是把线程组装成Node节点，追加到同步队列末尾。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 追加到同步队列末尾，传参mode表示是共享模式or排他模式</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Node </span><span style="color:#B392F0;">addWaiter</span><span style="color:#E1E4E8;">(Node mode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 组装成Node节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">(), mode);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node pred </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (pred </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        node.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 2. 在多线程竞争不激烈的情况下，通过CAS方法追加到同步队列末尾</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetTail</span><span style="color:#E1E4E8;">(pred, node)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            pred.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 3. 在多线程竞争激烈的情况下，使用死循环保证追加到同步队列末尾</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">enq</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 通过死循环的方式，追加到同步队列末尾</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Node </span><span style="color:#B392F0;">enq</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (; ; ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果同步队列为空，先初始化头节点（头节点是空节点）</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetHead</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">()))</span></span>
<span class="line"><span style="color:#E1E4E8;">                tail </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 再使用CAS追加到同步队列末尾</span></span>
<span class="line"><span style="color:#E1E4E8;">            node.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetTail</span><span style="color:#E1E4E8;">(t, node)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                t.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 创建Node节点，传参thread表示当前线程，mode表示共享模式or排他模式</span></span>
<span class="line"><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">(Thread thread, Node mode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.thread </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> thread;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.nextWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mode;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 追加到同步队列末尾，传参mode表示是共享模式or排他模式</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Node </span><span style="color:#6F42C1;">addWaiter</span><span style="color:#24292E;">(Node mode) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 组装成Node节点</span></span>
<span class="line"><span style="color:#24292E;">    Node node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">(), mode);</span></span>
<span class="line"><span style="color:#24292E;">    Node pred </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (pred </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        node.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 2. 在多线程竞争不激烈的情况下，通过CAS方法追加到同步队列末尾</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetTail</span><span style="color:#24292E;">(pred, node)) {</span></span>
<span class="line"><span style="color:#24292E;">            pred.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 3. 在多线程竞争激烈的情况下，使用死循环保证追加到同步队列末尾</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">enq</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 通过死循环的方式，追加到同步队列末尾</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Node </span><span style="color:#6F42C1;">enq</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node node) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (; ; ) {</span></span>
<span class="line"><span style="color:#24292E;">        Node t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果同步队列为空，先初始化头节点（头节点是空节点）</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetHead</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">()))</span></span>
<span class="line"><span style="color:#24292E;">                tail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 再使用CAS追加到同步队列末尾</span></span>
<span class="line"><span style="color:#24292E;">            node.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetTail</span><span style="color:#24292E;">(t, node)) {</span></span>
<span class="line"><span style="color:#24292E;">                t.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 创建Node节点，传参thread表示当前线程，mode表示共享模式or排他模式</span></span>
<span class="line"><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">(Thread thread, Node mode) {</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.thread </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> thread;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.nextWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mode;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>再看一下<code>addWaiter()</code>方法外层的<code>acquireQueued()</code>方法，作用就是：</p><ol><li>在追加到同步队列末尾后，再判断一下前驱节点是不是头节点。如果是，说明是第一个加入同步队列的，就再去尝试获取锁。如果获取锁成功，就把自己设置成头节点。</li><li>如果前驱节点不是头节点，或者获取锁失败，就逆序遍历同步队列，找到可以将自己唤醒的节点。</li><li>最后才放心地将自己挂起</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 追加到同步队列末尾后，再次尝试获取锁</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">acquireQueued</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node node, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> failed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> interrupted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (; ; ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 1. 找到前驱节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.</span><span style="color:#B392F0;">predecessor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 2. 如果前驱节点是头结点，就再次尝试获取锁</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (p </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> head </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(arg)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 3. 获取锁成功后，把自己设置为头节点</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">setHead</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">                p.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                failed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> interrupted;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 4. 如果还是没有获取到锁，找到可以将自己唤醒的节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">shouldParkAfterFailedAcquire</span><span style="color:#E1E4E8;">(p, node) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 5. 最后才放心地将自己挂起</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">parkAndCheckInterrupt</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">                interrupted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (failed)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">cancelAcquire</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 追加到同步队列末尾后，再次尝试获取锁</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">acquireQueued</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node node, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> failed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> interrupted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (; ; ) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 1. 找到前驱节点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.</span><span style="color:#6F42C1;">predecessor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 2. 如果前驱节点是头结点，就再次尝试获取锁</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (p </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> head </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(arg)) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 3. 获取锁成功后，把自己设置为头节点</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">setHead</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">                p.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                failed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> interrupted;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 4. 如果还是没有获取到锁，找到可以将自己唤醒的节点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">shouldParkAfterFailedAcquire</span><span style="color:#24292E;">(p, node) </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 5. 最后才放心地将自己挂起</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">parkAndCheckInterrupt</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">                interrupted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (failed)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">cancelAcquire</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>再看一下<code>shouldParkAfterFailedAcquire()</code>方法，是怎么找到将自己唤醒的节点的？为什么要找这个节点？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 加入同步队列后，找到能将自己唤醒的节点</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">shouldParkAfterFailedAcquire</span><span style="color:#E1E4E8;">(Node pred, Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ws </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred.waitStatus;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 如果前驱节点的状态已经是SIGNAL状态（释放锁后，需要唤醒后继节点），就无需操作了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Node.SIGNAL)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 2. 如果前驱节点的状态是已取消，就继续向前遍历</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            node.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred.prev;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (pred.waitStatus </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        pred.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 3. 找到了不是取消状态的节点，把该节点状态设置成SIGNAL</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(pred, ws, Node.SIGNAL);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 加入同步队列后，找到能将自己唤醒的节点</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">shouldParkAfterFailedAcquire</span><span style="color:#24292E;">(Node pred, Node node) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ws </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred.waitStatus;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 如果前驱节点的状态已经是SIGNAL状态（释放锁后，需要唤醒后继节点），就无需操作了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> Node.SIGNAL)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 2. 如果前驱节点的状态是已取消，就继续向前遍历</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            node.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred.prev;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (pred.waitStatus </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        pred.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 3. 找到了不是取消状态的节点，把该节点状态设置成SIGNAL</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(pred, ws, Node.SIGNAL);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>该代码目的就是为了找到不是取消状态的节点，并把该节点的状态设置成SIGNAL。 状态是SIGNAL的节点，释放锁后，需要唤醒其后继节点。 简单理解就是：小弟初来乍到，特意来知会老大一声，有好事，多通知小弟。 再看一下释放锁的逻辑。</p><h4 id="释放锁" tabindex="-1">释放锁 <a class="header-anchor" href="#释放锁" aria-label="Permalink to &quot;释放锁&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202406222128961.png" alt="image-20240622212848933"></p><p>部分源码解析：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 释放锁，传参是1，表示释放锁一次</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">release</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 先尝试释放锁，如果成功，则设置state-1，exclusiveOwnerThread=null（由子类实现）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">tryRelease</span><span style="color:#E1E4E8;">(arg)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 2. 如果同步队列中还有其他节点，就唤醒下一个节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> h.waitStatus </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 3. 唤醒其后继节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">unparkSuccessor</span><span style="color:#E1E4E8;">(h);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 释放锁，传参是1，表示释放锁一次</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">release</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 先尝试释放锁，如果成功，则设置state-1，exclusiveOwnerThread=null（由子类实现）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">tryRelease</span><span style="color:#24292E;">(arg)) {</span></span>
<span class="line"><span style="color:#24292E;">        Node h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 2. 如果同步队列中还有其他节点，就唤醒下一个节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> h.waitStatus </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 3. 唤醒其后继节点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">unparkSuccessor</span><span style="color:#24292E;">(h);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>再看一下 unparkSuccessor 方法，作用就是重置头节点状态，然后找到一个有效的后继节点并唤醒。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 唤醒后继节点</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">unparkSuccessor</span><span style="color:#E1E4E8;">(Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ws </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.waitStatus;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 如果头节点不是取消状态，就重置成初始状态</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(node, ws, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    Node s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 2. 如果后继节点是null或者是取消状态</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> s.waitStatus </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 3. 从队尾开始遍历，找到一个有效状态的节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Node t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail; t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> node; t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t.prev)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t.waitStatus </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 3. 唤醒这个有效节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        LockSupport.</span><span style="color:#B392F0;">unpark</span><span style="color:#E1E4E8;">(s.thread);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 唤醒后继节点</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">unparkSuccessor</span><span style="color:#24292E;">(Node node) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ws </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.waitStatus;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 如果头节点不是取消状态，就重置成初始状态</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(node, ws, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    Node s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.next;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 2. 如果后继节点是null或者是取消状态</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> s.waitStatus </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 3. 从队尾开始遍历，找到一个有效状态的节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Node t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail; t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> node; t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t.prev)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t.waitStatus </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 3. 唤醒这个有效节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        LockSupport.</span><span style="color:#6F42C1;">unpark</span><span style="color:#24292E;">(s.thread);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="await等待" tabindex="-1">await等待 <a class="header-anchor" href="#await等待" aria-label="Permalink to &quot;await等待&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202406222130541.png" alt="image-20240622213015502"></p><p>持有锁的线程可以调用await()方法，在ConditionObject类里面。</p><p>作用是：释放锁，并追加到条件队列末尾。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 等待方法</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果线程已中断，则抛出中断异常</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Thread.</span><span style="color:#B392F0;">interrupted</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InterruptedException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 追加到条件队列末尾</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">addConditionWaiter</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 2. 释放锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> savedState </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fullyRelease</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> interruptMode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 3. 有可能刚加入条件队列就被转移到同步队列了，如果还在条件队列，就可以放心地挂起自己</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">isOnSyncQueue</span><span style="color:#E1E4E8;">(node)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        LockSupport.</span><span style="color:#B392F0;">park</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((interruptMode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">checkInterruptWhileWaiting</span><span style="color:#E1E4E8;">(node)) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 4. 如果已经转移到同步队列，就尝试获取锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">acquireQueued</span><span style="color:#E1E4E8;">(node, savedState) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> interruptMode </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> THROW_IE)</span></span>
<span class="line"><span style="color:#E1E4E8;">        interruptMode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> REINTERRUPT;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.nextWaiter </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 5. 清除条件队列中已取消的节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">unlinkCancelledWaiters</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (interruptMode </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">reportInterruptAfterWait</span><span style="color:#E1E4E8;">(interruptMode);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 等待方法</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果线程已中断，则抛出中断异常</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Thread.</span><span style="color:#6F42C1;">interrupted</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InterruptedException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 追加到条件队列末尾</span></span>
<span class="line"><span style="color:#24292E;">    Node node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addConditionWaiter</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 2. 释放锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> savedState </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fullyRelease</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> interruptMode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 3. 有可能刚加入条件队列就被转移到同步队列了，如果还在条件队列，就可以放心地挂起自己</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">isOnSyncQueue</span><span style="color:#24292E;">(node)) {</span></span>
<span class="line"><span style="color:#24292E;">        LockSupport.</span><span style="color:#6F42C1;">park</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((interruptMode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">checkInterruptWhileWaiting</span><span style="color:#24292E;">(node)) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 4. 如果已经转移到同步队列，就尝试获取锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">acquireQueued</span><span style="color:#24292E;">(node, savedState) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> interruptMode </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> THROW_IE)</span></span>
<span class="line"><span style="color:#24292E;">        interruptMode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> REINTERRUPT;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.nextWaiter </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 5. 清除条件队列中已取消的节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">unlinkCancelledWaiters</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (interruptMode </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">reportInterruptAfterWait</span><span style="color:#24292E;">(interruptMode);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>再看一下addConditionWaiter方法，是怎么追加到条件队列末尾的？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 追加到条件队列末尾</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Node </span><span style="color:#B392F0;">addConditionWaiter</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> lastWaiter;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 清除已取消的节点，找到有效节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> t.waitStatus </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> Node.CONDITION) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">unlinkCancelledWaiters</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> lastWaiter;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 2. 创建Node节点，状态是CONDITION（表示处于条件队列）</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">(), Node.CONDITION);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 3. 追加到条件队列末尾</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        firstWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">        t.nextWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">    lastWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 追加到条件队列末尾</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Node </span><span style="color:#6F42C1;">addConditionWaiter</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    Node t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> lastWaiter;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 清除已取消的节点，找到有效节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> t.waitStatus </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> Node.CONDITION) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">unlinkCancelledWaiters</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> lastWaiter;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 2. 创建Node节点，状态是CONDITION（表示处于条件队列）</span></span>
<span class="line"><span style="color:#24292E;">    Node node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">(), Node.CONDITION);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 3. 追加到条件队列末尾</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        firstWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">        t.nextWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">    lastWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="signal唤醒" tabindex="-1">signal唤醒 <a class="header-anchor" href="#signal唤醒" aria-label="Permalink to &quot;signal唤醒&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202406222131082.png" alt="image-20240622213123042"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 唤醒条件队列的头节点</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">signal</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 只有持有锁的线程才能调用signal方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">isHeldExclusively</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IllegalMonitorStateException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 2. 找到条件队列的头节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node first </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> firstWaiter;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (first </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 3. 开始唤醒</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">doSignal</span><span style="color:#E1E4E8;">(first);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 实际的唤醒方法</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSignal</span><span style="color:#E1E4E8;">(Node first) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 4. 从条件队列中移除头节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((firstWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> first.nextWaiter) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            lastWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        first.nextWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 5. 使用死循环，一定要转移一个节点到同步队列</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">transferForSignal</span><span style="color:#E1E4E8;">(first) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">            (first </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> firstWaiter) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 唤醒条件队列的头节点</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 只有持有锁的线程才能调用signal方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">isHeldExclusively</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalMonitorStateException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 2. 找到条件队列的头节点</span></span>
<span class="line"><span style="color:#24292E;">    Node first </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> firstWaiter;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (first </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 3. 开始唤醒</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">doSignal</span><span style="color:#24292E;">(first);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 实际的唤醒方法</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSignal</span><span style="color:#24292E;">(Node first) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 4. 从条件队列中移除头节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((firstWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> first.nextWaiter) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            lastWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        first.nextWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 5. 使用死循环，一定要转移一个节点到同步队列</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">transferForSignal</span><span style="color:#24292E;">(first) </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">            (first </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> firstWaiter) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>到底是怎么转移到同步队列末尾的？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 实际转移方法</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">transferForSignal</span><span style="color:#E1E4E8;">(Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 把节点状态从CONDITION改成0，表示从条件队列转移到同步队列</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(node, Node.CONDITION, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 2. 使用死循环的方式，追加到同步队列末尾（前面已经讲过）</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">enq</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ws </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p.waitStatus;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 3. 把前驱节点状态设置SIGNAL（通知他，别忘了唤醒老弟）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(p, ws, Node.SIGNAL))</span></span>
<span class="line"><span style="color:#E1E4E8;">        LockSupport.</span><span style="color:#B392F0;">unpark</span><span style="color:#E1E4E8;">(node.thread);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 实际转移方法</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">transferForSignal</span><span style="color:#24292E;">(Node node) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 把节点状态从CONDITION改成0，表示从条件队列转移到同步队列</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(node, Node.CONDITION, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">))</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 2. 使用死循环的方式，追加到同步队列末尾（前面已经讲过）</span></span>
<span class="line"><span style="color:#24292E;">    Node p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">enq</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ws </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.waitStatus;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 3. 把前驱节点状态设置SIGNAL（通知他，别忘了唤醒老弟）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(p, ws, Node.SIGNAL))</span></span>
<span class="line"><span style="color:#24292E;">        LockSupport.</span><span style="color:#6F42C1;">unpark</span><span style="color:#24292E;">(node.thread);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="共享锁" tabindex="-1">共享锁 <a class="header-anchor" href="#共享锁" aria-label="Permalink to &quot;共享锁&quot;">​</a></h3><h4 id="加锁-1" tabindex="-1">加锁 <a class="header-anchor" href="#加锁-1" aria-label="Permalink to &quot;加锁&quot;">​</a></h4><p>共享锁的加锁流程源码解析：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 加锁方法，传参是1，表示加锁一次</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">acquireShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 首先尝试获取锁，返回值小于0，表示获取锁失败</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">tryAcquireShared</span><span style="color:#E1E4E8;">(arg) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 2. 获取锁失败后，执行的逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">doAcquireShared</span><span style="color:#E1E4E8;">(arg);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 获取锁失败，执行的逻辑</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doAcquireShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 把当前线程包装成Node节点追加到同步队列末尾（前面已经讲过）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">addWaiter</span><span style="color:#E1E4E8;">(Node.SHARED);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> failed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> interrupted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (; ; ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 2. 找到前驱节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.</span><span style="color:#B392F0;">predecessor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 3. 如果前驱节点是头结点，就再次尝试获取锁</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (p </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> head) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquireShared</span><span style="color:#E1E4E8;">(arg);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (r </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 3. 获取锁成功后，把自己设置为头节点并向后传播</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">setHeadAndPropagate</span><span style="color:#E1E4E8;">(node, r);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    p.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 4. 检查中断状态</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (interrupted) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#B392F0;">selfInterrupt</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#E1E4E8;">                    failed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 4. 如果获取锁失败，把前驱节点状态设置成SIGNAL，用来唤醒自己（前面讲过）</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">shouldParkAfterFailedAcquire</span><span style="color:#E1E4E8;">(p, node) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 挂起并中断当前线程</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">parkAndCheckInterrupt</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                interrupted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 5. 如果获取锁失败，就取消当前节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (failed) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">cancelAcquire</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 加锁方法，传参是1，表示加锁一次</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">acquireShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 首先尝试获取锁，返回值小于0，表示获取锁失败</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">tryAcquireShared</span><span style="color:#24292E;">(arg) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 2. 获取锁失败后，执行的逻辑</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">doAcquireShared</span><span style="color:#24292E;">(arg);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 获取锁失败，执行的逻辑</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doAcquireShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 把当前线程包装成Node节点追加到同步队列末尾（前面已经讲过）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addWaiter</span><span style="color:#24292E;">(Node.SHARED);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> failed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> interrupted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (; ; ) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 2. 找到前驱节点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.</span><span style="color:#6F42C1;">predecessor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 3. 如果前驱节点是头结点，就再次尝试获取锁</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (p </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> head) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> r </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquireShared</span><span style="color:#24292E;">(arg);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (r </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 3. 获取锁成功后，把自己设置为头节点并向后传播</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">setHeadAndPropagate</span><span style="color:#24292E;">(node, r);</span></span>
<span class="line"><span style="color:#24292E;">                    p.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 4. 检查中断状态</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (interrupted) {</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6F42C1;">selfInterrupt</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    }</span></span>
<span class="line"><span style="color:#24292E;">                    failed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 4. 如果获取锁失败，把前驱节点状态设置成SIGNAL，用来唤醒自己（前面讲过）</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">shouldParkAfterFailedAcquire</span><span style="color:#24292E;">(p, node) </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 挂起并中断当前线程</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">parkAndCheckInterrupt</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                interrupted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 5. 如果获取锁失败，就取消当前节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (failed) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">cancelAcquire</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>上面的第三步设置头节点的逻辑，setHeadAndPropagate() 方法的作用就是：</p><ol><li>设置新的头节点</li><li>向后传播共享锁</li></ol><p>这里就是共享锁与排它锁的区别，共享锁的同步队列中某个节点获取到锁时，会向后传播，唤醒其他节点，也就是通知队列中其他节点一起获取锁。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 设置头节点，并向后传播</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setHeadAndPropagate</span><span style="color:#E1E4E8;">(Node node, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> propagate) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">setHead</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// propagate &gt; 0 表示获取到了共享锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// h == null || h.waitStatus &lt; 0 表示当前头节点已经不再是有效节点，可能是被取消或者已经释放了锁，需要进行传播。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 再次判断头节点，防止在设置头节点的过程中发生竞争</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (propagate </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> h.waitStatus </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">        (h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> h.waitStatus </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 判断如果后继节点为空或者是共享节点，就开始传播共享锁</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">isShared</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">doReleaseShared</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 设置头节点，并向后传播</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setHeadAndPropagate</span><span style="color:#24292E;">(Node node, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> propagate) {</span></span>
<span class="line"><span style="color:#24292E;">    Node h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">setHead</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// propagate &gt; 0 表示获取到了共享锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// h == null || h.waitStatus &lt; 0 表示当前头节点已经不再是有效节点，可能是被取消或者已经释放了锁，需要进行传播。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 再次判断头节点，防止在设置头节点的过程中发生竞争</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (propagate </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> h.waitStatus </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">        (h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> h.waitStatus </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        Node s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.next;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 判断如果后继节点为空或者是共享节点，就开始传播共享锁</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">isShared</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">doReleaseShared</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>上面第五步，获取锁失败后，取消当前节点的逻辑：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 取消获取锁</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">cancelAcquire</span><span style="color:#E1E4E8;">(Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 判空</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 1. 设置线程为null，不再持有锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    node.thread </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 2. 如果前驱节点是取消状态，继续向前遍历，找到不是取消状态的前驱节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node pred </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.prev;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (pred.waitStatus </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        node.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred.prev;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    Node predNext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred.next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 3. 把当前节点设置为取消状态，不再获取锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    node.waitStatus </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Node.CANCELLED;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 4. 判断如果当前节点是尾节点，就删除当前节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> tail </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compareAndSetTail</span><span style="color:#E1E4E8;">(node, pred)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">compareAndSetNext</span><span style="color:#E1E4E8;">(pred, predNext, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 5. 判断后继节点是否需要被唤醒</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ws;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (pred </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> head </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">            ((ws </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred.waitStatus) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Node.SIGNAL </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">                (ws </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(pred, ws, Node.SIGNAL))) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">            pred.thread </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            Node next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (next </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> next.waitStatus </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 6. 删除当前节点</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">compareAndSetNext</span><span style="color:#E1E4E8;">(pred, predNext, next);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 7. 唤醒后继节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">unparkSuccessor</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        node.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 取消获取锁</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">cancelAcquire</span><span style="color:#24292E;">(Node node) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 判空</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 1. 设置线程为null，不再持有锁</span></span>
<span class="line"><span style="color:#24292E;">    node.thread </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 2. 如果前驱节点是取消状态，继续向前遍历，找到不是取消状态的前驱节点</span></span>
<span class="line"><span style="color:#24292E;">    Node pred </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.prev;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (pred.waitStatus </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        node.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred.prev;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    Node predNext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred.next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 3. 把当前节点设置为取消状态，不再获取锁</span></span>
<span class="line"><span style="color:#24292E;">    node.waitStatus </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Node.CANCELLED;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 4. 判断如果当前节点是尾节点，就删除当前节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> tail </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compareAndSetTail</span><span style="color:#24292E;">(node, pred)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">compareAndSetNext</span><span style="color:#24292E;">(pred, predNext, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 5. 判断后继节点是否需要被唤醒</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ws;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (pred </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> head </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">            ((ws </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred.waitStatus) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> Node.SIGNAL </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">                (ws </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(pred, ws, Node.SIGNAL))) </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">            pred.thread </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            Node next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.next;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (next </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> next.waitStatus </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 6. 删除当前节点</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">compareAndSetNext</span><span style="color:#24292E;">(pred, predNext, next);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 7. 唤醒后继节点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">unparkSuccessor</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        node.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="释放锁-1" tabindex="-1">释放锁 <a class="header-anchor" href="#释放锁-1" aria-label="Permalink to &quot;释放锁&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 释放锁，传参是1，表示释放锁一次</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">releaseShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 先尝试释放锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">tryReleaseShared</span><span style="color:#E1E4E8;">(arg)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 释放锁成功后，要执行的逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">doReleaseShared</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 释放锁，传参是1，表示释放锁一次</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">releaseShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 先尝试释放锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">tryReleaseShared</span><span style="color:#24292E;">(arg)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 释放锁成功后，要执行的逻辑</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">doReleaseShared</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>释放锁成功后，要执行的 doReleaseShared() 方法，作用是：</p><ol><li>传播共享锁</li><li>唤醒同步队列中线程</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 释放锁成功后要执行的逻辑</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doReleaseShared</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (; ; ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 判断是否等于尾节点，如果是尾节点，就不用传播了</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> tail) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 判断节点状态，如果是SIGNAL，则需要被唤醒</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ws </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> h.waitStatus;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Node.SIGNAL) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 重置head节点状态，表示开始唤醒下个节点。如果重置失败，说明发生了竞争，需要再次尝试。</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(h, Node.SIGNAL, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 唤醒下一个节点</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">unparkSuccessor</span><span style="color:#E1E4E8;">(h);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 如果节点状态是0，则需要设置成PROPAGATE，继续传播</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(h, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, Node.PROPAGATE)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果头节点没变，表示循环中没有进行头节点的修改，说明已经处理完了需要唤醒的节点，可以退出循环。</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> head) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 释放锁成功后要执行的逻辑</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doReleaseShared</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (; ; ) {</span></span>
<span class="line"><span style="color:#24292E;">        Node h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 判断是否等于尾节点，如果是尾节点，就不用传播了</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> tail) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 判断节点状态，如果是SIGNAL，则需要被唤醒</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ws </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> h.waitStatus;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> Node.SIGNAL) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 重置head节点状态，表示开始唤醒下个节点。如果重置失败，说明发生了竞争，需要再次尝试。</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(h, Node.SIGNAL, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 唤醒下一个节点</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">unparkSuccessor</span><span style="color:#24292E;">(h);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 如果节点状态是0，则需要设置成PROPAGATE，继续传播</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(h, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, Node.PROPAGATE)) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果头节点没变，表示循环中没有进行头节点的修改，说明已经处理完了需要唤醒的节点，可以退出循环。</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> head) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="q-a" tabindex="-1">Q&amp;A <a class="header-anchor" href="#q-a" aria-label="Permalink to &quot;Q&amp;A&quot;">​</a></h2><blockquote><p><strong>为什么 AQS 同步队列使用双链表实现，而条件队列使用单链表实现？</strong></p></blockquote><p>1、同步队列竞争激烈，需要频繁插入、删除 2、同步队列需要支持非公平锁，中间插入、删除节点更方便</p></div></div></main><footer class="VPDocFooter" data-v-6b87e69f data-v-ef5dee53><!--[--><!--]--><div class="edit-info" data-v-ef5dee53><!----><div class="last-updated" data-v-ef5dee53><p class="VPLastUpdated" data-v-ef5dee53 data-v-7e05ebdb>Last updated: <time datetime="2024-06-23T02:42:04.000Z" data-v-7e05ebdb></time></p></div></div><nav class="prev-next" data-v-ef5dee53><div class="pager" data-v-ef5dee53><a class="pager-link prev" href="/java/juc/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html" data-v-ef5dee53><span class="desc" data-v-ef5dee53>Previous page</span><span class="title" data-v-ef5dee53>2.阻塞队列</span></a></div><div class="pager" data-v-ef5dee53><a class="pager-link next" href="/java/juc/Synchronized.html" data-v-ef5dee53><span class="desc" data-v-ef5dee53>Next page</span><span class="title" data-v-ef5dee53>2.Synchronized</span></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"elasticsearch_elasticsearch调优.md\":\"444e03c3\",\"framework_index.md\":\"c07754e2\",\"elasticsearch_elk.md\":\"882a1e66\",\"framework_alibaba_index.md\":\"d2900f4f\",\"framework_alibaba_dubbo.md\":\"bf10ea3c\",\"elasticsearch_elasticsearch.md\":\"3be6eb8d\",\"framework_alibaba_zookeeper.md\":\"233a4203\",\"framework_alibaba_nacos.md\":\"cc154aaa\",\"ai_chatgpt使用指南.md\":\"d2c3299c\",\"2024_模块设计模板.md\":\"2c44af24\",\"framework_alibaba_sentinel.md\":\"91042ade\",\"framework_springcloud_springcloudgateway.md\":\"73556a26\",\"framework_springcloud_springcloud.md\":\"99e29ea1\",\"framework_springboot_springboot插件开发.md\":\"53c735d6\",\"framework_springcloud_hystrix.md\":\"01db41f2\",\"elasticsearch_elasticsearch生产实践.md\":\"cfe9af5a\",\"java_juc_synchronized.md\":\"dd6697c5\",\"中间件_数据库中间件_db_oracle_oracle.md\":\"1741fe03\",\"framework_spring_spring使用注意事项和总结.md\":\"4623af52\",\"k8s_k8s.md\":\"e53f4d58\",\"中间件_消息中间件_kafka.md\":\"48a2c402\",\"framework_springcloud_springcloudstream.md\":\"880ebba7\",\"更新日志_index.md\":\"bccdf842\",\"mysql_mysql常见问题及解决方案.md\":\"0084596c\",\"中间件_extend_权限框架_权限设计概述.md\":\"1869fd15\",\"java_juc_condition.md\":\"569cb3fd\",\"java_juc_readwritelock.md\":\"3c4b2bf3\",\"java_juc_exchanger.md\":\"ef9ac460\",\"mybatis_mybatisplus.md\":\"f4d6105c\",\"中间件_extend_权限框架_oauth2.md\":\"d27e9339\",\"中间件_extend_服务器_netty.md\":\"3be37f4c\",\"rabbitmq_rabbitmq.md\":\"7a300c94\",\"中间件_extend_分布式任务_powerjob.md\":\"53a22456\",\"中间件_extend_分布式任务_xxljob.md\":\"bd0c4063\",\"framework_springboot_springboot.md\":\"ea3b9fff\",\"java_jvm_jvm调优.md\":\"5dc8c303\",\"中间件_数据库中间件_druid_druid.md\":\"5deb03d7\",\"中间件_数据库中间件_canal_canal.md\":\"676c49d9\",\"java_juc_threadlocal.md\":\"f5d87663\",\"中间件_数据库中间件_db_postgresql_postgresql.md\":\"c5f6c61b\",\"mysql_mysql性能优化.md\":\"1cbbe805\",\"framework_springcloud_openfeign.md\":\"3d8af820\",\"shardingjdbc_分库分表.md\":\"5ad6fd48\",\"mysql_mysql索引.md\":\"a0de6f84\",\"系统设计_ddd设计的一次落地实践.md\":\"006efa2b\",\"redis_redisson.md\":\"edfda178\",\"中间件_extend_工作流_compileflow.md\":\"f2d6e110\",\"中间件_extend_工作流_工作流概述.md\":\"b9ef1076\",\"中间件_extend_工作流_flowable.md\":\"19f5c425\",\"mongodb_mongodb.md\":\"21306d61\",\"中间件_extend_工作流_liteflow.md\":\"83ebc8c1\",\"redis_redis.md\":\"68920969\",\"系统设计_秒杀系统设计.md\":\"0735c329\",\"中间件_extend_服务器_nginx.md\":\"b2e60468\",\"系统设计_订单系统设计.md\":\"0455ce82\",\"java_juc_线程池.md\":\"a5733cff\",\"系统设计_如何做好架构设计.md\":\"9773925c\",\"系统设计_日志系统设计.md\":\"bd84d8f9\",\"系统设计_分布式事务设计.md\":\"ac0c5788\",\"mysql_mysql.md\":\"7517d308\",\"shardingjdbc_shardingjdbc示例.md\":\"49a00e2c\",\"index.md\":\"bb1075d1\",\"中间件_数据库中间件_db_tidb_tidb.md\":\"8d15eec5\",\"中间件_extend_权限框架_satoken.md\":\"0784c1c8\",\"规范_redis规范.md\":\"320ef2ff\",\"java_juc_cyclicbarrier.md\":\"9f619c8c\",\"中间件_消息中间件_pulsar使用注意事项和总结.md\":\"d33f61d2\",\"生产事件_taimei_institution-svc反复重启事故.md\":\"45c6afc7\",\"生产事件_other_线上pod死锁案例.md\":\"c10219f9\",\"mybatis_mybatis应用.md\":\"ed036107\",\"mysql_mysql锁.md\":\"66e14a19\",\"生产事件_other_线上服务器端口故障.md\":\"2559b729\",\"生产事件_taimei_territory-svc内存溢出.md\":\"a1a767d2\",\"redis_redis应用.md\":\"d451cf4e\",\"mybatis_mybatis.md\":\"24cde3b5\",\"mysql_mysql事务.md\":\"6da6c2ad\",\"java_juc_volatile.md\":\"c30d0a96\",\"生产事件_如何做好性能优化.md\":\"7bfe465d\",\"mysql_mysql高可用.md\":\"6e1eb1e3\",\"系统设计_分布式id设计.md\":\"67ea62bd\",\"生产事件_线上环境指标定义.md\":\"e61f7f40\",\"系统设计_灰度架构设计.md\":\"29190aff\",\"规范_mysql规范.md\":\"d5835bfc\",\"笔记_linux.md\":\"aec03624\",\"系统设计_多级缓存架构设计.md\":\"c2e3b67b\",\"java_juc_semaphore.md\":\"0d9943f5\",\"笔记_dev.md\":\"19055630\",\"生产事件_如何排查生产问题.md\":\"0dc463eb\",\"java_juc_aqs.md\":\"792b15fd\",\"shardingjdbc_shardingjdbc.md\":\"bef6394c\",\"中间件_消息中间件_pulsar.md\":\"e882c695\",\"大数据_数仓分层.md\":\"c7bd729b\",\"java_juc_原子类.md\":\"3a95b2e7\",\"java_juc_reentrantlock.md\":\"1831f149\",\"生产事件_taimei_sfe-affiliate接口优化.md\":\"9c23680f\",\"java_juc_多线程基础.md\":\"e6f6abb4\",\"java_juc_countdownlatch.md\":\"ad531796\",\"framework_alibaba_seata.md\":\"ab73ed06\",\"笔记_docker.md\":\"ced4d05f\",\"java_juc_completablefuture.md\":\"99f0a488\",\"系统设计_mysql-es数据初始化同步方案.md\":\"0a9ca20b\",\"java_jvm_jvm基础.md\":\"61718788\",\"rocketmq_rocketmq.md\":\"6e99b758\",\"java_juc_并发容器.md\":\"63ab7ad4\",\"java_juc_阻塞队列.md\":\"928b5d7f\",\"framework_spring_spring.md\":\"a8d24ce7\",\"java_java.md\":\"409ab104\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"doc\",\"description\":\"在线文档\",\"base\":\"/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"siteTitle\":\"TheWe1\",\"logo\":\"/logo.png\",\"nav\":[{\"text\":\"研发提效\",\"items\":[{\"text\":\"规范\",\"link\":\"/规范/MySQL规范\"},{\"text\":\"笔记\",\"link\":\"/笔记/dev\"}]},{\"text\":\"生产事件\",\"items\":[{\"text\":\"线上环境指标定义\",\"link\":\"/生产事件/线上环境指标定义\"},{\"text\":\"如何做好性能优化\",\"link\":\"/生产事件/如何做好性能优化\"},{\"text\":\"如何排查生产问题\",\"link\":\"/生产事件/如何排查生产问题\"}]},{\"text\":\"系统设计\",\"items\":[{\"text\":\"如何做好架构设计\",\"link\":\"/系统设计/如何做好架构设计\"}]},{\"text\":\"更新日志\",\"link\":\"/更新日志/index\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/liuxiaowei2018\"}],\"search\":{\"provider\":\"local\"},\"lastUpdated\":\"Last Updated\",\"smoothScroll\":true,\"sidebar\":{\"/java\":[{\"text\":\"JavaSE\",\"collapsible\":true,\"items\":[{\"text\":\"1.java基础\",\"link\":\"/java/java\"},{\"text\":\"2.并发编程\",\"link\":\"/java/juc/多线程基础\"},{\"text\":\"3.虚拟机\",\"link\":\"/java/jvm/jvm基础\"}]}],\"/java/juc\":[{\"text\":\"并发编程基础\",\"collapsible\":true,\"items\":[{\"text\":\"1.多线程基础\",\"link\":\"/java/juc/多线程基础\"},{\"text\":\"2.原子类\",\"link\":\"/java/juc/原子类\"},{\"text\":\"3.ThreadLocal\",\"link\":\"/java/juc/ThreadLocal\"}]},{\"text\":\"并发容器\",\"collapsible\":true,\"items\":[{\"text\":\"1.并发容器\",\"link\":\"/java/juc/并发容器\"},{\"text\":\"2.阻塞队列\",\"link\":\"/java/juc/阻塞队列\"}]},{\"text\":\"锁\",\"collapsible\":true,\"items\":[{\"text\":\"1.AQS\",\"link\":\"/java/juc/AQS\"},{\"text\":\"2.Synchronized\",\"link\":\"/java/juc/Synchronized\"},{\"text\":\"3.ReentrantLock\",\"link\":\"/java/juc/ReentrantLock\"},{\"text\":\"4.ReadWriteLock\",\"link\":\"/java/juc/ReadWriteLock\"}]},{\"text\":\"并发工具类\",\"collapsible\":true,\"items\":[{\"text\":\"1.CountDownLatch\",\"link\":\"/java/juc/CountDownLatch\"},{\"text\":\"2.Semaphore\",\"link\":\"/java/juc/Semaphore\"},{\"text\":\"3.CyclicBarrier\",\"link\":\"/java/juc/CyclicBarrier\"},{\"text\":\"4.Exchanger\",\"link\":\"/java/juc/Exchanger\"},{\"text\":\"5.Condition\",\"link\":\"/java/juc/Condition\"},{\"text\":\"6.CompletableFuture\",\"link\":\"/java/juc/CompletableFuture\"}]},{\"text\":\"线程池\",\"collapsible\":true,\"items\":[{\"text\":\"线程池\",\"link\":\"/java/juc/线程池\"}]}],\"/java/jvm\":[{\"text\":\"虚拟机\",\"collapsible\":true,\"items\":[{\"text\":\"1.jvm基础\",\"link\":\"/java/jvm/jvm基础\"},{\"text\":\"2.jvm调优\",\"link\":\"/java/jvm/jvm调优\"}]}],\"/framework\":[{\"text\":\"常用开发框架\",\"collapsible\":true,\"items\":[{\"text\":\"Java开发框架概述\",\"link\":\"/framework/index\"}]},{\"text\":\"spring\",\"collapsible\":true,\"items\":[{\"text\":\"spring\",\"link\":\"/framework/spring/spring\"},{\"text\":\"spring使用注意事项和总结\",\"link\":\"/framework/spring/spring使用注意事项和总结\"}]},{\"text\":\"springboot\",\"collapsible\":true,\"items\":[{\"text\":\"springBoot\",\"link\":\"/framework/springboot/springBoot\"},{\"text\":\"SpringBoot插件开发\",\"link\":\"/framework/springboot/springBoot插件开发\"}]},{\"text\":\"springCloud\",\"collapsible\":true,\"items\":[{\"text\":\"springCloud\",\"link\":\"/framework/springcloud/openFeign\"}]},{\"text\":\"springCloudAlibaba\",\"collapsible\":true,\"items\":[{\"text\":\"springCloudAlibaba\",\"link\":\"/framework/alibaba/dubbo\"}]}],\"/framework/springcloud\":[{\"text\":\"SpringCloud\",\"collapsible\":true,\"items\":[{\"text\":\"springCloudOpenFeign\",\"link\":\"/framework/springcloud/openFeign\"},{\"text\":\"springCloudHystrix\",\"link\":\"/framework/springcloud/hystrix\"},{\"text\":\"springCloudGateway\",\"link\":\"/framework/springcloud/springCloudGateway\"},{\"text\":\"springCloudStream\",\"link\":\"/framework/springcloud/springCloudStream\"}]}],\"/framework/alibaba\":[{\"text\":\"SpringCloudAlibaba\",\"collapsible\":true,\"items\":[{\"text\":\"dubbo\",\"link\":\"/framework/alibaba/dubbo\"},{\"text\":\"nacos\",\"link\":\"/framework/alibaba/nacos\"},{\"text\":\"seata\",\"link\":\"/framework/alibaba/seata\"},{\"text\":\"sentinel\",\"link\":\"/framework/alibaba/sentinel\"},{\"text\":\"zookeeper\",\"link\":\"/framework/alibaba/zookeeper\"}]}],\"/mysql\":[{\"text\":\"mysql\",\"collapsible\":true,\"items\":[{\"text\":\"1.MySQL概述\",\"link\":\"/mysql/mysql\"},{\"text\":\"2.mysql索引\",\"link\":\"/mysql/mysql索引\"},{\"text\":\"3.MySQL事务\",\"link\":\"/mysql/mysql事务\"},{\"text\":\"4.MySQL性能优化\",\"link\":\"/mysql/mysql性能优化\"},{\"text\":\"5.MySQL常见问题及解决方案\",\"link\":\"/mysql/mysql常见问题及解决方案\"},{\"text\":\"6.MySQL高可用\",\"link\":\"/mysql/mysql高可用\"}]}],\"/elasticsearch\":[{\"text\":\"elasticsearch\",\"collapsible\":true,\"items\":[{\"text\":\"elasticsearch基础\",\"link\":\"/elasticsearch/elasticsearch\"},{\"text\":\"Elasticsearch调优\",\"link\":\"/elasticsearch/Elasticsearch调优\"},{\"text\":\"Elasticsearch生产实践\",\"link\":\"/elasticsearch/Elasticsearch生产实践\"},{\"text\":\"ELK日志平台\",\"link\":\"/elasticsearch/ELK\"}]}],\"/mongodb\":[{\"text\":\"mongodb\",\"collapsible\":true,\"items\":[{\"text\":\"mongoDB\",\"link\":\"/mongodb/mongoDB\"}]}],\"/mybatis\":[{\"text\":\"mybatis\",\"collapsible\":true,\"items\":[{\"text\":\"mybatis\",\"link\":\"/mybatis/mybatis\"},{\"text\":\"mybatis应用\",\"link\":\"/mybatis/mybatis应用\"}]},{\"text\":\"mybatisPlus\",\"collapsible\":true,\"items\":[{\"text\":\"mybatisPlus\",\"link\":\"/mybatis/mybatisPlus\"}]}],\"/redis\":[{\"text\":\"redis\",\"collapsible\":true,\"items\":[{\"text\":\"redis\",\"link\":\"/redis/redis\"},{\"text\":\"redis应用\",\"link\":\"/redis/redis应用\"}]},{\"text\":\"redisson\",\"collapsible\":true,\"items\":[{\"text\":\"redisson\",\"link\":\"/redis/redisson\"}]}],\"/shardingjdbc\":[{\"text\":\"分库分表\",\"collapsible\":true,\"items\":[{\"text\":\"分库分表概述\",\"link\":\"/shardingjdbc/分库分表\"}]},{\"text\":\"shardingJdbc\",\"collapsible\":true,\"items\":[{\"text\":\"shardingJdbc\",\"link\":\"/shardingjdbc/shardingJdbc\"},{\"text\":\"shardingJdbc示例\",\"link\":\"/shardingjdbc/shardingJdbc示例\"}]}],\"/rabbitmq\":[{\"text\":\"消息中间件\",\"collapsible\":true,\"items\":[{\"text\":\"rabbitMQ\",\"link\":\"/rabbitmq/rabbitMQ\"}]}],\"/rocketmq\":[{\"text\":\"消息中间件\",\"collapsible\":true,\"items\":[{\"text\":\"rocketMQ\",\"link\":\"/rocketmq/rocketMQ\"}]}],\"/中间件\":[{\"text\":\"数据库\",\"collapsible\":true,\"items\":[{\"text\":\"PostgreSQL\",\"link\":\"/中间件/数据库中间件/db/postgresql/postgreSQL\"},{\"text\":\"Oracle\",\"link\":\"/中间件/数据库中间件/db/oracle/oracle\"},{\"text\":\"TiDB\",\"link\":\"/中间件/数据库中间件/db/tidb/tiDB\"}]},{\"text\":\"数据库中间件-连接池\",\"collapsible\":true,\"items\":[{\"text\":\"druid\",\"link\":\"/中间件/数据库中间件/druid/druid\"}]},{\"text\":\"数据库中间件-ETL\",\"collapsible\":true,\"items\":[{\"text\":\"canal\",\"link\":\"/中间件/数据库中间件/canal/canal\"}]},{\"text\":\"消息中间件\",\"collapsible\":true,\"items\":[{\"text\":\"kafka\",\"link\":\"/中间件/消息中间件/kafka\"},{\"text\":\"pulsar\",\"link\":\"/中间件/消息中间件/pulsar\"}]},{\"text\":\"分布式任务\",\"collapsible\":true,\"items\":[{\"text\":\"xxlJob\",\"link\":\"/中间件/extend/分布式任务/xxlJob\"},{\"text\":\"powerJob\",\"link\":\"/中间件/extend/分布式任务/powerJob\"}]},{\"text\":\"工作流\",\"collapsible\":true,\"items\":[{\"text\":\"工作流概述\",\"link\":\"/中间件/extend/工作流/工作流概述\"}]},{\"text\":\"工作流框架\",\"collapsible\":true,\"items\":[{\"text\":\"flowable\",\"link\":\"/中间件/extend/工作流/flowable\"},{\"text\":\"compileflow\",\"link\":\"/中间件/extend/工作流/compileflow\"},{\"text\":\"liteflow\",\"link\":\"/中间件/extend/工作流/liteflow\"}]},{\"text\":\"权限设计\",\"collapsible\":true,\"items\":[{\"text\":\"权限设计概述\",\"link\":\"/中间件/extend/权限框架/权限设计概述\"}]},{\"text\":\"权限框架\",\"collapsible\":true,\"items\":[{\"text\":\"oauth2\",\"link\":\"/中间件/extend/权限框架/oauth2\"},{\"text\":\"saToken\",\"link\":\"/中间件/extend/权限框架/saToken\"}]}],\"/笔记\":[{\"text\":\"笔记\",\"collapsible\":true,\"items\":[{\"text\":\"1.开发环境配置\",\"link\":\"/笔记/dev\"},{\"text\":\"2.linux\",\"link\":\"/笔记/linux\"},{\"text\":\"3.docker\",\"link\":\"/笔记/docker\"}]}],\"/规范\":[{\"text\":\"开发规范\",\"collapsible\":true,\"items\":[{\"text\":\"1.MySQL规范\",\"link\":\"/规范/MySQL规范\"},{\"text\":\"2.Redis规范\",\"link\":\"/规范/Redis规范\"}]}],\"/生产事件\":[{\"text\":\"线上指标\",\"collapsible\":true,\"items\":[{\"text\":\"线上环境指标定义\",\"link\":\"/生产事件/线上环境指标定义\"}]},{\"text\":\"性能优化\",\"collapsible\":true,\"items\":[{\"text\":\"如何做好性能优化\",\"link\":\"/生产事件/如何做好性能优化\"},{\"text\":\"sfe-affiliate接口优化\",\"link\":\"/生产事件/taimei/sfe-affiliate接口优化\"}]},{\"text\":\"事件排查\",\"collapsible\":true,\"items\":[{\"text\":\"如何排查生产问题\",\"link\":\"/生产事件/如何排查生产问题\"},{\"text\":\"线上服务器端口故障\",\"link\":\"/生产事件/other/线上服务器端口故障\"},{\"text\":\"线上pod死锁案例\",\"link\":\"/生产事件/other/线上pod死锁案例\"},{\"text\":\"territory-svc内存溢出\",\"link\":\"/生产事件/taimei/territory-svc内存溢出\"},{\"text\":\"institution-svc反复重启事故\",\"link\":\"/生产事件/taimei/institution-svc反复重启事故\"}]}],\"/系统设计\":[{\"text\":\"系统设计\",\"collapsible\":true,\"items\":[{\"text\":\"1.如何做好架构设计\",\"link\":\"/系统设计/如何做好架构设计\"},{\"text\":\"2.分布式ID设计\",\"link\":\"/系统设计/分布式ID设计\"},{\"text\":\"3.多级缓存架构设计\",\"link\":\"/系统设计/多级缓存架构设计\"},{\"text\":\"4.日志系统设计\",\"link\":\"/系统设计/日志系统设计\"},{\"text\":\"5.分布式事务设计\",\"link\":\"/系统设计/分布式事务设计\"},{\"text\":\"6.灰度架构设计\",\"link\":\"/系统设计/灰度架构设计\"},{\"text\":\"7.秒杀系统设计\",\"link\":\"/系统设计/秒杀系统设计\"},{\"text\":\"8.订单系统设计\",\"link\":\"/系统设计/订单系统设计\"},{\"text\":\"9.Mysql-ES数据初始化同步方案\",\"link\":\"/系统设计/Mysql-ES数据初始化同步方案\"},{\"text\":\"10.DDD设计的一次落地实践\",\"link\":\"/系统设计/DDD设计的一次落地实践\"}]}]}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}");</script>
    
  </body>
</html>