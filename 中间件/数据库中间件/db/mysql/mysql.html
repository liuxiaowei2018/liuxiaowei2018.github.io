<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL | 某不知名小开发</title>
    <meta name="description" content="在线文档">
    <link rel="preload stylesheet" href="/assets/style.edc773f7.css" as="style">
    
    <script type="module" src="/assets/app.fdb777a7.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.8048b864.js">
    <link rel="modulepreload" href="/assets/chunks/theme.4a9c9a8b.js">
    <link rel="modulepreload" href="/assets/中间件_数据库中间件_db_mysql_mysql.md.1bf51dc8.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5a346dfe><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5a346dfe data-v-ae24b3ad><div class="VPNavBar has-sidebar" data-v-ae24b3ad data-v-a0fd61f4><div class="container" data-v-a0fd61f4><div class="title" data-v-a0fd61f4><div class="VPNavBarTitle has-sidebar" data-v-a0fd61f4 data-v-86d1bed8><a class="title" href="/" data-v-86d1bed8><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo.png" alt data-v-8426fc1a><!--]--><!--[-->伟酱<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-a0fd61f4><div class="curtain" data-v-a0fd61f4></div><div class="content-body" data-v-a0fd61f4><!--[--><!--]--><div class="VPNavBarSearch search" data-v-a0fd61f4><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg class="DocSearch-Search-Icon" width="20" height="20" viewBox="0 0 20 20" aria-label="search icon"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-a0fd61f4 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/index.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>更新日志</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-9c007e85><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-9c007e85><span class="text" data-v-9c007e85><!----><span data-v-9c007e85>经验</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-9c007e85><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-9c007e85><div class="VPMenu" data-v-9c007e85 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/index.html" data-v-43f1e123><!--[-->生产问题记录<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E7%94%9F%E4%BA%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20230802q1.html" data-v-43f1e123><!--[-->生产性能优化<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E7%9F%A5%E8%AF%86%E9%80%9F%E6%9F%A5%E5%BA%93/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93.html" data-v-43f1e123><!--[-->知识速查库<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/%E5%B7%A5%E5%85%B7%E9%9B%86/index.html" data-v-43f1e123><!--[-->工具集<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-a0fd61f4 data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-e6aabb21 data-v-ce54a7d1 data-v-b1685198><span class="check" data-v-b1685198><span class="icon" data-v-b1685198><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-ce54a7d1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-ce54a7d1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-a0fd61f4 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/liuxiaowei2018" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-f80f8133><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-a0fd61f4 data-v-40855f84 data-v-9c007e85><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-9c007e85><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-9c007e85><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-9c007e85><div class="VPMenu" data-v-9c007e85 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-40855f84 data-v-ce54a7d1 data-v-b1685198><span class="check" data-v-b1685198><span class="icon" data-v-b1685198><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-ce54a7d1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-ce54a7d1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-40855f84><div class="item social-links" data-v-40855f84><div class="VPSocialLinks social-links-list" data-v-40855f84 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/liuxiaowei2018" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-f80f8133><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-a0fd61f4 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav reached-top" data-v-5a346dfe data-v-79c8c1df><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-79c8c1df><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-79c8c1df><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-79c8c1df>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-79c8c1df data-v-1c15a60a><button data-v-1c15a60a>Return to top</button><!----></div></div><aside class="VPSidebar" data-v-5a346dfe data-v-b00e2fdd><div class="curtain" data-v-b00e2fdd></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-b00e2fdd><span class="visually-hidden" id="sidebar-aria-label" data-v-b00e2fdd> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-b00e2fdd><section class="VPSidebarItem level-0" data-v-b00e2fdd data-v-e31bd47b><div class="item" role="button" tabindex="0" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><h2 class="text" data-v-e31bd47b>数据库</h2><!----></div><div class="items" data-v-e31bd47b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/database/mysql.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>1.MySQL</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/database/oracle.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>3.Oracle</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/database/postgreSQL.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>4.PostgreSQL</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/database/mongoDB.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>5.MongoDB</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/database/tiDB.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>6.TiDB</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5a346dfe data-v-669faec9><div class="VPDoc has-sidebar has-aside" data-v-669faec9 data-v-6b87e69f><!--[--><!--]--><div class="container" data-v-6b87e69f><div class="aside" data-v-6b87e69f><div class="aside-curtain" data-v-6b87e69f></div><div class="aside-container" data-v-6b87e69f><div class="aside-content" data-v-6b87e69f><div class="VPDocAside" data-v-6b87e69f data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-3f215769 data-v-d330b1bb><div class="content" data-v-d330b1bb><div class="outline-marker" data-v-d330b1bb></div><div class="outline-title" role="heading" aria-level="2" data-v-d330b1bb>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-d330b1bb><span class="visually-hidden" id="doc-outline-aria-label" data-v-d330b1bb> Table of Contents for current page </span><ul class="root" data-v-d330b1bb data-v-d0ee3533><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-6b87e69f><div class="content-container" data-v-6b87e69f><!--[--><!--]--><!----><main class="main" data-v-6b87e69f><div style="position:relative;" class="vp-doc _%E4%B8%AD%E9%97%B4%E4%BB%B6_%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6_db_mysql_mysql" data-v-6b87e69f><div><h1 id="mysql" tabindex="-1">MySQL <a class="header-anchor" href="#mysql" aria-label="Permalink to &quot;MySQL&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#_1、mysql应用">1、MySQL应用</a><ul><li><a href="#_1-1、sql执行过程">1.1、SQL执行过程</a></li><li><a href="#_1-2、查询性能优化">1.2、查询性能优化</a></li><li><a href="#_1-3、sql优化">1.3、SQL优化</a></li><li><a href="#_1-4、常见参数">1.4、常见参数</a></li><li><a href="#_1-5、数据操作">1.5、数据操作</a></li></ul></li><li><a href="#_2、mysql扩展">2、MySQL扩展</a><ul><li><a href="#_1-1、存储引擎">1.1、存储引擎</a></li><li><a href="#_1-2、缓冲池">1.2、缓冲池</a></li><li><a href="#_1-3、索引">1.3、索引</a></li><li><a href="#_1-4、事务">1.4、事务</a></li><li><a href="#_1-5、mvcc">1.5、MVCC</a></li><li><a href="#_1-6、锁">1.6、锁</a></li><li><a href="#_1-7、分库分表">1.7、分库分表</a></li><li><a href="#_1-8、主从复制">1.8、主从复制</a></li><li><a href="#_1-9、读写分离">1.9、读写分离</a></li></ul></li></ul></nav><h2 id="_1、mysql应用" tabindex="-1">1、MySQL应用 <a class="header-anchor" href="#_1、mysql应用" aria-label="Permalink to &quot;1、MySQL应用&quot;">​</a></h2><h3 id="_1-1、sql执行过程" tabindex="-1">1.1、SQL执行过程 <a class="header-anchor" href="#_1-1、sql执行过程" aria-label="Permalink to &quot;1.1、SQL执行过程&quot;">​</a></h3><h4 id="sql整体执行过程" tabindex="-1">sql整体执行过程 <a class="header-anchor" href="#sql整体执行过程" aria-label="Permalink to &quot;sql整体执行过程&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301620542.png" alt="img"></p><h4 id="执行状态" tabindex="-1">执行状态 <a class="header-anchor" href="#执行状态" aria-label="Permalink to &quot;执行状态&quot;">​</a></h4><p>通过命令:<code>show full processlist</code>，展示所有的处理进程</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621894.png" alt="2021-09-04-13-21-33-100573.png"></p><h4 id="sql执行顺序" tabindex="-1">sql执行顺序 <a class="header-anchor" href="#sql执行顺序" aria-label="Permalink to &quot;sql执行顺序&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621804.png" alt="2021-09-04-13-21-33-280552.png"></p><h4 id="内连接-外连接区别" tabindex="-1">内连接|外连接区别 <a class="header-anchor" href="#内连接-外连接区别" aria-label="Permalink to &quot;内连接|外连接区别&quot;">​</a></h4><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621236.png" alt="image-20231012165607635"></p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- INNER JOIN（内连接）</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`t1`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">inner join</span><span style="color:#E1E4E8;"> t2 </span><span style="color:#F97583;">on</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t1</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t2</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- LEFT JOIN（左连接）</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`t1`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">left join</span><span style="color:#E1E4E8;"> t2 </span><span style="color:#F97583;">on</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t1</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t2</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- LEFT JOIN EXCLUDING INNER JOIN（左连接-内连接）</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`t1`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">left join</span><span style="color:#E1E4E8;"> t2 </span><span style="color:#F97583;">on</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t1</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t2</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">WHERE</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t2</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">is</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">null</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- RIGHT JOIN（右连接）</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`t1`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">right join</span><span style="color:#E1E4E8;"> t2 </span><span style="color:#F97583;">on</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t1</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t2</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- RIGHT JOIN EXCLUDING INNER JOIN（右连接-内连接）</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`t1`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">right join</span><span style="color:#E1E4E8;"> t2 </span><span style="color:#F97583;">on</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t1</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t2</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">WHERE</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">t1</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">is</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">null</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- INNER JOIN（内连接）</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`t1`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">inner join</span><span style="color:#24292E;"> t2 </span><span style="color:#D73A49;">on</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t1</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t2</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- LEFT JOIN（左连接）</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`t1`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">left join</span><span style="color:#24292E;"> t2 </span><span style="color:#D73A49;">on</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t1</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t2</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- LEFT JOIN EXCLUDING INNER JOIN（左连接-内连接）</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`t1`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">left join</span><span style="color:#24292E;"> t2 </span><span style="color:#D73A49;">on</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t1</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t2</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;">  </span><span style="color:#D73A49;">WHERE</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t2</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">is</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">null</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- RIGHT JOIN（右连接）</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`t1`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">right join</span><span style="color:#24292E;"> t2 </span><span style="color:#D73A49;">on</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t1</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t2</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- RIGHT JOIN EXCLUDING INNER JOIN（右连接-内连接）</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`t1`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">right join</span><span style="color:#24292E;"> t2 </span><span style="color:#D73A49;">on</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t1</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t2</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;">  </span><span style="color:#D73A49;">WHERE</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">t1</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">is</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">null</span></span></code></pre></div><h3 id="_1-2、查询性能优化" tabindex="-1">1.2、查询性能优化 <a class="header-anchor" href="#_1-2、查询性能优化" aria-label="Permalink to &quot;1.2、查询性能优化&quot;">​</a></h3><h4 id="查看执行频次" tabindex="-1">查看执行频次 <a class="header-anchor" href="#查看执行频次" aria-label="Permalink to &quot;查看执行频次&quot;">​</a></h4><p>sql 客户端连接成功后，通过<code>show [session|global] status</code> 命令可以提供服务器状态信息，通过如下指令可以查看数据的INSERT，UPDATE，DELETE，SELECT 的访问频次</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">SHOW </span><span style="color:#F97583;">GLOBAL</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">STATUS</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">LIKE</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;Com_______&#39;</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">SHOW </span><span style="color:#D73A49;">GLOBAL</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">STATUS</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">LIKE</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;Com_______&#39;</span><span style="color:#24292E;">;</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621100.png" alt="在这里插入图片描述"></p><h4 id="慢查询日志" tabindex="-1">慢查询日志 <a class="header-anchor" href="#慢查询日志" aria-label="Permalink to &quot;慢查询日志&quot;">​</a></h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL 语句的日志。</p><p>sql 的慢查询日志默认没有开启，需要在sql 的配置文件（/etc/my.cnf）中配置如下信息：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 开启慢查询日志开关</span></span>
<span class="line"><span style="color:#E1E4E8;">slow_query_log</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;"># 设置慢查询日志时间为2秒</span></span>
<span class="line"><span style="color:#E1E4E8;">long_query_time</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 开启慢查询日志开关</span></span>
<span class="line"><span style="color:#24292E;">slow_query_log</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;"># 设置慢查询日志时间为2秒</span></span>
<span class="line"><span style="color:#24292E;">long_query_time</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">2</span></span></code></pre></div><p>配置完毕之后，重启sql 服务器，查看慢日志文件中的记录信息 <code>/var/lib/sql/localhost-slow.log</code>。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># Time 2022-03-05T15:45:39.688679Z</span></span>
<span class="line"><span style="color:#6A737D;"># User@Host: root[root] @ locahost [] Id: 8</span></span>
<span class="line"><span style="color:#6A737D;"># Query_time: 13.350650 Lock_time 0.000358 Rows_sent: 1 Rows_examined: 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">use</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">xxx</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#B392F0;">SET</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">timestamp=</span><span style="color:#79B8FF;">1635435926</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> count(1) from user_operation_log;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># Time 2022-03-05T15:45:39.688679Z</span></span>
<span class="line"><span style="color:#6A737D;"># User@Host: root[root] @ locahost [] Id: 8</span></span>
<span class="line"><span style="color:#6A737D;"># Query_time: 13.350650 Lock_time 0.000358 Rows_sent: 1 Rows_examined: 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">use</span><span style="color:#24292E;"> </span><span style="color:#032F62;">xxx</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6F42C1;">SET</span><span style="color:#24292E;"> </span><span style="color:#032F62;">timestamp=</span><span style="color:#005CC5;">1635435926</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> count(1) from user_operation_log;</span></span></code></pre></div><h4 id="show-profiles" tabindex="-1">show profiles <a class="header-anchor" href="#show-profiles" aria-label="Permalink to &quot;show profiles&quot;">​</a></h4><p><code>show profile</code>能够在做SQL优化是帮助我们了解时间都消耗到哪里去了，通过have_profiling 参数，能够看到当前sql 是否支持profile操作</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> @@have_profiling;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> @@have_profiling;</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621229.png" alt="在这里插入图片描述"></p><p>默认profiling 是关闭的 （<code>select @@profiling</code>），可以通过set 语句在session/global 级别开启profiling:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">SET</span><span style="color:#E1E4E8;"> profiling </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">SET</span><span style="color:#24292E;"> profiling </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span></code></pre></div><p>执行一系列的业务SQL的操作，然后通过如下指令查看SQL 的执行耗时</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 查看每一条SQL的耗时情况</span></span>
<span class="line"><span style="color:#E1E4E8;">show profiles;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 查看指定Query_id的SQL语句各个阶段的耗时情况</span></span>
<span class="line"><span style="color:#E1E4E8;">show </span><span style="color:#F97583;">profile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> query query_id;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 查看query_id的SQL cpu使用情况</span></span>
<span class="line"><span style="color:#E1E4E8;">show </span><span style="color:#F97583;">profile</span><span style="color:#E1E4E8;"> cpu </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> query query_id;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 查看每一条SQL的耗时情况</span></span>
<span class="line"><span style="color:#24292E;">show profiles;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 查看指定Query_id的SQL语句各个阶段的耗时情况</span></span>
<span class="line"><span style="color:#24292E;">show </span><span style="color:#D73A49;">profile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> query query_id;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 查看query_id的SQL cpu使用情况</span></span>
<span class="line"><span style="color:#24292E;">show </span><span style="color:#D73A49;">profile</span><span style="color:#24292E;"> cpu </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> query query_id;</span></span></code></pre></div><p>执行了3条SQL</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user_operation_log </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;456465&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;">  user_operation_log </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> user_id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;15646&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user_operation_log </span><span style="color:#F97583;">LIMIT</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10000</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user_operation_log </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;456465&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;">  user_operation_log </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> user_id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;15646&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user_operation_log </span><span style="color:#D73A49;">LIMIT</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10000</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">;</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621861.png" alt="在这里插入图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621104.png" alt="在这里插入图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621933.png" alt="在这里插入图片描述"></p><h4 id="trace" tabindex="-1">trace <a class="header-anchor" href="#trace" aria-label="Permalink to &quot;trace&quot;">​</a></h4><p>trace 分析优化器如何选择执行计划，通过 trace 文件能够进一步了解为什么优惠券选择 A 执行计划而不选择 B 执行计划。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">set</span><span style="color:#E1E4E8;"> optimizer_trace</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;enabled=on&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">set</span><span style="color:#E1E4E8;"> optimizer_trace_max_mem_size</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">1000000</span><span style="color:#E1E4E8;">;	</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">information_schema</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">optimizer_trace</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">set</span><span style="color:#24292E;"> optimizer_trace</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;enabled=on&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">set</span><span style="color:#24292E;"> optimizer_trace_max_mem_size</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">1000000</span><span style="color:#24292E;">;	</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">information_schema</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">optimizer_trace</span><span style="color:#24292E;">;</span></span></code></pre></div><h4 id="explain-执行计划" tabindex="-1">explain 执行计划 <a class="header-anchor" href="#explain-执行计划" aria-label="Permalink to &quot;explain 执行计划&quot;">​</a></h4><blockquote><p>详见 <code>sql</code>官方文档 ：<a href="https://dev.sql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge" target="_blank" rel="noreferrer">https://dev.sql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge</a></p></blockquote><p>EXPLAIN 或者 DESC 命令获取sql 如何语句的信息，包括在SELECT 语句执行过程中表如何连接和连接顺序</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 在SQL语句前加上关键字 EXPLAIN</span></span>
<span class="line"><span style="color:#E1E4E8;">EXPLAIN </span><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> col0,clo1,... </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> table_name </span><span style="color:#F97583;">WHERE</span><span style="color:#E1E4E8;"> condition;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 在SQL语句前加上关键字 EXPLAIN</span></span>
<span class="line"><span style="color:#24292E;">EXPLAIN </span><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> col0,clo1,... </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> table_name </span><span style="color:#D73A49;">WHERE</span><span style="color:#24292E;"> condition;</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621845.png" alt="在这里插入图片描述"></p><p>当<code>Explain</code> 与 <code>SQL</code>语句一起使用时，<code>sql</code> 会显示来自优化器关于SQL执行的信息。也就是说，<code>sql</code>解释了它将如何处理该语句，包括如何连接表以及什么顺序连接表等。</p><ul><li>表的加载顺序</li><li><code>sql</code> 的查询类型</li><li>可能用到哪些索引，哪些索引又被实际使用</li><li>表与表之间的引用关系</li><li>一个表中有多少行被优化器查询</li></ul><p><code>Explain</code> 执行计划包含字段信息如下：分别是</p><p><code>id</code>、<code>select_type</code>、<code>table</code>、<code>partitions</code>、<code>type</code>、<code>possible_keys</code>、<code>key</code>、<code>key_len</code>、<code>ref</code>、<code>rows</code>、<code>filtered</code>、<code>Extra</code> 12个字段。</p><h5 id="_1-id-执行顺序" tabindex="-1">1.id 执行顺序 <a class="header-anchor" href="#_1-id-执行顺序" aria-label="Permalink to &quot;1.id 执行顺序&quot;">​</a></h5><p><code>id：</code> ：表示查询中执行select子句或者操作表的顺序，<strong><code>id</code>的值越大，代表优先级越高，越先执行</strong>。<code>id</code>大致会出现 3种情况：</p><h6 id="id相同" tabindex="-1">id相同 <a class="header-anchor" href="#id相同" aria-label="Permalink to &quot;id相同&quot;">​</a></h6><p>看到三条记录的<code>id</code>都相同，可以理解成这三个表为一组，具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定。</p><h6 id="id不同" tabindex="-1">id不同 <a class="header-anchor" href="#id不同" aria-label="Permalink to &quot;id不同&quot;">​</a></h6><p>如果我们的 <code>SQL</code> 中存在子查询，那么 <code>id</code>的序号会递增，<code>id</code>值越大优先级越高，越先被执行 。当三个表依次嵌套，发现最里层的子查询 <code>id</code>最大，最先执行。</p><h6 id="以上两种同时存在" tabindex="-1">以上两种同时存在 <a class="header-anchor" href="#以上两种同时存在" aria-label="Permalink to &quot;以上两种同时存在&quot;">​</a></h6><p>相同<code>id</code>划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组 <code>id</code>值越大，优先级越高，越先执行。</p><h5 id="_2-select-type-查询类型" tabindex="-1">2.select_type 查询类型 <a class="header-anchor" href="#_2-select-type-查询类型" aria-label="Permalink to &quot;2.select_type 查询类型&quot;">​</a></h5><blockquote><p><code>select_type</code>：表示 <code>select</code> 查询的类型，主要是用于区分各种复杂的查询，例如：<code>普通查询</code>、<code>联合查询</code>、<code>子查询</code>等。</p></blockquote><h6 id="simple" tabindex="-1">SIMPLE <a class="header-anchor" href="#simple" aria-label="Permalink to &quot;SIMPLE&quot;">​</a></h6><p>表示最简单的 select 查询语句，也就是在查询中不包含子查询或者 <code>union</code>交并差集等操作。</p><h6 id="primary" tabindex="-1">PRIMARY <a class="header-anchor" href="#primary" aria-label="Permalink to &quot;PRIMARY&quot;">​</a></h6><p>当查询语句中包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</p><h6 id="subquery" tabindex="-1">SUBQUERY <a class="header-anchor" href="#subquery" aria-label="Permalink to &quot;SUBQUERY&quot;">​</a></h6><p>当 <code>select</code> 或 <code>where</code> 列表中包含了<strong>子查询</strong>，该子查询被标记为：<code>SUBQUERY</code> 。</p><h6 id="derived" tabindex="-1">DERIVED <a class="header-anchor" href="#derived" aria-label="Permalink to &quot;DERIVED&quot;">​</a></h6><p>表示包含在<code>from</code>子句中的子查询的select，在我们的 <code>from</code> 列表中包含的子查询会被标记为<code>derived</code> 。</p><h6 id="union" tabindex="-1">UNION <a class="header-anchor" href="#union" aria-label="Permalink to &quot;UNION&quot;">​</a></h6><p>如果<code>union</code>后边又出现的<code>select</code> 语句，则会被标记为<code>union</code>；若 <code>union</code> 包含在 <code>from</code> 子句的子查询中，外层 <code>select</code> 将被标记为 <code>derived</code>。</p><h6 id="union-result" tabindex="-1">UNION RESULT <a class="header-anchor" href="#union-result" aria-label="Permalink to &quot;UNION RESULT&quot;">​</a></h6><p>代表从<code>union</code>的临时表中读取数据</p><h5 id="_3-table-查询表名" tabindex="-1">3.table 查询表名 <a class="header-anchor" href="#_3-table-查询表名" aria-label="Permalink to &quot;3.table 查询表名&quot;">​</a></h5><blockquote><p>查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表</p></blockquote><h5 id="_4-partitions-分区信息" tabindex="-1">4.partitions 分区信息 <a class="header-anchor" href="#_4-partitions-分区信息" aria-label="Permalink to &quot;4.partitions 分区信息&quot;">​</a></h5><blockquote><p>查询时匹配到的分区信息，对于非分区表值为<code>NULL</code>，当查询的是分区表时，<code>partitions</code>显示分区表命中的分区情况。</p></blockquote><h5 id="_5-type-索引查询类型" tabindex="-1">5.type 索引查询类型 <a class="header-anchor" href="#_5-type-索引查询类型" aria-label="Permalink to &quot;5.type 索引查询类型&quot;">​</a></h5><blockquote><p><strong>由上至下，效率越来越高</strong></p><ul><li>ALL 全表扫描</li><li>index 索引全扫描</li><li>range 索引范围扫描，常用语&lt;,&lt;=,&gt;=,between,in等操作</li><li>ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</li><li>eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询</li><li>const/system 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询</li><li>null sql不访问任何表或索引，直接返回结果</li></ul><p><strong>经常用到的索引查询类型</strong></p><ul><li>const：使用主键或者唯一索引进行查询的时候只有一行匹配</li><li>ref：使用非唯一索引</li><li>range：使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询</li><li>index：和all的区别是扫描的是索引树</li><li>all：扫描全表</li></ul></blockquote><h6 id="system" tabindex="-1">system <a class="header-anchor" href="#system" aria-label="Permalink to &quot;system&quot;">​</a></h6><blockquote><p><strong>触发条件：表只有一行，这是一个 const type 的特殊情况</strong></p></blockquote><h6 id="const" tabindex="-1">const <a class="header-anchor" href="#const" aria-label="Permalink to &quot;const&quot;">​</a></h6><blockquote><p><strong>触发条件：在使用主键或者唯一索引进行查询的时候只有一行匹配。</strong></p></blockquote><h6 id="eq-ref" tabindex="-1">eq_ref <a class="header-anchor" href="#eq-ref" aria-label="Permalink to &quot;eq_ref&quot;">​</a></h6><blockquote><p><strong>触发条件：在进行联接查询的，使用主键或者唯一索引并且只匹配到一行记录的时候</strong></p></blockquote><h6 id="ref" tabindex="-1">ref <a class="header-anchor" href="#ref" aria-label="Permalink to &quot;ref&quot;">​</a></h6><blockquote><p>区别于<code>eq_ref</code> ，<code>ref</code>表示使用非唯一性索引，会找到很多个符合条件的行。</p><p><strong>触发条件：使用非唯一索引</strong></p></blockquote><h6 id="ref-or-null" tabindex="-1">ref_or_null <a class="header-anchor" href="#ref-or-null" aria-label="Permalink to &quot;ref_or_null&quot;">​</a></h6><blockquote><p>这种连接类型类似于 ref，区别在于 <code>sql</code>会额外搜索包含<code>NULL</code>值的行。</p></blockquote><h6 id="index-merge" tabindex="-1">index_merge <a class="header-anchor" href="#index-merge" aria-label="Permalink to &quot;index_merge&quot;">​</a></h6><blockquote><p><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。</p></blockquote><h6 id="unique-subquery" tabindex="-1">unique_subquery <a class="header-anchor" href="#unique-subquery" aria-label="Permalink to &quot;unique_subquery&quot;">​</a></h6><blockquote><p><code>unique_subquery</code>：替换下面的 <code>IN</code>子查询，子查询返回不重复的集合。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">value</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">IN</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> primary_key </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> single_table </span><span style="color:#F97583;">WHERE</span><span style="color:#E1E4E8;"> some_expr)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">IN</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> primary_key </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> single_table </span><span style="color:#D73A49;">WHERE</span><span style="color:#24292E;"> some_expr)</span></span></code></pre></div></blockquote><h6 id="index-subquery" tabindex="-1">index_subquery <a class="header-anchor" href="#index-subquery" aria-label="Permalink to &quot;index_subquery&quot;">​</a></h6><blockquote><p><code>index_subquery</code>：区别于<code>unique_subquery</code>，用于非唯一索引，可以返回重复值。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">value</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">IN</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> key_column </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> single_table </span><span style="color:#F97583;">WHERE</span><span style="color:#E1E4E8;"> some_expr)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">IN</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> key_column </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> single_table </span><span style="color:#D73A49;">WHERE</span><span style="color:#24292E;"> some_expr)</span></span></code></pre></div></blockquote><h6 id="range" tabindex="-1">range <a class="header-anchor" href="#range" aria-label="Permalink to &quot;range&quot;">​</a></h6><blockquote><p><strong>触发条件：只有在使用 主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段 进行范围查询 才是 range</strong></p><p>使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在<code>where</code>语句中使用 <code>bettween...and</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>in</code> 等条件查询 <code>type</code> 都是 <code>range</code>。</p></blockquote><h6 id="index" tabindex="-1">index <a class="header-anchor" href="#index" aria-label="Permalink to &quot;index&quot;">​</a></h6><blockquote><p>触发条件：只扫描索引树</p><p>1）查询的字段是索引的一部分，覆盖索引。</p><p>2）使用主键进行排序</p></blockquote><h6 id="all" tabindex="-1">ALL <a class="header-anchor" href="#all" aria-label="Permalink to &quot;ALL&quot;">​</a></h6><blockquote><p>触发条件：全表扫描，不走索引</p></blockquote><h5 id="_6-possible-keys-可能索引" tabindex="-1">6.possible_keys 可能索引 <a class="header-anchor" href="#_6-possible-keys-可能索引" aria-label="Permalink to &quot;6.possible_keys 可能索引&quot;">​</a></h5><blockquote><p><code>possible_keys</code>：表示在<code>sql</code>中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，<strong>但这个索引并不定一会是最终查询数据时所被用到的索引</strong>。</p></blockquote><h5 id="_7-key-实际索引" tabindex="-1">7.key 实际索引 <a class="header-anchor" href="#_7-key-实际索引" aria-label="Permalink to &quot;7.key 实际索引&quot;">​</a></h5><blockquote><p><code>key</code>：区别于<code>possible_keys</code>，key是查询中实际使用到的索引，若没有使用索引，显示为<code>NULL</code>。</p><blockquote><p>当 <code>type</code> 为 <code>index_merge</code> 时，可能会显示多个索引。</p></blockquote></blockquote><h5 id="_8-key-len-索引长度" tabindex="-1">8.key_len 索引长度 <a class="header-anchor" href="#_8-key-len-索引长度" aria-label="Permalink to &quot;8.key_len 索引长度&quot;">​</a></h5><blockquote><p><code>key_len</code>：表示查询用到的索引长度（字节数），原则上长度越短越好 。</p><ul><li>单列索引，那么需要将整个索引长度算进去；</li><li>多列索引，不是所有列都能用到，需要计算查询中实际用到的列。</li></ul><blockquote><p>注意：<code>key_len</code>只计算<code>where</code>条件中用到的索引长度，而排序和分组即便是用到了索引，也不会计算到<code>key_len</code>中。</p></blockquote></blockquote><h5 id="_9-ref-关联字段名" tabindex="-1">9.ref 关联字段名 <a class="header-anchor" href="#_9-ref-关联字段名" aria-label="Permalink to &quot;9.ref  关联字段名&quot;">​</a></h5><blockquote><p><code>ref</code>：常见的有：<code>const</code>，<code>func</code>，<code>null</code>，字段名。</p><ul><li>当使用常量等值查询，显示<code>const</code>，</li><li>当关联查询时，会显示相应关联表的<code>关联字段</code></li><li>如果查询条件使用了<code>表达式</code>、<code>函数</code>，或者条件列发生内部隐式转换，可能显示为<code>func</code></li><li>其他情况<code>null</code></li></ul></blockquote><h5 id="_10-rows-读取行数" tabindex="-1">10.rows 读取行数 <a class="header-anchor" href="#_10-rows-读取行数" aria-label="Permalink to &quot;10.rows 读取行数&quot;">​</a></h5><blockquote><p><code>rows</code>：以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。</p><p>这是评估<code>SQL</code> 性能的一个比较重要的数据，<code>sql</code>需要扫描的行数，很直观的显示 <code>SQL</code> 性能的好坏，一般情况下 <code>rows</code> 值越小越好。</p></blockquote><h5 id="_11-filtered-记录数百分比" tabindex="-1">11.filtered 记录数百分比 <a class="header-anchor" href="#_11-filtered-记录数百分比" aria-label="Permalink to &quot;11.filtered 记录数百分比&quot;">​</a></h5><blockquote><p><code>filtered</code> 这个是一个百分比的值，表里符合条件的记录数的百分比。这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例.在<code>sql5.7</code>以前版本想要显示<code>filtered</code>需要使用<code>explain extended</code>命令。<code>sql.5.7</code>后，默认<code>explain</code>直接显示<code>partitions</code>和<code>filtered</code>的信息</p></blockquote><h5 id="_12-extra-额外信息" tabindex="-1">12.Extra 额外信息 <a class="header-anchor" href="#_12-extra-额外信息" aria-label="Permalink to &quot;12.Extra 额外信息&quot;">​</a></h5><h6 id="using-index" tabindex="-1">Using index <a class="header-anchor" href="#using-index" aria-label="Permalink to &quot;Using index&quot;">​</a></h6><blockquote><p><code>Using index</code>：我们在相应的 <code>select</code> 操作中使用了覆盖索引，通俗一点讲就是查询的列被索引覆盖，使用到覆盖索引查询速度会非常快，<code>SQl</code>优化中理想的状态。</p></blockquote><h6 id="using-index-condition" tabindex="-1">Using index condition <a class="header-anchor" href="#using-index-condition" aria-label="Permalink to &quot;Using index condition&quot;">​</a></h6><blockquote><p>**Using index condition：**sql5.6 之后新增的 ICP，using index condtion 就是可能使用了 ICP（索引下推）</p><p>在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</p></blockquote><h6 id="using-where" tabindex="-1">Using where <a class="header-anchor" href="#using-where" aria-label="Permalink to &quot;Using where&quot;">​</a></h6><blockquote><p><code>Using where</code>：查询时未找到可用的索引，进而通过<code>where</code>条件过滤获取所需数据，但要注意的是并不是所有带<code>where</code>语句的查询都会显示<code>Using where</code>。</p><p>下边示例<code>create_time</code> 并未用到索引，<code>type</code> 为 <code>ALL</code>，即<code>sql</code>通过全表扫描后再按<code>where</code>条件筛选数据。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql&gt; EXPLAIN SELECT one_name from one where create_time =&#39;2020-05-18&#39;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql&gt; EXPLAIN SELECT one_name from one where create_time =&#39;2020-05-18&#39;;</span></span></code></pre></div></blockquote><h6 id="using-temporary" tabindex="-1">Using temporary <a class="header-anchor" href="#using-temporary" aria-label="Permalink to &quot;Using temporary&quot;">​</a></h6><blockquote><p><code>Using temporary</code>：表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到。<strong>性能很差</strong>，需要重点优化</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql&gt; EXPLAIN SELECT one_name from one where one_id in (1,2) group by one_name;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql&gt; EXPLAIN SELECT one_name from one where one_id in (1,2) group by one_name;</span></span></code></pre></div></blockquote><h6 id="using-filesort" tabindex="-1">Using filesort <a class="header-anchor" href="#using-filesort" aria-label="Permalink to &quot;Using filesort&quot;">​</a></h6><blockquote><p><code>Using filesort</code>：表示无法利用索引完成的排序操作，也就是<code>ORDER BY</code>的字段没有索引，<strong>性能较差</strong>，通常这样的SQL都是需要优化的。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql&gt; EXPLAIN SELECT one_id from one  ORDER BY create_time;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql&gt; EXPLAIN SELECT one_id from one  ORDER BY create_time;</span></span></code></pre></div><p>如果<code>ORDER BY</code>字段有索引就会用到覆盖索引，相比执行速度快很多。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql&gt; EXPLAIN SELECT one_id from one  ORDER BY one_id;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql&gt; EXPLAIN SELECT one_id from one  ORDER BY one_id;</span></span></code></pre></div></blockquote><h6 id="using-join-buffer" tabindex="-1">Using join buffer <a class="header-anchor" href="#using-join-buffer" aria-label="Permalink to &quot;Using join buffer&quot;">​</a></h6><blockquote><p><code>Using join buffer</code>：在我们联表查询的时候，如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果。</p></blockquote><h6 id="impossible-where" tabindex="-1">Impossible where <a class="header-anchor" href="#impossible-where" aria-label="Permalink to &quot;Impossible where&quot;">​</a></h6><blockquote><p><code>Impossible where</code>：表示在我们用不太正确的<code>where</code>语句，导致没有符合条件的行。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql&gt; EXPLAIN SELECT one_name from one WHERE 1=2;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql&gt; EXPLAIN SELECT one_name from one WHERE 1=2;</span></span></code></pre></div></blockquote><h6 id="no-tables-used" tabindex="-1">No tables used <a class="header-anchor" href="#no-tables-used" aria-label="Permalink to &quot;No tables used&quot;">​</a></h6><blockquote><p><code>No tables used</code>：我们的查询语句中没有<code>FROM</code>子句，或者有 <code>FROM DUAL</code>子句。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql&gt; EXPLAIN select now();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql&gt; EXPLAIN select now();</span></span></code></pre></div></blockquote><table><thead><tr><th style="text-align:center;">列</th><th style="text-align:center;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">id</td><td style="text-align:center;">select 查询的序号，表示查询中的执行select 子句或者操作表的顺序（id相同，顺序从上到下，id 不同值越大越先执行）</td></tr><tr><td style="text-align:center;">select_type</td><td style="text-align:center;">表示 SELECT 的类型，常见的取值有 SIMPLE （简单表，不使用表连接和子查询），PRIMIAY（主查询，即外层的查询），UNION ，SUBQUERY （select/where 之后包含了子查询）等</td></tr><tr><td style="text-align:center;">table</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">partitions</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;"><strong>type</strong></td><td style="text-align:center;">表示连接的类型，性能由好到差的连接类型为 NULL，system，const，eq_ref，ref，range，index，all</td></tr><tr><td style="text-align:center;"><strong>possible_keys</strong></td><td style="text-align:center;">可能用到的索引</td></tr><tr><td style="text-align:center;"><strong>key</strong></td><td style="text-align:center;">实际用到的索引</td></tr><tr><td style="text-align:center;"><strong>key_len</strong></td><td style="text-align:center;">表示索引使用的字节数</td></tr><tr><td style="text-align:center;">ref</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">rows</td><td style="text-align:center;">查询预估值</td></tr><tr><td style="text-align:center;">filtered</td><td style="text-align:center;">返回结果占读取行数的百分比，越大越好</td></tr><tr><td style="text-align:center;">Extra</td><td style="text-align:center;">额外信息</td></tr></tbody></table><h4 id="优化数据访问" tabindex="-1">优化数据访问 <a class="header-anchor" href="#优化数据访问" aria-label="Permalink to &quot;优化数据访问&quot;">​</a></h4><blockquote><h6 id="减少请求的数据量" tabindex="-1">减少请求的数据量 <a class="header-anchor" href="#减少请求的数据量" aria-label="Permalink to &quot;减少请求的数据量&quot;">​</a></h6><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h6 id="减少服务器端扫描的行数" tabindex="-1">减少服务器端扫描的行数 <a class="header-anchor" href="#减少服务器端扫描的行数" aria-label="Permalink to &quot;减少服务器端扫描的行数&quot;">​</a></h6><p>最有效的方式是使用索引来覆盖查询。</p></blockquote><h4 id="重构查询方式" tabindex="-1">重构查询方式 <a class="header-anchor" href="#重构查询方式" aria-label="Permalink to &quot;重构查询方式&quot;">​</a></h4><blockquote><h6 id="切分大查询" tabindex="-1">切分大查询 <a class="header-anchor" href="#切分大查询" aria-label="Permalink to &quot;切分大查询&quot;">​</a></h6><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">DELETE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> messages </span><span style="color:#F97583;">WHERE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">create</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> DATE_SUB(</span><span style="color:#F97583;">NOW</span><span style="color:#E1E4E8;">(), INTERVAL </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">MONTH</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">----------&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">rows_affected </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">do {</span></span>
<span class="line"><span style="color:#E1E4E8;">rows_affected </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> do_query(</span></span>
<span class="line"><span style="color:#9ECBFF;">&quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> rows_affected </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">DELETE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> messages </span><span style="color:#D73A49;">WHERE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">create</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> DATE_SUB(</span><span style="color:#D73A49;">NOW</span><span style="color:#24292E;">(), INTERVAL </span><span style="color:#005CC5;">3</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">MONTH</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">----------&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">rows_affected </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">do {</span></span>
<span class="line"><span style="color:#24292E;">rows_affected </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> do_query(</span></span>
<span class="line"><span style="color:#032F62;">&quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> rows_affected </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span></code></pre></div><h6 id="分解大连接查询" tabindex="-1">分解大连接查询 <a class="header-anchor" href="#分解大连接查询" aria-label="Permalink to &quot;分解大连接查询&quot;">​</a></h6><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。</li></ul></blockquote><h3 id="_1-3、sql优化" tabindex="-1">1.3、SQL优化 <a class="header-anchor" href="#_1-3、sql优化" aria-label="Permalink to &quot;1.3、SQL优化&quot;">​</a></h3><h4 id="插入数据" tabindex="-1">插入数据 <a class="header-anchor" href="#插入数据" aria-label="Permalink to &quot;插入数据&quot;">​</a></h4><h5 id="批量操作" tabindex="-1">批量操作 <a class="header-anchor" href="#批量操作" aria-label="Permalink to &quot;批量操作&quot;">​</a></h5><p>2-1000条</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">insert into</span><span style="color:#E1E4E8;"> emp (</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;1&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;柳岩&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;女&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;123456789012345678&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;北京&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;2000-01-01&#39;</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#E1E4E8;">       (</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;2&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;张无忌&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;男&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">18</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;123456789012345670&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;北京&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;2005-09-01&#39;</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">insert into</span><span style="color:#24292E;"> emp (</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;1&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;柳岩&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;女&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">20</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;123456789012345678&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;北京&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;2000-01-01&#39;</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">       (</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;2&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;张无忌&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;男&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">18</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;123456789012345670&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;北京&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;2005-09-01&#39;</span><span style="color:#24292E;">);</span></span></code></pre></div><p>手动提交事务</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">start transaction</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">insert</span><span style="color:#E1E4E8;"> ....</span></span>
<span class="line"><span style="color:#F97583;">commit</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">start transaction</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">insert</span><span style="color:#24292E;"> ....</span></span>
<span class="line"><span style="color:#D73A49;">commit</span><span style="color:#24292E;">;</span></span></code></pre></div><p>如果一次性涉及大批量数据，insert 语句性能较低，此时可以使用sql 的load 指令进行插入</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># 客户端连接服务器时，加上参数，--local-infile</span></span>
<span class="line"><span style="color:#B392F0;">sql</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--local-infile</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-uroot</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-p</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 设置全局参数local-infile 为1 开启从本地加载文件导入数据的开关</span></span>
<span class="line"><span style="color:#79B8FF;">set</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">global</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">local_infile</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 执行load 指令将准备好的数据，加载到表结构当中</span></span>
<span class="line"><span style="color:#B392F0;">load</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">data</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">local</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">file</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;/home/xxx.log&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">into</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">table</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;xxx&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">fields</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">terminated</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">by</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;,&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">lines</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">terminated</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;\n&#39;</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># 客户端连接服务器时，加上参数，--local-infile</span></span>
<span class="line"><span style="color:#6F42C1;">sql</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--local-infile</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-uroot</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-p</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 设置全局参数local-infile 为1 开启从本地加载文件导入数据的开关</span></span>
<span class="line"><span style="color:#005CC5;">set</span><span style="color:#24292E;"> </span><span style="color:#032F62;">global</span><span style="color:#24292E;"> </span><span style="color:#032F62;">local_infile</span><span style="color:#24292E;"> </span><span style="color:#032F62;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 执行load 指令将准备好的数据，加载到表结构当中</span></span>
<span class="line"><span style="color:#6F42C1;">load</span><span style="color:#24292E;"> </span><span style="color:#032F62;">data</span><span style="color:#24292E;"> </span><span style="color:#032F62;">local</span><span style="color:#24292E;"> </span><span style="color:#032F62;">file</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;/home/xxx.log&#39;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">into</span><span style="color:#24292E;"> </span><span style="color:#032F62;">table</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;xxx&#39;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">fields</span><span style="color:#24292E;"> </span><span style="color:#032F62;">terminated</span><span style="color:#24292E;"> </span><span style="color:#032F62;">by</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;,&#39;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">lines</span><span style="color:#24292E;"> </span><span style="color:#032F62;">terminated</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;\n&#39;</span><span style="color:#24292E;">;</span></span></code></pre></div><h4 id="主键优化" tabindex="-1">主键优化 <a class="header-anchor" href="#主键优化" aria-label="Permalink to &quot;主键优化&quot;">​</a></h4><p>在InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index Organized Table IOT）。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301621862.png" alt="在这里插入图片描述"></p><p>一个Page 默认是16K ，一个Extent 是固定的，是1M。一个Page 是InnoDB 磁盘管理的最小单元。</p><h5 id="页分裂" tabindex="-1">页分裂 <a class="header-anchor" href="#页分裂" aria-label="Permalink to &quot;页分裂&quot;">​</a></h5><p>页可以为空，也可以填充一半，也可以填充满。每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排序。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301622557.png" alt="在这里插入图片描述"></p><p>首先会新获取一个page, 将page 页的50%之后的数据，迁移到新开辟的页面，就新数据50插入到新页面，然后重新设置页的表指针。这个操作成为页分裂。</p><h5 id="页合并" tabindex="-1">页合并 <a class="header-anchor" href="#页合并" aria-label="Permalink to &quot;页合并&quot;">​</a></h5><p>当删除一行记录时，实际上记录并没有被物理删除，而是被标记（flaged）为删除并且它的空间变得被其他记录声明使用。当页中删除的记录达到MERGE_THREADSHOLD(默认页的50%)，InnoDB 会开始寻找最靠近的页看看是否可以将2个页合并优化空间使用。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301622877.png" alt="在这里插入图片描述"></p><p>MERGE_THREADSHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p><h5 id="主键设计原则" tabindex="-1">主键设计原则 <a class="header-anchor" href="#主键设计原则" aria-label="Permalink to &quot;主键设计原则&quot;">​</a></h5><ul><li>满足业务需求的情况下，尽量降低主键的长度（二级索引存储聚集索引的值）。</li><li>插入数据时，尽量选择顺序插入，选择AUTO_INCREMENT 自增主键。</li><li>尽量不要使用UUID 做主键或者是其他自然主键。</li><li>业务操作时，避免对主键的修改。</li></ul><h4 id="order-by-优化" tabindex="-1">order by 优化 <a class="header-anchor" href="#order-by-优化" aria-label="Permalink to &quot;order by 优化&quot;">​</a></h4><ul><li>using filesort : 通过表的索引或者扫描权标，读取满足条件的数据行，然后在排序缓冲区sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都是 FileSort 排序。</li><li>using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</li></ul><p>将<code>emp</code>中的<code>idcard</code>索引删除。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 删除索引</span></span>
<span class="line"><span style="color:#F97583;">DROP</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> idx_id_card </span><span style="color:#F97583;">ON</span><span style="color:#E1E4E8;"> emp;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">EXPLAIN </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`emp`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">order by</span><span style="color:#E1E4E8;"> idcard;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">explain </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> id, workno, age,idcard  </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> emp </span><span style="color:#F97583;">order by</span><span style="color:#E1E4E8;"> workno </span><span style="color:#F97583;">desc</span><span style="color:#E1E4E8;">, age </span><span style="color:#F97583;">desc</span><span style="color:#E1E4E8;"> ,idcard </span><span style="color:#F97583;">desc</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 删除索引</span></span>
<span class="line"><span style="color:#D73A49;">DROP</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> idx_id_card </span><span style="color:#D73A49;">ON</span><span style="color:#24292E;"> emp;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">EXPLAIN </span><span style="color:#D73A49;">select</span><span style="color:#24292E;">  </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">  </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`emp`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> idcard;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">explain </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> id, workno, age,idcard  </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> emp </span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> workno </span><span style="color:#D73A49;">desc</span><span style="color:#24292E;">, age </span><span style="color:#D73A49;">desc</span><span style="color:#24292E;"> ,idcard </span><span style="color:#D73A49;">desc</span><span style="color:#24292E;">;</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301622782.png" alt="在这里插入图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301622551.png" alt="在这里插入图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301622510.png" alt="在这里插入图片描述"></p><p>然而根据最左原则，排序字段应该也要跟着索引指定的字段顺序进行排序</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301622253.png" alt="在这里插入图片描述"></p><p>当select 字段不出现在索引中，需要回表操作，此时，缓冲区会用filesort 进行排序。</p><p><strong>小结</strong></p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序，一个升序，一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC ）。</li><li>如果不可避免的出现filesort，大数据量排序，可适当增大排序缓冲区大小 sort_buffer_size（默认256k）。</li></ul><h4 id="group-by-优化" tabindex="-1">group by 优化 <a class="header-anchor" href="#group-by-优化" aria-label="Permalink to &quot;group by 优化&quot;">​</a></h4><p>先删除表上其他索引</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">drop</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">index</span><span style="color:#E1E4E8;"> xxx </span><span style="color:#F97583;">on</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">explain </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> workaddress,</span><span style="color:#79B8FF;">count</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> emp </span><span style="color:#F97583;">group by</span><span style="color:#E1E4E8;">  workaddress</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">drop</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">index</span><span style="color:#24292E;"> xxx </span><span style="color:#D73A49;">on</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">explain </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> workaddress,</span><span style="color:#005CC5;">count</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> emp </span><span style="color:#D73A49;">group by</span><span style="color:#24292E;">  workaddress</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301622702.png" alt="在这里插入图片描述"></p><p><code>Using temporary</code>使用临时表性能非常低。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 创建一个联合索引</span></span>
<span class="line"><span style="color:#F97583;">create</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">index</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">idx_add_gender</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">on</span><span style="color:#E1E4E8;"> emp(workaddress,gender);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">explain </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> workaddress,</span><span style="color:#79B8FF;">count</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> emp </span><span style="color:#F97583;">group by</span><span style="color:#E1E4E8;">  workaddress</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 创建一个联合索引</span></span>
<span class="line"><span style="color:#D73A49;">create</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">index</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">idx_add_gender</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">on</span><span style="color:#24292E;"> emp(workaddress,gender);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">explain </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> workaddress,</span><span style="color:#005CC5;">count</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> emp </span><span style="color:#D73A49;">group by</span><span style="color:#24292E;">  workaddress</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301622486.png" alt="在这里插入图片描述"></p><p>当group by 不满足最左前缀法则，则用不到索引，先会使用临时表。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301622702.png" alt="在这里插入图片描述"></p><p>当查询涉及如上的查询，在查询条件添加where 条件且刚好满足最左原则则查询可以使用索引。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301623325.png" alt="在这里插入图片描述"></p><p>分组操作时，索引的适合用也是尽可能满足最左前缀法则。</p><h4 id="limit-优化" tabindex="-1">limit 优化 <a class="header-anchor" href="#limit-优化" aria-label="Permalink to &quot;limit 优化&quot;">​</a></h4><p><code>user_operation_log</code>这张表有1000w的数据。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user_operation_log </span><span style="color:#F97583;">limit</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1000000</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">10</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user_operation_log </span><span style="color:#D73A49;">limit</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1000000</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">10</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301623837.png" alt="在这里插入图片描述"></p><p>时长显然是不可接受的。在对于limit 来说，大数据量的情况下，越往后效率越低，耗时越长。sql需要排序前N 条记录，仅仅返回N-(N+n)条记录，其他记录设计，查询排序的代价非常大。</p><p>官方推荐使用覆盖索引加子查询的方式。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301623469.png" alt="在这里插入图片描述"></p><p>sql 不支持此类语法 <s><code>select * from user_operation_log where id in (select id from user_operation_log order by id limit 1000000,10)</code></s>，8.0的版本不支持在 in 条件的子查询里使用<code>limit</code>，所以要修改写法。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user_operation_log u,(</span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user_operation_log </span><span style="color:#F97583;">order by</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">limit</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1000000</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">) a </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">u</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">a</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">id</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user_operation_log u,(</span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user_operation_log </span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">limit</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1000000</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">) a </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">u</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">a</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301623991.png" alt="在这里插入图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301623471.png" alt="在这里插入图片描述"></p><h4 id="count-优化" tabindex="-1">count 优化 <a class="header-anchor" href="#count-优化" aria-label="Permalink to &quot;count 优化&quot;">​</a></h4><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行<code>count(*)</code>的时候会直接返回这个数，效率很高。而在InnoDB 引擎就麻烦了，他执行<code>count(*)</code>的时候，需要把数据一行一行地从引擎里读，然后累积计数。</p><h5 id="count" tabindex="-1">count <a class="header-anchor" href="#count" aria-label="Permalink to &quot;count&quot;">​</a></h5><p><code>count()</code>是一个聚合函数，对于返回的结果集，一行行地判断，如果count() 函数的参数不是<code>NULL </code>就累加1，否则不加，最后返回累计值。</p><p>InnoDB 在<code>count(主键)</code>时，会遍历整张表，把每一行的主键ID的值都取出来，返回给服务层。服务层拿到主键后，直接进行累加（主键不可能为<code>null</code>）。</p><p>count(1)，遍历整张表，不取值，对于返回的每一层，放一个数字1，进行累加。</p><p>count(*)，InnoDB引擎不会把全部字段取出来，而是专门做了优化，直接按行进行累加。</p><p>按照效率 count(字段)&lt; count(pk)&lt; count(1)≈count(*)</p><h4 id="update-优化" tabindex="-1">update 优化 <a class="header-anchor" href="#update-优化" aria-label="Permalink to &quot;update 优化&quot;">​</a></h4><p>update 时候尽量使用ID作为条件更新，不然update 会因为没有索引，从而将行锁升级为表锁。InnoDB 的行锁只针对索引加的锁，不是针对记录加的锁，并且索引不能失效，否则会从行锁升级为表锁。</p><h3 id="_1-4、常见参数" tabindex="-1">1.4、常见参数 <a class="header-anchor" href="#_1-4、常见参数" aria-label="Permalink to &quot;1.4、常见参数&quot;">​</a></h3><h4 id="连接数" tabindex="-1">连接数 <a class="header-anchor" href="#连接数" aria-label="Permalink to &quot;连接数&quot;">​</a></h4><blockquote><p><strong>最大连接数设置</strong>：</p><p>Max_used_connections / max_connections * 100% ≈ 85% 最大连接数占上限连接数的85%左右，如果发现比例在10%以下，sql服务器连接数上限设置的过高了。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">-- sql最大连接数</span></span>
<span class="line"><span style="color:#e1e4e8;">sql&gt; show variables like &#39;max_connections&#39;; </span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">-- 服务器响应的最大连接数</span></span>
<span class="line"><span style="color:#e1e4e8;">sql&gt; show global status like ‘Max_used_connections’;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">-- sql最大连接数</span></span>
<span class="line"><span style="color:#24292e;">sql&gt; show variables like &#39;max_connections&#39;; </span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">-- 服务器响应的最大连接数</span></span>
<span class="line"><span style="color:#24292e;">sql&gt; show global status like ‘Max_used_connections’;</span></span></code></pre></div><h4 id="临时表" tabindex="-1">临时表 <a class="header-anchor" href="#临时表" aria-label="Permalink to &quot;临时表&quot;">​</a></h4><blockquote><p>每次创建临时表，Created_tmp_tables增加</p><p>如果是在磁盘上创建临时表，Created_tmp_disk_tables也增加【Created_tmp_files表示sql服务创建的临时文件文件数】</p><p>比较理想的配置是： 　　Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">-- 查询临时表</span></span>
<span class="line"><span style="color:#e1e4e8;">sql&gt; show global status like &#39;created_tmp%&#39;; </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+-------------------------+---------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+-------------------------+---------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Created_tmp_disk_tables | 21197 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Created_tmp_files | 58 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Created_tmp_tables | 1771587 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+-------------------------+---------+　　</span></span>
<span class="line"><span style="color:#e1e4e8;">　　</span></span>
<span class="line"><span style="color:#e1e4e8;">-- 只有256MB以下的临时表才能全部放内存，超过的就会用到硬盘临时表。</span></span>
<span class="line"><span style="color:#e1e4e8;">sql&gt; show variables where Variable_name in (&#39;tmp_table_size&#39;, &#39;max_heap_table_size&#39;); </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+---------------------+-----------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+---------------------+-----------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| max_heap_table_size | 268435456 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| tmp_table_size | 536870912 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+---------------------+-----------+</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">-- 查询临时表</span></span>
<span class="line"><span style="color:#24292e;">sql&gt; show global status like &#39;created_tmp%&#39;; </span></span>
<span class="line"><span style="color:#24292e;">　　+-------------------------+---------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#24292e;">　　+-------------------------+---------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| Created_tmp_disk_tables | 21197 | </span></span>
<span class="line"><span style="color:#24292e;">　　| Created_tmp_files | 58 | </span></span>
<span class="line"><span style="color:#24292e;">　　| Created_tmp_tables | 1771587 | </span></span>
<span class="line"><span style="color:#24292e;">　　+-------------------------+---------+　　</span></span>
<span class="line"><span style="color:#24292e;">　　</span></span>
<span class="line"><span style="color:#24292e;">-- 只有256MB以下的临时表才能全部放内存，超过的就会用到硬盘临时表。</span></span>
<span class="line"><span style="color:#24292e;">sql&gt; show variables where Variable_name in (&#39;tmp_table_size&#39;, &#39;max_heap_table_size&#39;); </span></span>
<span class="line"><span style="color:#24292e;">　　+---------------------+-----------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#24292e;">　　+---------------------+-----------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| max_heap_table_size | 268435456 | </span></span>
<span class="line"><span style="color:#24292e;">　　| tmp_table_size | 536870912 | </span></span>
<span class="line"><span style="color:#24292e;">　　+---------------------+-----------+</span></span></code></pre></div><h4 id="表锁" tabindex="-1">表锁 <a class="header-anchor" href="#表锁" aria-label="Permalink to &quot;表锁&quot;">​</a></h4><blockquote><p>Table_locks_immediate表示立即释放表锁数</p><p>Table_locks_waited表示需要等待的表锁数，</p><p>如果Table_locks_immediate / Table_locks_waited &gt; 5000，最好采用InnoDB引擎，因为InnoDB是行锁</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">-- 查询表锁情况</span></span>
<span class="line"><span style="color:#e1e4e8;">sql&gt; show global status like &#39;table_locks%&#39;; </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+-----------------------+-----------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+-----------------------+-----------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Table_locks_immediate | 490206328 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Table_locks_waited | 2084912 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+-----------------------+-----------+</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">-- 查询表锁情况</span></span>
<span class="line"><span style="color:#24292e;">sql&gt; show global status like &#39;table_locks%&#39;; </span></span>
<span class="line"><span style="color:#24292e;">　　+-----------------------+-----------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#24292e;">　　+-----------------------+-----------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| Table_locks_immediate | 490206328 | </span></span>
<span class="line"><span style="color:#24292e;">　　| Table_locks_waited | 2084912 | </span></span>
<span class="line"><span style="color:#24292e;">　　+-----------------------+-----------+</span></span></code></pre></div><h4 id="表扫描" tabindex="-1">表扫描 <a class="header-anchor" href="#表扫描" aria-label="Permalink to &quot;表扫描&quot;">​</a></h4><blockquote><p>计算表扫描率： 　　表扫描率 = Handler_read_rnd_next / Com_select 如果表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，增加read_buffer_size值(max=8MB)</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql&gt; show global status like &#39;handler_read%&#39;; 、</span></span>
<span class="line"><span style="color:#e1e4e8;">　　+-----------------------+-------------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+-----------------------+-------------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Handler_read_first | 5803750 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Handler_read_key | 6049319850 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Handler_read_next | 94440908210 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Handler_read_prev | 34822001724 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Handler_read_rnd | 405482605 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Handler_read_rnd_next | 18912877839 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+-----------------------+-------------+　　</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">-- 服务器完成的查询请求次数</span></span>
<span class="line"><span style="color:#e1e4e8;">sql&gt; show global status like &#39;com_select&#39;; </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+---------------+-----------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+---------------+-----------+ </span></span>
<span class="line"><span style="color:#e1e4e8;">　　| Com_select | 222693559 | </span></span>
<span class="line"><span style="color:#e1e4e8;">　　+---------------+-----------+</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql&gt; show global status like &#39;handler_read%&#39;; 、</span></span>
<span class="line"><span style="color:#24292e;">　　+-----------------------+-------------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#24292e;">　　+-----------------------+-------------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| Handler_read_first | 5803750 | </span></span>
<span class="line"><span style="color:#24292e;">　　| Handler_read_key | 6049319850 | </span></span>
<span class="line"><span style="color:#24292e;">　　| Handler_read_next | 94440908210 | </span></span>
<span class="line"><span style="color:#24292e;">　　| Handler_read_prev | 34822001724 | </span></span>
<span class="line"><span style="color:#24292e;">　　| Handler_read_rnd | 405482605 | </span></span>
<span class="line"><span style="color:#24292e;">　　| Handler_read_rnd_next | 18912877839 | </span></span>
<span class="line"><span style="color:#24292e;">　　+-----------------------+-------------+　　</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">-- 服务器完成的查询请求次数</span></span>
<span class="line"><span style="color:#24292e;">sql&gt; show global status like &#39;com_select&#39;; </span></span>
<span class="line"><span style="color:#24292e;">　　+---------------+-----------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| Variable_name | Value | </span></span>
<span class="line"><span style="color:#24292e;">　　+---------------+-----------+ </span></span>
<span class="line"><span style="color:#24292e;">　　| Com_select | 222693559 | </span></span>
<span class="line"><span style="color:#24292e;">　　+---------------+-----------+</span></span></code></pre></div><h3 id="_1-5、数据操作" tabindex="-1">1.5、数据操作 <a class="header-anchor" href="#_1-5、数据操作" aria-label="Permalink to &quot;1.5、数据操作&quot;">​</a></h3><h4 id="dql" tabindex="-1">DQL <a class="header-anchor" href="#dql" aria-label="Permalink to &quot;DQL&quot;">​</a></h4><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span></span>
<span class="line"><span style="color:#E1E4E8;">[DISTINCT] </span></span>
<span class="line"><span style="color:#E1E4E8;">字段</span></span>
<span class="line"><span style="color:#F97583;">from</span></span>
<span class="line"><span style="color:#E1E4E8;">表1 </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> 别名1</span></span>
<span class="line"><span style="color:#E1E4E8;">[left|right|inner join 表2 on xx=xx]</span></span>
<span class="line"><span style="color:#F97583;">where</span></span>
<span class="line"><span style="color:#E1E4E8;">条件</span></span>
<span class="line"><span style="color:#F97583;">group by</span></span>
<span class="line"><span style="color:#E1E4E8;">分组字段</span></span>
<span class="line"><span style="color:#F97583;">having</span></span>
<span class="line"><span style="color:#E1E4E8;">分组条件</span></span>
<span class="line"><span style="color:#F97583;">order by</span></span>
<span class="line"><span style="color:#E1E4E8;">字段 </span><span style="color:#F97583;">asc</span><span style="color:#E1E4E8;">|</span><span style="color:#F97583;">desc</span></span>
<span class="line"><span style="color:#F97583;">limit</span></span>
<span class="line"><span style="color:#E1E4E8;">(currentPage</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">pageSzie,pageSzie</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span></span>
<span class="line"><span style="color:#24292E;">[DISTINCT] </span></span>
<span class="line"><span style="color:#24292E;">字段</span></span>
<span class="line"><span style="color:#D73A49;">from</span></span>
<span class="line"><span style="color:#24292E;">表1 </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> 别名1</span></span>
<span class="line"><span style="color:#24292E;">[left|right|inner join 表2 on xx=xx]</span></span>
<span class="line"><span style="color:#D73A49;">where</span></span>
<span class="line"><span style="color:#24292E;">条件</span></span>
<span class="line"><span style="color:#D73A49;">group by</span></span>
<span class="line"><span style="color:#24292E;">分组字段</span></span>
<span class="line"><span style="color:#D73A49;">having</span></span>
<span class="line"><span style="color:#24292E;">分组条件</span></span>
<span class="line"><span style="color:#D73A49;">order by</span></span>
<span class="line"><span style="color:#24292E;">字段 </span><span style="color:#D73A49;">asc</span><span style="color:#24292E;">|</span><span style="color:#D73A49;">desc</span></span>
<span class="line"><span style="color:#D73A49;">limit</span></span>
<span class="line"><span style="color:#24292E;">(currentPage</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">pageSzie,pageSzie</span></span></code></pre></div><blockquote><p>... limit beginIndex,pageSize;</p><p>beginIndex:表示从第多少条数据开始 pageSize:表示每页显示的数据条数</p><p>beginIndex=(当前页数-1)*pageSize</p></blockquote><h4 id="ddl" tabindex="-1">DDL <a class="header-anchor" href="#ddl" aria-label="Permalink to &quot;DDL&quot;">​</a></h4><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 创建数据库</span></span>
<span class="line"><span style="color:#F97583;">CREATE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">DATABASE</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">not</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">exists</span><span style="color:#E1E4E8;"> 数据库名 </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">character</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">set</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&#39;utf8&#39;</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 创建数据库</span></span>
<span class="line"><span style="color:#D73A49;">CREATE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">DATABASE</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">if</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">not</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">exists</span><span style="color:#24292E;"> 数据库名 </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">character</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">set</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&#39;utf8&#39;</span><span style="color:#24292E;">;</span></span></code></pre></div><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 查看建表语句</span></span>
<span class="line"><span style="color:#E1E4E8;">show </span><span style="color:#F97583;">create</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">table</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> 表名</span></span>
<span class="line"><span style="color:#6A737D;">-- 查看表详情</span></span>
<span class="line"><span style="color:#F97583;">desc</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> 表名</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 查看建表语句</span></span>
<span class="line"><span style="color:#24292E;">show </span><span style="color:#D73A49;">create</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">table</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> 表名</span></span>
<span class="line"><span style="color:#6A737D;">-- 查看表详情</span></span>
<span class="line"><span style="color:#D73A49;">desc</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> 表名</span></span></code></pre></div><blockquote><p>索引操作</p></blockquote><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 创建索引</span></span>
<span class="line"><span style="color:#F97583;">CREATE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">索引名称</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ON</span><span style="color:#E1E4E8;"> 表名 (列名)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 删除索引</span></span>
<span class="line"><span style="color:#F97583;">DROP</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> 索引名 </span><span style="color:#F97583;">ON</span><span style="color:#E1E4E8;"> 表名</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 修改索引</span></span>
<span class="line"><span style="color:#F97583;">ALTER</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> 表名 </span><span style="color:#F97583;">DROP</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> 索引名</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 创建索引</span></span>
<span class="line"><span style="color:#D73A49;">CREATE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">索引名称</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ON</span><span style="color:#24292E;"> 表名 (列名)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 删除索引</span></span>
<span class="line"><span style="color:#D73A49;">DROP</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> 索引名 </span><span style="color:#D73A49;">ON</span><span style="color:#24292E;"> 表名</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 修改索引</span></span>
<span class="line"><span style="color:#D73A49;">ALTER</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> 表名 </span><span style="color:#D73A49;">DROP</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> 索引名</span></span></code></pre></div><p><code>普通索引</code></p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">ALTER</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`table_name`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ADD</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> index_name ( </span><span style="color:#9ECBFF;">`column`</span><span style="color:#E1E4E8;"> )</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">ALTER</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`table_name`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ADD</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> index_name ( </span><span style="color:#032F62;">`column`</span><span style="color:#24292E;"> )</span></span></code></pre></div><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">ALTER</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`table_name`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ADD</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> index_name ( </span><span style="color:#9ECBFF;">`column1`</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">`column2`</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">`column3`</span><span style="color:#E1E4E8;"> )</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">ALTER</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`table_name`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ADD</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> index_name ( </span><span style="color:#032F62;">`column1`</span><span style="color:#24292E;">, </span><span style="color:#032F62;">`column2`</span><span style="color:#24292E;">, </span><span style="color:#032F62;">`column3`</span><span style="color:#24292E;"> )</span></span></code></pre></div><p><code>主键索引</code></p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">ALTER</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`table_name`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ADD</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">PRIMARY KEY</span><span style="color:#E1E4E8;"> ( </span><span style="color:#9ECBFF;">`column`</span><span style="color:#E1E4E8;"> )</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">ALTER</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`table_name`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ADD</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">PRIMARY KEY</span><span style="color:#24292E;"> ( </span><span style="color:#032F62;">`column`</span><span style="color:#24292E;"> )</span></span></code></pre></div><p><code>唯一索引</code></p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">ALTER</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`table_name`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ADD</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">UNIQUE</span><span style="color:#E1E4E8;"> ( </span><span style="color:#9ECBFF;">`column`</span><span style="color:#E1E4E8;"> )</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">ALTER</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`table_name`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ADD</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">UNIQUE</span><span style="color:#24292E;"> ( </span><span style="color:#032F62;">`column`</span><span style="color:#24292E;"> )</span></span></code></pre></div><p><code>全文索引</code></p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">ALTER</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`table_name`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ADD</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">FULLTEXT</span><span style="color:#E1E4E8;"> ( </span><span style="color:#9ECBFF;">`column`</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">ALTER</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`table_name`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ADD</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">FULLTEXT</span><span style="color:#24292E;"> ( </span><span style="color:#032F62;">`column`</span><span style="color:#24292E;">)</span></span></code></pre></div><h4 id="dml" tabindex="-1">DML <a class="header-anchor" href="#dml" aria-label="Permalink to &quot;DML&quot;">​</a></h4><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 插入单条数据</span></span>
<span class="line"><span style="color:#F97583;">insert into</span><span style="color:#E1E4E8;"> 表名(字段1,字段2..) </span><span style="color:#F97583;">values</span><span style="color:#E1E4E8;">(值1,值2..);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 插入多条数据</span></span>
<span class="line"><span style="color:#F97583;">insert into</span><span style="color:#E1E4E8;"> 表名(字段1,字段2) </span><span style="color:#F97583;">values</span><span style="color:#E1E4E8;">(值1,值2),(值1,值2);   </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 针对全表所有字段进行插入操作</span></span>
<span class="line"><span style="color:#F97583;">insert into</span><span style="color:#E1E4E8;"> 表名 </span><span style="color:#F97583;">values</span><span style="color:#E1E4E8;">(值1,值2);  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 查询结果插入</span></span>
<span class="line"><span style="color:#F97583;">insert into</span><span style="color:#E1E4E8;"> 表名(字段) </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> 字段 </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> 表2;   </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 查询结果，全表插入</span></span>
<span class="line"><span style="color:#F97583;">insert into</span><span style="color:#E1E4E8;"> 表名 </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> 字段 </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> 表2;      </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 带条件修改指定数据，否则修改全表</span></span>
<span class="line"><span style="color:#F97583;">update</span><span style="color:#E1E4E8;"> 表 </span><span style="color:#F97583;">set</span><span style="color:#E1E4E8;"> 字段</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">值 </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> 条件;  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 删除数据带条件指定数据，否则删除全表数据</span></span>
<span class="line"><span style="color:#F97583;">delete</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> 表 </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> 条件;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 完全清空表数据</span></span>
<span class="line"><span style="color:#F97583;">TRUNCATE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> 表名;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 插入单条数据</span></span>
<span class="line"><span style="color:#D73A49;">insert into</span><span style="color:#24292E;"> 表名(字段1,字段2..) </span><span style="color:#D73A49;">values</span><span style="color:#24292E;">(值1,值2..);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 插入多条数据</span></span>
<span class="line"><span style="color:#D73A49;">insert into</span><span style="color:#24292E;"> 表名(字段1,字段2) </span><span style="color:#D73A49;">values</span><span style="color:#24292E;">(值1,值2),(值1,值2);   </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 针对全表所有字段进行插入操作</span></span>
<span class="line"><span style="color:#D73A49;">insert into</span><span style="color:#24292E;"> 表名 </span><span style="color:#D73A49;">values</span><span style="color:#24292E;">(值1,值2);  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 查询结果插入</span></span>
<span class="line"><span style="color:#D73A49;">insert into</span><span style="color:#24292E;"> 表名(字段) </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> 字段 </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> 表2;   </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 查询结果，全表插入</span></span>
<span class="line"><span style="color:#D73A49;">insert into</span><span style="color:#24292E;"> 表名 </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> 字段 </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> 表2;      </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 带条件修改指定数据，否则修改全表</span></span>
<span class="line"><span style="color:#D73A49;">update</span><span style="color:#24292E;"> 表 </span><span style="color:#D73A49;">set</span><span style="color:#24292E;"> 字段</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">值 </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> 条件;  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 删除数据带条件指定数据，否则删除全表数据</span></span>
<span class="line"><span style="color:#D73A49;">delete</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> 表 </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> 条件;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">-- 完全清空表数据</span></span>
<span class="line"><span style="color:#D73A49;">TRUNCATE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> 表名;</span></span></code></pre></div><h4 id="函数操作" tabindex="-1">函数操作 <a class="header-anchor" href="#函数操作" aria-label="Permalink to &quot;函数操作&quot;">​</a></h4><h5 id="聚合函数" tabindex="-1">聚合函数 <a class="header-anchor" href="#聚合函数" aria-label="Permalink to &quot;聚合函数&quot;">​</a></h5><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">max 				</span><span style="color:#6A737D;">-- 最大值</span></span>
<span class="line"><span style="color:#E1E4E8;">min 				</span><span style="color:#6A737D;">-- 最小值</span></span>
<span class="line"><span style="color:#E1E4E8;">sum 				</span><span style="color:#6A737D;">-- 求和</span></span>
<span class="line"><span style="color:#E1E4E8;">avg 				</span><span style="color:#6A737D;">-- 平均值</span></span>
<span class="line"><span style="color:#E1E4E8;">count 				</span><span style="color:#6A737D;">-- 记录个数(若统计的是列，列中为Null，那么count将不会计算值)</span></span>
<span class="line"><span style="color:#E1E4E8;">ABS 				</span><span style="color:#6A737D;">-- 绝对值</span></span>
<span class="line"><span style="color:#79B8FF;">CEILING</span><span style="color:#E1E4E8;">() </span><span style="color:#79B8FF;">FLOOR</span><span style="color:#E1E4E8;">() 	</span><span style="color:#6A737D;">-- 向上取整 向下取整</span></span>
<span class="line"><span style="color:#79B8FF;">RAND</span><span style="color:#E1E4E8;">() 				</span><span style="color:#6A737D;">-- 返回0~1之间的随机数</span></span>
<span class="line"><span style="color:#79B8FF;">SIGN</span><span style="color:#E1E4E8;">() 				</span><span style="color:#6A737D;">-- 判断一个数的符号位。负数返回-1，正数返回1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">max 				</span><span style="color:#6A737D;">-- 最大值</span></span>
<span class="line"><span style="color:#24292E;">min 				</span><span style="color:#6A737D;">-- 最小值</span></span>
<span class="line"><span style="color:#24292E;">sum 				</span><span style="color:#6A737D;">-- 求和</span></span>
<span class="line"><span style="color:#24292E;">avg 				</span><span style="color:#6A737D;">-- 平均值</span></span>
<span class="line"><span style="color:#24292E;">count 				</span><span style="color:#6A737D;">-- 记录个数(若统计的是列，列中为Null，那么count将不会计算值)</span></span>
<span class="line"><span style="color:#24292E;">ABS 				</span><span style="color:#6A737D;">-- 绝对值</span></span>
<span class="line"><span style="color:#005CC5;">CEILING</span><span style="color:#24292E;">() </span><span style="color:#005CC5;">FLOOR</span><span style="color:#24292E;">() 	</span><span style="color:#6A737D;">-- 向上取整 向下取整</span></span>
<span class="line"><span style="color:#005CC5;">RAND</span><span style="color:#24292E;">() 				</span><span style="color:#6A737D;">-- 返回0~1之间的随机数</span></span>
<span class="line"><span style="color:#005CC5;">SIGN</span><span style="color:#24292E;">() 				</span><span style="color:#6A737D;">-- 判断一个数的符号位。负数返回-1，正数返回1</span></span></code></pre></div><h5 id="数据函数" tabindex="-1">数据函数 <a class="header-anchor" href="#数据函数" aria-label="Permalink to &quot;数据函数&quot;">​</a></h5><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">abs</span><span style="color:#E1E4E8;">(x) 			</span><span style="color:#6A737D;">-- 绝对值 abs(-10.9) = 10</span></span>
<span class="line"><span style="color:#79B8FF;">format</span><span style="color:#E1E4E8;">(x, d) 	</span><span style="color:#6A737D;">-- 格式化千分位数值 format(1234567.456, 2) =1,234,567.46</span></span>
<span class="line"><span style="color:#E1E4E8;">ceil(x) 		</span><span style="color:#6A737D;">-- 向上取整 ceil(10.1) = 11</span></span>
<span class="line"><span style="color:#79B8FF;">floor</span><span style="color:#E1E4E8;">(x) 		</span><span style="color:#6A737D;">-- 向下取整 floor (10.1) = 10</span></span>
<span class="line"><span style="color:#79B8FF;">round</span><span style="color:#E1E4E8;">(x) 		</span><span style="color:#6A737D;">-- 四舍五入去整</span></span>
<span class="line"><span style="color:#E1E4E8;">mod(m, n) 		</span><span style="color:#6A737D;">-- m%n m mod n 求余 10%3=1</span></span>
<span class="line"><span style="color:#79B8FF;">pi</span><span style="color:#E1E4E8;">() 			</span><span style="color:#6A737D;">-- 获得圆周率</span></span>
<span class="line"><span style="color:#E1E4E8;">pow(m, n) 		</span><span style="color:#6A737D;">-- m^n</span></span>
<span class="line"><span style="color:#79B8FF;">sqrt</span><span style="color:#E1E4E8;">(x) 		</span><span style="color:#6A737D;">-- 算术平方根</span></span>
<span class="line"><span style="color:#79B8FF;">rand</span><span style="color:#E1E4E8;">() 			</span><span style="color:#6A737D;">-- 随机数</span></span>
<span class="line"><span style="color:#F97583;">truncate</span><span style="color:#E1E4E8;">(x, d) 	</span><span style="color:#6A737D;">-- 截取d位小数</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">abs</span><span style="color:#24292E;">(x) 			</span><span style="color:#6A737D;">-- 绝对值 abs(-10.9) = 10</span></span>
<span class="line"><span style="color:#005CC5;">format</span><span style="color:#24292E;">(x, d) 	</span><span style="color:#6A737D;">-- 格式化千分位数值 format(1234567.456, 2) =1,234,567.46</span></span>
<span class="line"><span style="color:#24292E;">ceil(x) 		</span><span style="color:#6A737D;">-- 向上取整 ceil(10.1) = 11</span></span>
<span class="line"><span style="color:#005CC5;">floor</span><span style="color:#24292E;">(x) 		</span><span style="color:#6A737D;">-- 向下取整 floor (10.1) = 10</span></span>
<span class="line"><span style="color:#005CC5;">round</span><span style="color:#24292E;">(x) 		</span><span style="color:#6A737D;">-- 四舍五入去整</span></span>
<span class="line"><span style="color:#24292E;">mod(m, n) 		</span><span style="color:#6A737D;">-- m%n m mod n 求余 10%3=1</span></span>
<span class="line"><span style="color:#005CC5;">pi</span><span style="color:#24292E;">() 			</span><span style="color:#6A737D;">-- 获得圆周率</span></span>
<span class="line"><span style="color:#24292E;">pow(m, n) 		</span><span style="color:#6A737D;">-- m^n</span></span>
<span class="line"><span style="color:#005CC5;">sqrt</span><span style="color:#24292E;">(x) 		</span><span style="color:#6A737D;">-- 算术平方根</span></span>
<span class="line"><span style="color:#005CC5;">rand</span><span style="color:#24292E;">() 			</span><span style="color:#6A737D;">-- 随机数</span></span>
<span class="line"><span style="color:#D73A49;">truncate</span><span style="color:#24292E;">(x, d) 	</span><span style="color:#6A737D;">-- 截取d位小数</span></span></code></pre></div><h5 id="字符串函数" tabindex="-1">字符串函数 <a class="header-anchor" href="#字符串函数" aria-label="Permalink to &quot;字符串函数&quot;">​</a></h5><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">length</span><span style="color:#E1E4E8;">(string) 							</span><span style="color:#6A737D;">-- string长度，字节</span></span>
<span class="line"><span style="color:#E1E4E8;">char_length(string) 					</span><span style="color:#6A737D;">-- string的字符个数</span></span>
<span class="line"><span style="color:#79B8FF;">substring</span><span style="color:#E1E4E8;">(str, position [,length]) 		</span><span style="color:#6A737D;">-- 从str的position开始,取length个字符</span></span>
<span class="line"><span style="color:#79B8FF;">replace</span><span style="color:#E1E4E8;">(str ,search_str ,replace_str) 	</span><span style="color:#6A737D;">-- 在str中用replace_str替换search_str</span></span>
<span class="line"><span style="color:#E1E4E8;">instr(string ,substring) 				</span><span style="color:#6A737D;">-- 返回substring首次在string中出现的位置</span></span>
<span class="line"><span style="color:#79B8FF;">concat</span><span style="color:#E1E4E8;">(string [,...]) 					</span><span style="color:#6A737D;">-- 连接字串</span></span>
<span class="line"><span style="color:#E1E4E8;">charset(str) 							</span><span style="color:#6A737D;">-- 返回字串字符集</span></span>
<span class="line"><span style="color:#E1E4E8;">lcase(string) 							</span><span style="color:#6A737D;">-- 转换成小写</span></span>
<span class="line"><span style="color:#79B8FF;">left</span><span style="color:#E1E4E8;">(string, </span><span style="color:#F97583;">length</span><span style="color:#E1E4E8;">) 					</span><span style="color:#6A737D;">-- 从string2中的左边起取length个字符</span></span>
<span class="line"><span style="color:#E1E4E8;">load_file(file_name) 					</span><span style="color:#6A737D;">-- 从文件读取内容</span></span>
<span class="line"><span style="color:#F97583;">locate</span><span style="color:#E1E4E8;">(substring, string [,start_position]) 	</span><span style="color:#6A737D;">-- 同instr,但可指定开始位置</span></span>
<span class="line"><span style="color:#E1E4E8;">lpad(string, </span><span style="color:#F97583;">length</span><span style="color:#E1E4E8;">, pad) 				</span><span style="color:#6A737D;">-- 重复用pad加在string开头,直到字串长度为length</span></span>
<span class="line"><span style="color:#79B8FF;">ltrim</span><span style="color:#E1E4E8;">(string) 							</span><span style="color:#6A737D;">-- 去除前面空格</span></span>
<span class="line"><span style="color:#F97583;">repeat</span><span style="color:#E1E4E8;">(string, count) 					</span><span style="color:#6A737D;">-- 重复count次</span></span>
<span class="line"><span style="color:#E1E4E8;">rpad(string, </span><span style="color:#F97583;">length</span><span style="color:#E1E4E8;">, pad) 				</span><span style="color:#6A737D;">-- 在str后用pad补充,直到长度为length</span></span>
<span class="line"><span style="color:#79B8FF;">rtrim</span><span style="color:#E1E4E8;">(string) 							</span><span style="color:#6A737D;">-- 去除后端空格</span></span>
<span class="line"><span style="color:#E1E4E8;">strcmp(string1 ,string2) 				</span><span style="color:#6A737D;">-- 逐字符比较两字串大小</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">length</span><span style="color:#24292E;">(string) 							</span><span style="color:#6A737D;">-- string长度，字节</span></span>
<span class="line"><span style="color:#24292E;">char_length(string) 					</span><span style="color:#6A737D;">-- string的字符个数</span></span>
<span class="line"><span style="color:#005CC5;">substring</span><span style="color:#24292E;">(str, position [,length]) 		</span><span style="color:#6A737D;">-- 从str的position开始,取length个字符</span></span>
<span class="line"><span style="color:#005CC5;">replace</span><span style="color:#24292E;">(str ,search_str ,replace_str) 	</span><span style="color:#6A737D;">-- 在str中用replace_str替换search_str</span></span>
<span class="line"><span style="color:#24292E;">instr(string ,substring) 				</span><span style="color:#6A737D;">-- 返回substring首次在string中出现的位置</span></span>
<span class="line"><span style="color:#005CC5;">concat</span><span style="color:#24292E;">(string [,...]) 					</span><span style="color:#6A737D;">-- 连接字串</span></span>
<span class="line"><span style="color:#24292E;">charset(str) 							</span><span style="color:#6A737D;">-- 返回字串字符集</span></span>
<span class="line"><span style="color:#24292E;">lcase(string) 							</span><span style="color:#6A737D;">-- 转换成小写</span></span>
<span class="line"><span style="color:#005CC5;">left</span><span style="color:#24292E;">(string, </span><span style="color:#D73A49;">length</span><span style="color:#24292E;">) 					</span><span style="color:#6A737D;">-- 从string2中的左边起取length个字符</span></span>
<span class="line"><span style="color:#24292E;">load_file(file_name) 					</span><span style="color:#6A737D;">-- 从文件读取内容</span></span>
<span class="line"><span style="color:#D73A49;">locate</span><span style="color:#24292E;">(substring, string [,start_position]) 	</span><span style="color:#6A737D;">-- 同instr,但可指定开始位置</span></span>
<span class="line"><span style="color:#24292E;">lpad(string, </span><span style="color:#D73A49;">length</span><span style="color:#24292E;">, pad) 				</span><span style="color:#6A737D;">-- 重复用pad加在string开头,直到字串长度为length</span></span>
<span class="line"><span style="color:#005CC5;">ltrim</span><span style="color:#24292E;">(string) 							</span><span style="color:#6A737D;">-- 去除前面空格</span></span>
<span class="line"><span style="color:#D73A49;">repeat</span><span style="color:#24292E;">(string, count) 					</span><span style="color:#6A737D;">-- 重复count次</span></span>
<span class="line"><span style="color:#24292E;">rpad(string, </span><span style="color:#D73A49;">length</span><span style="color:#24292E;">, pad) 				</span><span style="color:#6A737D;">-- 在str后用pad补充,直到长度为length</span></span>
<span class="line"><span style="color:#005CC5;">rtrim</span><span style="color:#24292E;">(string) 							</span><span style="color:#6A737D;">-- 去除后端空格</span></span>
<span class="line"><span style="color:#24292E;">strcmp(string1 ,string2) 				</span><span style="color:#6A737D;">-- 逐字符比较两字串大小</span></span></code></pre></div><h5 id="时间函数" tabindex="-1">时间函数 <a class="header-anchor" href="#时间函数" aria-label="Permalink to &quot;时间函数&quot;">​</a></h5><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> CURRENT_DATE();  	</span><span style="color:#6A737D;">/*获取当前日期*/</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> CURDATE();  			</span><span style="color:#6A737D;">/*获取当前日期*/</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">NOW</span><span style="color:#E1E4E8;">();  				</span><span style="color:#6A737D;">/*获取当前日期和时间*/</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> LOCALTIME();  		</span><span style="color:#6A737D;">/*获取当前日期和时间*/</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">SYSDATE</span><span style="color:#E1E4E8;">();  			</span><span style="color:#6A737D;">/*获取当前日期和时间*/</span></span>
<span class="line"><span style="color:#6A737D;">-- 获取年月日,时分秒</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">YEAR</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">NOW</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">MONTH</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">NOW</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">DAY</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">NOW</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">HOUR</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">NOW</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">MINUTE</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">NOW</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">SECOND</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">NOW</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#6A737D;">-- 时间日期函数</span></span>
<span class="line"><span style="color:#F97583;">now</span><span style="color:#E1E4E8;">(), </span><span style="color:#79B8FF;">current_timestamp</span><span style="color:#E1E4E8;">();   	</span><span style="color:#6A737D;">-- 当前日期时间</span></span>
<span class="line"><span style="color:#E1E4E8;">current_date();          		</span><span style="color:#6A737D;">-- 当前日期</span></span>
<span class="line"><span style="color:#79B8FF;">current_time</span><span style="color:#E1E4E8;">();          		</span><span style="color:#6A737D;">-- 当前时间</span></span>
<span class="line"><span style="color:#F97583;">date</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;yyyy-mm-dd hh:ii:ss&#39;</span><span style="color:#E1E4E8;">);  	</span><span style="color:#6A737D;">-- 获取日期部分</span></span>
<span class="line"><span style="color:#F97583;">time</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;yyyy-mm-dd hh:ii:ss&#39;</span><span style="color:#E1E4E8;">);  	</span><span style="color:#6A737D;">-- 获取时间部分</span></span>
<span class="line"><span style="color:#F97583;">date_format</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;yyyy-mm-dd hh:ii:ss&#39;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&#39;%d %y %a %d %m %b %j&#39;</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">-- 格式化时间</span></span>
<span class="line"><span style="color:#E1E4E8;">unix_timestamp();        		</span><span style="color:#6A737D;">-- 获得unix时间戳</span></span>
<span class="line"><span style="color:#E1E4E8;">from_unixtime();        		</span><span style="color:#6A737D;">-- 从时间戳获得时间</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> CURRENT_DATE();  	</span><span style="color:#6A737D;">/*获取当前日期*/</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> CURDATE();  			</span><span style="color:#6A737D;">/*获取当前日期*/</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">NOW</span><span style="color:#24292E;">();  				</span><span style="color:#6A737D;">/*获取当前日期和时间*/</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> LOCALTIME();  		</span><span style="color:#6A737D;">/*获取当前日期和时间*/</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">SYSDATE</span><span style="color:#24292E;">();  			</span><span style="color:#6A737D;">/*获取当前日期和时间*/</span></span>
<span class="line"><span style="color:#6A737D;">-- 获取年月日,时分秒</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">YEAR</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">NOW</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">MONTH</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">NOW</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">DAY</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">NOW</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">HOUR</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">NOW</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">MINUTE</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">NOW</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">SECOND</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">NOW</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#6A737D;">-- 时间日期函数</span></span>
<span class="line"><span style="color:#D73A49;">now</span><span style="color:#24292E;">(), </span><span style="color:#005CC5;">current_timestamp</span><span style="color:#24292E;">();   	</span><span style="color:#6A737D;">-- 当前日期时间</span></span>
<span class="line"><span style="color:#24292E;">current_date();          		</span><span style="color:#6A737D;">-- 当前日期</span></span>
<span class="line"><span style="color:#005CC5;">current_time</span><span style="color:#24292E;">();          		</span><span style="color:#6A737D;">-- 当前时间</span></span>
<span class="line"><span style="color:#D73A49;">date</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;yyyy-mm-dd hh:ii:ss&#39;</span><span style="color:#24292E;">);  	</span><span style="color:#6A737D;">-- 获取日期部分</span></span>
<span class="line"><span style="color:#D73A49;">time</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;yyyy-mm-dd hh:ii:ss&#39;</span><span style="color:#24292E;">);  	</span><span style="color:#6A737D;">-- 获取时间部分</span></span>
<span class="line"><span style="color:#D73A49;">date_format</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;yyyy-mm-dd hh:ii:ss&#39;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&#39;%d %y %a %d %m %b %j&#39;</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">-- 格式化时间</span></span>
<span class="line"><span style="color:#24292E;">unix_timestamp();        		</span><span style="color:#6A737D;">-- 获得unix时间戳</span></span>
<span class="line"><span style="color:#24292E;">from_unixtime();        		</span><span style="color:#6A737D;">-- 从时间戳获得时间</span></span></code></pre></div><h5 id="窗口函数" tabindex="-1">窗口函数 <a class="header-anchor" href="#窗口函数" aria-label="Permalink to &quot;窗口函数&quot;">​</a></h5><blockquote><p>CUME_DIST() 累积分配值</p><p><code>DENSE_RANK()</code> 当前行在其分区中的排名，稠密排序（分数一致排名一致，分数不一致排名+1）</p><p>FIRST_VALUE() 指定区间范围内的第一行的值</p><p>LAG() 取排在当前行之前的值</p><p>LAST_VALUE() 指定区间范围内的最后一行的值</p><p>LEAD() 取排在当前行之后的值</p><p>NTH_VALUE() 指定区间范围内第N行的值</p><p>NTILE() 将数据分到N个桶，当前行所在的桶号</p><p>PERCENT_RANK() 排名值的百分比</p><p><code>RANK()</code> 当前行在其分区中的排名，稀疏排序（相同分数有重复排名，但是重复后下一个人按照实际排名）</p><p><code>ROW_NUMBER()</code> 分区内当前行的行号（依次递增排名，无重复排名）</p><p><code>NTILE(4)</code> 分组排名，里面的数字是几，最多排名就是几，里面的数字是4，最多的排名就是4</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301623967.jpg" alt="img"></p><blockquote><p><code>select 窗口函数 over (partition by 用于分组的列名， order by 用于排序的列名）</code></p></blockquote><h6 id="row-number" tabindex="-1">row_number() <a class="header-anchor" href="#row-number" aria-label="Permalink to &quot;row_number()&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">row_number</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">OVER</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">order by</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">number</span><span style="color:#E1E4E8;"> ) </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> row_num </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> num</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">row_number</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">OVER</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">number</span><span style="color:#24292E;"> ) </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> row_num </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> num</span></span></code></pre></div><blockquote><p>注意：在使用row_number() 实现分页时需要特别注意一点，over子句中的order by 要与SQL排序记录中的order by保持一致，否则得到的序号可能不是连续</p></blockquote><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 错误例子</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">row_number</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">OVER</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">order by</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">number</span><span style="color:#E1E4E8;"> ) </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> row_num </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">ORDER BY</span><span style="color:#E1E4E8;"> id</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 错误例子</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">row_number</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">OVER</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">number</span><span style="color:#24292E;"> ) </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> row_num </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> num </span><span style="color:#D73A49;">ORDER BY</span><span style="color:#24292E;"> id</span></span></code></pre></div><h6 id="rank" tabindex="-1">rank() <a class="header-anchor" href="#rank" aria-label="Permalink to &quot;rank()&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">rank</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">OVER</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">order by</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">number</span><span style="color:#E1E4E8;"> ) </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> row_num </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> num</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">rank</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">OVER</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">number</span><span style="color:#24292E;"> ) </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> row_num </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> num</span></span></code></pre></div><h6 id="dense-rank" tabindex="-1">dense_rank() <a class="header-anchor" href="#dense-rank" aria-label="Permalink to &quot;dense_rank()&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">dense_rank</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">OVER</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">order by</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">number</span><span style="color:#E1E4E8;"> ) </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> row_num </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> num</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">dense_rank</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">OVER</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">number</span><span style="color:#24292E;"> ) </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> row_num </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> num</span></span></code></pre></div><h6 id="ntile" tabindex="-1">ntile() <a class="header-anchor" href="#ntile" aria-label="Permalink to &quot;ntile()&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- Ntile(group_num) 将所有记录分成group_num个组，每组序号一样</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">ntile</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">OVER</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">order by</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">number</span><span style="color:#E1E4E8;"> ) </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> row_num </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> num</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- Ntile(group_num) 将所有记录分成group_num个组，每组序号一样</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">ntile</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">OVER</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">number</span><span style="color:#24292E;"> ) </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> row_num </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> num</span></span></code></pre></div><h6 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">CREATE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">成绩单</span><span style="color:#E1E4E8;"> (学号 </span><span style="color:#F97583;">VARCHAR</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">), 姓名 </span><span style="color:#F97583;">VARCHAR</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">), 科目 </span><span style="color:#F97583;">VARCHAR</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">), 得分 </span><span style="color:#F97583;">INT</span><span style="color:#E1E4E8;"> ) </span></span>
<span class="line"><span style="color:#E1E4E8;">ENGINE </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> INNODB </span><span style="color:#F97583;">DEFAULT</span><span style="color:#E1E4E8;"> CHARSET </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> utf8;</span></span>
<span class="line"><span style="color:#F97583;">INSERT INTO</span><span style="color:#E1E4E8;"> 成绩单</span></span>
<span class="line"><span style="color:#F97583;">VALUES</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1000&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;小明&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;语文&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">112</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1000&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;小明&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;数学&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">120</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1000&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;小明&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;英语&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">92</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1001&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;云朵&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;语文&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">112</span><span style="color:#E1E4E8;"> ), </span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1001&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;云朵&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;数学&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">118</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1001&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;云朵&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;英语&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">99</span><span style="color:#E1E4E8;"> ), </span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1002&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;库里&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;语文&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">101</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1002&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;库里&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;数学&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">111</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1002&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;库里&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;英语&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">90</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1003&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;才子&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;语文&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">112</span><span style="color:#E1E4E8;"> ), </span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1003&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;才子&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;数学&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">120</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1003&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;才子&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;英语&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">112</span><span style="color:#E1E4E8;"> ), </span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1004&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;小华&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;语文&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">112</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1004&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;小华&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;数学&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">112</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1004&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;小华&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;英语&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">112</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1005&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;强森&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;语文&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">92</span><span style="color:#E1E4E8;"> ), </span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1005&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;强森&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;数学&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">120</span><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&#39;1005&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;强森&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;英语&#39;</span><span style="color:#E1E4E8;"> ,</span><span style="color:#79B8FF;">92</span><span style="color:#E1E4E8;"> );</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">CREATE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">成绩单</span><span style="color:#24292E;"> (学号 </span><span style="color:#D73A49;">VARCHAR</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">), 姓名 </span><span style="color:#D73A49;">VARCHAR</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">), 科目 </span><span style="color:#D73A49;">VARCHAR</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">), 得分 </span><span style="color:#D73A49;">INT</span><span style="color:#24292E;"> ) </span></span>
<span class="line"><span style="color:#24292E;">ENGINE </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> INNODB </span><span style="color:#D73A49;">DEFAULT</span><span style="color:#24292E;"> CHARSET </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> utf8;</span></span>
<span class="line"><span style="color:#D73A49;">INSERT INTO</span><span style="color:#24292E;"> 成绩单</span></span>
<span class="line"><span style="color:#D73A49;">VALUES</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1000&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;小明&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;语文&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">112</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1000&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;小明&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;数学&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">120</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1000&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;小明&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;英语&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">92</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1001&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;云朵&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;语文&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">112</span><span style="color:#24292E;"> ), </span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1001&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;云朵&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;数学&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">118</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1001&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;云朵&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;英语&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">99</span><span style="color:#24292E;"> ), </span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1002&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;库里&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;语文&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">101</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1002&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;库里&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;数学&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">111</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1002&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;库里&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;英语&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">90</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1003&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;才子&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;语文&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">112</span><span style="color:#24292E;"> ), </span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1003&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;才子&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;数学&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">120</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1003&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;才子&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;英语&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">112</span><span style="color:#24292E;"> ), </span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1004&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;小华&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;语文&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">112</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1004&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;小华&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;数学&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">112</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1004&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;小华&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;英语&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">112</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1005&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;强森&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;语文&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">92</span><span style="color:#24292E;"> ), </span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1005&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;强森&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;数学&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">120</span><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;"> (</span><span style="color:#032F62;">&#39;1005&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;强森&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;英语&#39;</span><span style="color:#24292E;"> ,</span><span style="color:#005CC5;">92</span><span style="color:#24292E;"> );</span></span></code></pre></div><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">RANK</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">OVER</span><span style="color:#E1E4E8;"> ( </span><span style="color:#F97583;">PARTITION</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">BY</span><span style="color:#E1E4E8;"> 科目 </span><span style="color:#F97583;">ORDER BY</span><span style="color:#E1E4E8;"> 得分 </span><span style="color:#F97583;">DESC</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">AS</span><span style="color:#E1E4E8;"> RANK_排名 ,</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">DENSE_RANK</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">OVER</span><span style="color:#E1E4E8;"> ( </span><span style="color:#F97583;">PARTITION</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">BY</span><span style="color:#E1E4E8;"> 科目 </span><span style="color:#F97583;">ORDER BY</span><span style="color:#E1E4E8;"> 得分 </span><span style="color:#F97583;">DESC</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">AS</span><span style="color:#E1E4E8;"> DENSE_RANK_排名 ,</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">ROW_NUMBER</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">OVER</span><span style="color:#E1E4E8;"> ( </span><span style="color:#F97583;">PARTITION</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">BY</span><span style="color:#E1E4E8;"> 科目 </span><span style="color:#F97583;">ORDER BY</span><span style="color:#E1E4E8;"> 得分 </span><span style="color:#F97583;">DESC</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">AS</span><span style="color:#E1E4E8;"> ROW_NUMBER_排名</span></span>
<span class="line"><span style="color:#F97583;">FROM</span></span>
<span class="line"><span style="color:#E1E4E8;"> 成绩单</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#005CC5;">RANK</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">OVER</span><span style="color:#24292E;"> ( </span><span style="color:#D73A49;">PARTITION</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">BY</span><span style="color:#24292E;"> 科目 </span><span style="color:#D73A49;">ORDER BY</span><span style="color:#24292E;"> 得分 </span><span style="color:#D73A49;">DESC</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">AS</span><span style="color:#24292E;"> RANK_排名 ,</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#005CC5;">DENSE_RANK</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">OVER</span><span style="color:#24292E;"> ( </span><span style="color:#D73A49;">PARTITION</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">BY</span><span style="color:#24292E;"> 科目 </span><span style="color:#D73A49;">ORDER BY</span><span style="color:#24292E;"> 得分 </span><span style="color:#D73A49;">DESC</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">AS</span><span style="color:#24292E;"> DENSE_RANK_排名 ,</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#005CC5;">ROW_NUMBER</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">OVER</span><span style="color:#24292E;"> ( </span><span style="color:#D73A49;">PARTITION</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">BY</span><span style="color:#24292E;"> 科目 </span><span style="color:#D73A49;">ORDER BY</span><span style="color:#24292E;"> 得分 </span><span style="color:#D73A49;">DESC</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">AS</span><span style="color:#24292E;"> ROW_NUMBER_排名</span></span>
<span class="line"><span style="color:#D73A49;">FROM</span></span>
<span class="line"><span style="color:#24292E;"> 成绩单</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301623591.png" alt="image-20230629101433924"></p><blockquote><p>TOP N 问题</p></blockquote><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span></span>
<span class="line"><span style="color:#E1E4E8;">	(</span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;"> 		</span><span style="color:#79B8FF;">row_number</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">over</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">partition</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">by</span><span style="color:#E1E4E8;"> 要分组的列名 </span><span style="color:#F97583;">order by</span><span style="color:#E1E4E8;"> 要排序的列名 </span><span style="color:#F97583;">desc</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;"> 	</span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> ranking </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> 表名）</span></span>
<span class="line"><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> ranking </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> N;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span></span>
<span class="line"><span style="color:#24292E;">	(</span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">, </span></span>
<span class="line"><span style="color:#24292E;"> 		</span><span style="color:#005CC5;">row_number</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">over</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">partition</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">by</span><span style="color:#24292E;"> 要分组的列名 </span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> 要排序的列名 </span><span style="color:#D73A49;">desc</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;"> 	</span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> ranking </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> 表名）</span></span>
<span class="line"><span style="color:#D73A49;">as</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> ranking </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> N;</span></span></code></pre></div><h2 id="_2、mysql扩展" tabindex="-1">2、MySQL扩展 <a class="header-anchor" href="#_2、mysql扩展" aria-label="Permalink to &quot;2、MySQL扩展&quot;">​</a></h2><h3 id="_1-1、存储引擎" tabindex="-1">1.1、存储引擎 <a class="header-anchor" href="#_1-1、存储引擎" aria-label="Permalink to &quot;1.1、存储引擎&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301624903.png" alt="image-20220329182103809"></p><ul><li><p>连接层：主要完成客户端的连接处理，授权，检查连接数。</p></li><li><p>服务层：绝大部分的核心功能都是在服务层完成，sql接口，解析器，优化器，缓存。</p></li><li><p>引擎层：可插拔式的存储引擎。索引实在存储引擎层实现的。</p></li><li><p>存储层：日志，数据，索引等。</p></li></ul><h4 id="innodb" tabindex="-1">InnoDB <a class="header-anchor" href="#innodb" aria-label="Permalink to &quot;InnoDB&quot;">​</a></h4><blockquote><p>InnoDB 是sql5.5 版本之后的默认的存储引擎。</p><p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。其默认级别时可重复读（REPEATABLE READ），在可重复读级别下，通过 MVCC + Next-Key Locking 防止幻读。</p><p>主索引时聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对主键查询有很高的性能。</p><p>InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读，能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><p>InnoDB 支持真正的在线热备份，sql 其他的存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合的场景中，停止写入可能也意味着停止读取。</p></blockquote><p>下面是InnoDB 架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301624917.png" alt="在这里插入图片描述(https://img-blog.csdnimg.cn/7cb0c00ecaca4043ac877bce74192f83.png"></p><h5 id="存储文件" tabindex="-1">存储文件 <a class="header-anchor" href="#存储文件" aria-label="Permalink to &quot;存储文件&quot;">​</a></h5><blockquote><p>xxx.ibd：xxx表示表名，InnoDB 引擎的每张表都会对应一个这样的表空间文件，存储该表的表结构（frm（8.0之后表结构存储到了sdi）、sdi）、数据和索引。</p><p>参数：innodb_file_per_table 8.0版本这个参数是打开的，每一张表有自己的表空间</p></blockquote><h5 id="逻辑存储结构" tabindex="-1">逻辑存储结构 <a class="header-anchor" href="#逻辑存储结构" aria-label="Permalink to &quot;逻辑存储结构&quot;">​</a></h5><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301624718.png" alt="在这里插入图片描述"></p><p>表空间（ibd文件），一个sql 实例可以对应多个表空间，用于存储记录、索引等数据。</p><p>段（Segment），分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollbak segment）。InnoDB 是索引组织表，数据段就是B+tree的叶子节点，索引段即为B+Tree的非叶子节点。段用来管理多个Extent。</p><p>区（Extent）表空间的单元结构，每个区的大小为1M，默认情况下InnoDB 存储引擎页大小为16k，即一个区中一共有64个连续的页。</p><p>页（Page），是InnoDB 存储引擎磁盘管理的最小单元，每个页默认大小为16k。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请4-5个区。</p><p>行（Row），InnoDB 存储引擎数据是按行存放的。</p><blockquote><p>Trx_id: 每次对某条记录进行改动时，都会把对应的事务id 赋值给trx_id 隐藏列</p><p>Rool_pointer：每次对某条记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列相当于一个指针，可以通过它来找到该记录的修改前的信息。</p></blockquote><h5 id="内存结构" tabindex="-1">内存结构 <a class="header-anchor" href="#内存结构" aria-label="Permalink to &quot;内存结构&quot;">​</a></h5><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301624551.png" alt="在这里插入图片描述"></p><h6 id="buffer-pool" tabindex="-1">Buffer Pool <a class="header-anchor" href="#buffer-pool" aria-label="Permalink to &quot;Buffer Pool&quot;">​</a></h6><p>缓冲池是主内存中的一个区域，里面可以缓存磁盘上进场操作的真实数据，在执行增删改查操作时，先操作缓冲池的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池有一个一个的块，叫做缓冲池。缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态Page 被分为3类：</p><ul><li>free page：空闲page，未被使用。</li><li>clean page：被使用page，数据没有被修改过。</li><li>dirty page：脏页，被使用page，数据被修改过，数据与磁盘的数据产生了不一致</li></ul><h6 id="change-buffer" tabindex="-1">Change Buffer <a class="header-anchor" href="#change-buffer" aria-label="Permalink to &quot;Change Buffer&quot;">​</a></h6><p>更改缓冲区（针对于非一二级所以页），在执行DML 语句时，如果这些数据Page 没有在Buffer Pool 中，不会直接操作磁盘，而会将数据变更存在缓冲区Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool 中，再讲合并后的数据刷新到磁盘中。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301624708.png" alt="在这里插入图片描述"></p><p><strong>Change Buffer的意义</strong></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响数中不相邻的二级索引页。如果每一次都操作磁盘，会造成大量磁盘IO，有了Change Buffer 之后，我们可以在缓冲池进行合并处理，减少磁盘IO。</p><h6 id="adaptive-hash-index" tabindex="-1">Adaptive Hash Index <a class="header-anchor" href="#adaptive-hash-index" aria-label="Permalink to &quot;Adaptive Hash Index&quot;">​</a></h6><p>hash 索引最大优势在于快，因为他只需要一次匹配就可以完成（前提是不存在hash冲突的情况下），B+Tree 往往需要2-3次。但是他的弊端是不能够支持范围查询，只能做等值匹配。所以InnoDB 引擎就做了这个自适应hash 。</p><p>自适应hash 索引，用于优化对Buffer Pool 数据查询。InnoDB 存储引擎会监控对表上各索引的查询，如果观察到hash 索引可以提高速度，则建立hash 索引，称之为自适应hash 索引。</p><p><strong>自适应hash 索引，无须人工干预，是系统根据情况自动完成。</strong></p><p>参数：adaptive_hash_index</p><h6 id="log-buffer" tabindex="-1">Log Buffer <a class="header-anchor" href="#log-buffer" aria-label="Permalink to &quot;Log Buffer&quot;">​</a></h6><p>日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log，undo log），默认大小是16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入删除许多行的事务，增加日志缓冲区的大小可以节省磁盘I/O。</p><p>参数：innodb_log_buffer_size（缓冲区大小），innodb_flush_log_at_trx_commit(日志刷新到磁盘的时机)</p><p>刷新时机默认是1,1 日志在每次事务提交时写入并刷新到磁盘，0 每秒将日志写入并刷新到磁盘一次， 2 日志在每次事务提交后写入并每秒刷新到磁盘一次。</p><h5 id="磁盘结构" tabindex="-1">磁盘结构 <a class="header-anchor" href="#磁盘结构" aria-label="Permalink to &quot;磁盘结构&quot;">​</a></h5><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301624893.png" alt="在这里插入图片描述"></p><h6 id="system-tablespace" tabindex="-1">System Tablespace <a class="header-anchor" href="#system-tablespace" aria-label="Permalink to &quot;System Tablespace&quot;">​</a></h6><p>系统表空间是更新缓冲区存储的区域。如果表示在系统表空间而不是每个表文件或者通用表空间中创建的，它也可能包含表和索引的数据（在sql5.x版本中还包含InnoDB数据字典、undolog 等）</p><p>参数：innodb_data_file_path</p><h6 id="file-per-table-tablespaces" tabindex="-1">File-Per-Table Tablespaces <a class="header-anchor" href="#file-per-table-tablespaces" aria-label="Permalink to &quot;File-Per-Table Tablespaces&quot;">​</a></h6><p>每个表的文件表空间包含单个InnoDB 表的数据和索引，并存储在文件系统上的单个数据文件中。</p><p>参数：innodb_file_per_table</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 创建表空间</span></span>
<span class="line"><span style="color:#F97583;">create</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">tablespace</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">xxx</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">add</span><span style="color:#E1E4E8;"> datafile </span><span style="color:#9ECBFF;">&#39;xxx.ibd&#39;</span><span style="color:#E1E4E8;"> engine </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> innodb;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 创建表空间</span></span>
<span class="line"><span style="color:#D73A49;">create</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">tablespace</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">xxx</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">add</span><span style="color:#24292E;"> datafile </span><span style="color:#032F62;">&#39;xxx.ibd&#39;</span><span style="color:#24292E;"> engine </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> innodb;</span></span></code></pre></div><h6 id="general-tablespaces" tabindex="-1">General Tablespaces <a class="header-anchor" href="#general-tablespaces" aria-label="Permalink to &quot;General Tablespaces&quot;">​</a></h6><p>通用表空间，需要通过<code>Create tablespace</code>语法创建通用表空间，在创建表时，可以指定该表空间。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">CREATE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">xxx</span><span style="color:#E1E4E8;">(...) TABLESPACE xxxx;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">CREATE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">xxx</span><span style="color:#24292E;">(...) TABLESPACE xxxx;</span></span></code></pre></div><h6 id="undo-tablespaces" tabindex="-1">undo Tablespaces <a class="header-anchor" href="#undo-tablespaces" aria-label="Permalink to &quot;undo Tablespaces&quot;">​</a></h6><p>撤销表空间，sql 实例在初始化时会自动创建2个默认的undo表空间(初始大小为16M)，用于存储undo log日志。</p><h6 id="temporary-tablespaces" tabindex="-1">Temporary Tablespaces <a class="header-anchor" href="#temporary-tablespaces" aria-label="Permalink to &quot;Temporary Tablespaces&quot;">​</a></h6><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户会话和零时表等等数据。</p><h6 id="doublewrite-buffer-files" tabindex="-1">Doublewrite Buffer Files <a class="header-anchor" href="#doublewrite-buffer-files" aria-label="Permalink to &quot;Doublewrite Buffer Files&quot;">​</a></h6><p>双写缓冲区，innoDB 引擎将数据页从Buffer Pool 刷新到磁盘前，先将数据写入到双写缓冲区文件中，便于系统异常时恢复数据。</p><h6 id="redo-log" tabindex="-1">Redo Log <a class="header-anchor" href="#redo-log" aria-label="Permalink to &quot;Redo Log&quot;">​</a></h6><p>Redo Log 是用来实现事务的持久性。该日志文件由两部分组成。重做日志缓冲（redo log buffer）已经重做日志文件（redo log），前者是在内存中，后者在磁盘中。事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发送错误时，进行数据恢复使用。以循环方式写入重做日志文件。</p><h5 id="后台线程" tabindex="-1">后台线程 <a class="header-anchor" href="#后台线程" aria-label="Permalink to &quot;后台线程&quot;">​</a></h5><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301624725.png" alt="在这里插入图片描述"></p><p>后台线程的作用就是将内存里缓冲池的数据在合适的时机刷新到磁盘文件当中。</p><h6 id="master-thread" tabindex="-1">Master Thread <a class="header-anchor" href="#master-thread" aria-label="Permalink to &quot;Master Thread&quot;">​</a></h6><p>核心后台线程，负责调度其他线程，还负责将缓冲池的数据异步刷新到磁盘中，保持数据一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。</p><h6 id="io-thread" tabindex="-1">IO Thread <a class="header-anchor" href="#io-thread" aria-label="Permalink to &quot;IO Thread&quot;">​</a></h6><p>在InnoDB 存储引擎中大量使用了AIO 来处理IO 请求，这样可以极大地提高数据库的性能，从IO Thread 主要负责这些IO 请求的回调。</p><table><thead><tr><th style="text-align:center;">线程类型</th><th style="text-align:center;">默认个数</th><th style="text-align:center;">职责</th></tr></thead><tbody><tr><td style="text-align:center;">Read thread</td><td style="text-align:center;">4</td><td style="text-align:center;">负责读操作</td></tr><tr><td style="text-align:center;">Write thread</td><td style="text-align:center;">4</td><td style="text-align:center;">负责写操作</td></tr><tr><td style="text-align:center;">Log thread</td><td style="text-align:center;">1</td><td style="text-align:center;">负责将日志缓冲区刷新到磁盘</td></tr><tr><td style="text-align:center;">Insert buffer thread</td><td style="text-align:center;">1</td><td style="text-align:center;">负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><h6 id="purge-thread" tabindex="-1">Purge Thread <a class="header-anchor" href="#purge-thread" aria-label="Permalink to &quot;Purge Thread&quot;">​</a></h6><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log 可能不用了，就用它来回收</p><h6 id="page-cleaner-thread" tabindex="-1">Page Cleaner Thread <a class="header-anchor" href="#page-cleaner-thread" aria-label="Permalink to &quot;Page Cleaner Thread&quot;">​</a></h6><p>协助 Master Thread 刷新脏页到磁盘的线程，他可以减轻Master Thread 的工作压力，减少阻塞。</p><p>当我们业务在操作的时候会直接操作sql 的缓冲区，如果缓冲区内没有数据，会将磁盘的数据加载进来，然后存储在缓冲区当中。在增删改查的时候会操作这个缓冲区里的数据。缓冲区的数据会以一定的频率，一定的时机通过后台线程刷新到磁盘当中，然后才持久化</p><h4 id="myisam" tabindex="-1">MyISAM <a class="header-anchor" href="#myisam" aria-label="Permalink to &quot;MyISAM&quot;">​</a></h4><blockquote><p>提供了大量的特性，包括压缩表、空间数据索引等</p><p>不支持事务</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p></blockquote><h5 id="存储文件-1" tabindex="-1">存储文件 <a class="header-anchor" href="#存储文件-1" aria-label="Permalink to &quot;存储文件&quot;">​</a></h5><blockquote><p>xxx.sdi: 存储表结构信息</p><p>xxx.MYD: 存储表数据</p><p>xxx.MYI: 存储索引</p></blockquote><h4 id="memory" tabindex="-1">Memory <a class="header-anchor" href="#memory" aria-label="Permalink to &quot;Memory&quot;">​</a></h4><p>Memory 引擎的表数据是存放在内存中的，由于受到硬件问题或断点问题的影响，只能将这些表作为临时表或者缓存使用。</p><ul><li>内存存放</li><li>hash索引(默认)</li></ul><h5 id="存储文件-2" tabindex="-1">存储文件 <a class="header-anchor" href="#存储文件-2" aria-label="Permalink to &quot;存储文件&quot;">​</a></h5><blockquote><p>xxx.sdi: 存储表结构信息</p></blockquote><h4 id="存储引擎选择" tabindex="-1">存储引擎选择 <a class="header-anchor" href="#存储引擎选择" aria-label="Permalink to &quot;存储引擎选择&quot;">​</a></h4><h5 id="innodb-和-myisam-的比较" tabindex="-1">InnoDB 和 MyISAM 的比较 <a class="header-anchor" href="#innodb-和-myisam-的比较" aria-label="Permalink to &quot;InnoDB 和 MyISAM 的比较&quot;">​</a></h5><ul><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键：InnoDB 支持外键。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。</li></ul><table><thead><tr><th style="text-align:center;">特点</th><th style="text-align:center;">InnoDB</th><th style="text-align:center;">MyISAM</th><th style="text-align:center;">Memory</th></tr></thead><tbody><tr><td style="text-align:center;">存储限制</td><td style="text-align:center;">64TB</td><td style="text-align:center;">有</td><td style="text-align:center;">有</td></tr><tr><td style="text-align:center;">事务安全</td><td style="text-align:center;">支持</td><td style="text-align:center;">-</td><td style="text-align:center;">-</td></tr><tr><td style="text-align:center;">锁机制</td><td style="text-align:center;">行锁</td><td style="text-align:center;">表锁</td><td style="text-align:center;">表锁</td></tr><tr><td style="text-align:center;">B+Tree索引</td><td style="text-align:center;">支持</td><td style="text-align:center;">支持</td><td style="text-align:center;">支持</td></tr><tr><td style="text-align:center;">Hash索引</td><td style="text-align:center;">-</td><td style="text-align:center;">-</td><td style="text-align:center;">支持</td></tr><tr><td style="text-align:center;">全文索引</td><td style="text-align:center;">支持(5.6版本之后)</td><td style="text-align:center;">支持</td><td style="text-align:center;">-</td></tr><tr><td style="text-align:center;">空间使用</td><td style="text-align:center;">高</td><td style="text-align:center;">低</td><td style="text-align:center;">N/A</td></tr><tr><td style="text-align:center;">内存使用</td><td style="text-align:center;">高</td><td style="text-align:center;">低</td><td style="text-align:center;">中等</td></tr><tr><td style="text-align:center;">批量插入速度</td><td style="text-align:center;">低</td><td style="text-align:center;">高</td><td style="text-align:center;">高</td></tr><tr><td style="text-align:center;">支持外键</td><td style="text-align:center;">支持</td><td style="text-align:center;">-</td><td style="text-align:center;">-</td></tr></tbody></table><blockquote><p>InnoDB ：是sql 的默认引擎，支持事务外键，对事务完整性要求比较高，要求一定并发条件下数据一致性，除查询和插入外还包括更新删除操作，InnoDB 比较适合</p><p>MyISAM ：以读操作插入操作为主少有更新和删除操作，并对事务的完整性，并发要求不是很高，MyISAM 比较适合</p><p>Memory 访问速度快，对于大数据表无法缓存在内存中，而且无法保证数据安全性。</p></blockquote><h3 id="_1-2、缓冲池" tabindex="-1">1.2、缓冲池 <a class="header-anchor" href="#_1-2、缓冲池" aria-label="Permalink to &quot;1.2、缓冲池&quot;">​</a></h3><p>sql作为一个存储系统，具有<strong>缓冲池</strong>(buffer pool)机制，以避免每次查询数据都进行磁盘IO。</p><p><strong>InnoDB的缓冲池缓存什么？有什么用？</strong></p><p>缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用。</p><p>速度快，那<strong>为啥不把所有数据都放到缓冲池里</strong>？</p><p>凡事都具备两面性，抛开数据易失性不说，访问快速的反面是存储容量小：</p><p>（1）缓存访问快，但容量小，数据库存储了200G数据，缓存容量可能只有64G；</p><p>（2）内存访问快，但容量小，买一台笔记本磁盘有2T，内存可能只有16G；</p><p>因此，只能把“最热”的数据放到“最近”的地方，以“最大限度”的降低磁盘访问。</p><p><strong>什么是预读？</strong></p><p>磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。</p><p><strong>预读为什么有效？</strong></p><p>数据访问，通常都遵循“集中读写”的原则，使用一些数据，大概率会使用附近的数据，这就是所谓的“局部性原理”，它表明提前加载是有效的，确实能够减少磁盘IO。</p><p><strong>按页(4K)读取，和InnoDB的缓冲池设计有啥关系？</strong></p><p>（1）磁盘访问按页读取能够提高性能，所以缓冲池一般也是按页缓存数据；</p><p>（2）预读机制启示了我们，能把一些“可能要访问”的页提前加入缓冲池，避免未来的磁盘IO操作；</p><p><strong>InnoDB是以什么算法，来管理这些缓冲页呢？</strong></p><p>最容易想到的，就是LRU(Least recently used)。</p><p><em>画外音：memcache，OS都会用LRU来进行页置换管理，但sql的玩法并不一样。</em></p><p><strong>传统的LRU是如何进行缓冲页管理？</strong></p><p>最常见的玩法是，把入缓冲池的页放到LRU的头部，作为最近访问的元素，从而最晚被淘汰。这里又分两种情况：</p><p>（1）<strong>页已经在缓冲池里</strong>，那就只做“移至”LRU头部的动作，而没有页被淘汰；</p><p>（2）<strong>页不在缓冲池里</strong>，除了做“放入”LRU头部的动作，还要做“淘汰”LRU尾部页的动作；</p><p><strong>传统的LRU缓冲池算法十分直观</strong>，OS，memcache等很多软件都在用，<strong>sql为啥这么矫情，不能直接用呢？</strong></p><p>这里有两个问题：</p><p>（1）预读失效；</p><p>（2）缓冲池污染；</p><p><strong>什么是预读失效？</strong></p><p>由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终sql并没有从页中读取数据，称为预读失效。</p><p><strong>如何对预读失效进行优化？</strong></p><p>要优化预读失效，思路是：</p><p>（1）让预读失败的页，停留在缓冲池LRU里的时间尽可能短；</p><p>（2）让真正被读取的页，才挪到缓冲池LRU的头部；</p><p>以保证，真正被读取的热数据留在缓冲池里的时间尽可能长。</p><p>具体方法是：</p><p>（1）将LRU分为两个部分：</p><p>- 新生代(new sublist)</p><p>- 老生代(old sublist)</p><p>（2）新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)；</p><p>（3）新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：</p><p>- 如果数据真正被读取（预读成功），才会加入到新生代的头部</p><p>- 如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池</p><p><strong>上述原理，对应InnoDB里哪些参数？</strong></p><p>有三个比较重要的参数。</p><p><strong>参数</strong>：innodb_buffer_pool_size</p><p><strong>介绍</strong>：配置缓冲池的大小，在内存允许的情况下，DBA往往会建议调大这个参数，越多数据和索引放到内存里，数据库的性能会越好。</p><p><strong>参数</strong>：innodb_old_blocks_pct</p><p><strong>介绍</strong>：老生代占整个LRU链长度的比例，默认是37，即整个LRU中新生代与老生代长度比例是63:37。</p><p><em>画外音：如果把这个参数设为100，就退化为普通LRU了。</em></p><p><strong>参数</strong>：innodb_old_blocks_time</p><p><strong>介绍</strong>：老生代停留时间窗口，单位是毫秒，默认是1000，即同时满足“被访问”与“在老生代停留时间超过1秒”两个条件，才会被插入到新生代头部。</p><p><strong>总结</strong></p><p>（1）缓冲池(buffer pool)是一种<strong>常见的降低磁盘访问的机制；</strong></p><p>（2）缓冲池通常<strong>以页(page)为单位缓存数据；</strong></p><p>（3）缓冲池的<strong>常见管理算法是LRU</strong>，memcache，OS，InnoDB都使用了这种算法；</p><p>（4）InnoDB对普通LRU进行了优化：</p><ul><li><p>将缓冲池分为<strong>老生代和新生代</strong>，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题</p></li><li><p>页被访问，且在老生代<strong>停留时间超过配置阈值</strong>的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题</p></li></ul><h3 id="_1-3、索引" tabindex="-1">1.3、索引 <a class="header-anchor" href="#_1-3、索引" aria-label="Permalink to &quot;1.3、索引&quot;">​</a></h3><h4 id="b-tree" tabindex="-1">B+ Tree <a class="header-anchor" href="#b-tree" aria-label="Permalink to &quot;B+ Tree&quot;">​</a></h4><h5 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h5><blockquote><p>B Tree 指的是 Balance Tree，也就是平衡树，平衡树是一颗查找树，并且所有叶子节点位于同一层</p><p><strong>B+ Tree 是 B 树的一种变形，它是基于 B Tree 和叶子节点顺序访问指针进行实现，通常用于数据库和操作系统的文件系统中。</strong></p><p>B+ 树有两种类型的节点：内部节点（也称索引节点）和叶子节点，内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存在叶子节点。</p><p>内部节点中的 key 都按照从小到大的顺序排列，对于内部节点中的一个 key，左子树中的所有 key 都小于它，右子树中的 key 都大于等于它，叶子节点的记录也是按照从小到大排列的。每个叶子节点都存有相邻叶子节点的指针。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301624110.png" alt="image-20220319114855757"></p><h6 id="b-树与-b-树的比较" tabindex="-1">B + 树与 B 树的比较 <a class="header-anchor" href="#b-树与-b-树的比较" aria-label="Permalink to &quot;B + 树与 B 树的比较&quot;">​</a></h6><blockquote><p><strong>B+ 树的磁盘 IO 更低</strong></p><p>B+ 树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p><strong>B+ 树的查询效率更加稳定</strong></p><p>由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p><strong>B+ 树元素遍历效率高</strong></p><p>B 树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作（或者说效率太低）。</p></blockquote><h5 id="操作" tabindex="-1">操作 <a class="header-anchor" href="#操作" aria-label="Permalink to &quot;操作&quot;">​</a></h5><h6 id="查找" tabindex="-1"><strong>查找</strong> <a class="header-anchor" href="#查找" aria-label="Permalink to &quot;**查找**&quot;">​</a></h6><blockquote><p>查找以典型的方式进行，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。</p></blockquote><h6 id="插入" tabindex="-1"><strong>插入</strong> <a class="header-anchor" href="#插入" aria-label="Permalink to &quot;**插入**&quot;">​</a></h6><blockquote><p>二叉树插入</p></blockquote><h6 id="删除" tabindex="-1"><strong>删除</strong> <a class="header-anchor" href="#删除" aria-label="Permalink to &quot;**删除**&quot;">​</a></h6><blockquote><p>类似插入，只不过是自下而上的合并操作</p></blockquote><h4 id="sql-索引" tabindex="-1">sql 索引 <a class="header-anchor" href="#sql-索引" aria-label="Permalink to &quot;sql 索引&quot;">​</a></h4><p>索引（index）是帮助sql <strong>高效获取数据的有序数据结构</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>优缺点：</p><table><thead><tr><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th></tr></thead><tbody><tr><td style="text-align:center;">提高数据库检索的效率，降低数据库的IO成本</td><td style="text-align:center;">索引列也是需要占用空间的</td></tr><tr><td style="text-align:center;">通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td><td style="text-align:center;">索引大大提高了查询效率，同时也降低更新表的速度，如果对表进行INSERT，UPDATE，DELETE时，效率降低</td></tr></tbody></table><p>sql 的索引实在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：</p><table><thead><tr><th style="text-align:center;">索引结构</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">B+Tree索引</td><td style="text-align:center;">最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td style="text-align:center;">Hash索引</td><td style="text-align:center;">底层数据结构是hash表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td style="text-align:center;">R-Tree(空间索引)</td><td style="text-align:center;">空间索引是MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td style="text-align:center;">Full-Text(全文索引)</td><td style="text-align:center;">是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES</td></tr></tbody></table><p>支持情况</p><table><thead><tr><th style="text-align:center;">索引</th><th style="text-align:center;">InnoDB</th><th style="text-align:center;">MyISAM</th><th style="text-align:center;">Memory</th></tr></thead><tbody><tr><td style="text-align:center;">B+Tree 索引</td><td style="text-align:center;">支持</td><td style="text-align:center;">支持</td><td style="text-align:center;">支持</td></tr><tr><td style="text-align:center;">Hash 索引</td><td style="text-align:center;">不支持</td><td style="text-align:center;">不支持</td><td style="text-align:center;">支持</td></tr><tr><td style="text-align:center;">R-Tree 索引</td><td style="text-align:center;">不支持</td><td style="text-align:center;">支持</td><td style="text-align:center;">不支持</td></tr><tr><td style="text-align:center;">Full-text</td><td style="text-align:center;">5.6版本之后支持</td><td style="text-align:center;">支持</td><td style="text-align:center;">不支持</td></tr></tbody></table><p>平时所说的索引，没有特别指明，都是B+Tree结构的索引。</p><h5 id="b-tree-索引" tabindex="-1">B+ Tree 索引 <a class="header-anchor" href="#b-tree-索引" aria-label="Permalink to &quot;B+ Tree 索引&quot;">​</a></h5><blockquote><p>sql 存储引擎的默认索引类型</p><ul><li>不需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</li><li>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</li><li>可以指定多个列作为索引列，多个索引列共同组成键。</li><li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</li></ul></blockquote><h6 id="聚簇索引" tabindex="-1">聚簇索引 <a class="header-anchor" href="#聚簇索引" aria-label="Permalink to &quot;聚簇索引&quot;">​</a></h6><blockquote><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p><p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。</p><p>因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。InnoDB创建索引的具体规则如下：</p><blockquote><ol><li>在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。</li><li>如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。</li><li>如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。</li></ol></blockquote></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301625862.png" alt="image-20220319115633139"></p><blockquote></blockquote><h6 id="非聚簇索引-辅助索引" tabindex="-1">非聚簇索引(辅助索引) <a class="header-anchor" href="#非聚簇索引-辅助索引" aria-label="Permalink to &quot;非聚簇索引(辅助索引)&quot;">​</a></h6><blockquote><p>InnoDB辅助索引中的叶子节点存储的数据是该行的主键值。在检索时，InnoDB使用此主键值在聚簇索引中搜索行记录。</p><p>因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找，这个过程也被称作<strong>回表</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301625446.png" alt="image-20220319115800358"></p><h5 id="哈希索引" tabindex="-1">哈希索引 <a class="header-anchor" href="#哈希索引" aria-label="Permalink to &quot;哈希索引&quot;">​</a></h5><blockquote><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p></blockquote><h5 id="全文索引" tabindex="-1">全文索引 <a class="header-anchor" href="#全文索引" aria-label="Permalink to &quot;全文索引&quot;">​</a></h5><blockquote><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 sql 5.6.4 版本中也开始支持全文索引。</p><p>只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。</p></blockquote><h5 id="空间数据索引" tabindex="-1">空间数据索引 <a class="header-anchor" href="#空间数据索引" aria-label="Permalink to &quot;空间数据索引&quot;">​</a></h5><blockquote><p>MyISAM 5.7之后存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。</p><p>空间数据索引从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><ul><li>必须使用 GIS 相关的函数来维护数据。</li></ul></blockquote><h5 id="索引分类1" tabindex="-1">索引分类1 <a class="header-anchor" href="#索引分类1" aria-label="Permalink to &quot;索引分类1&quot;">​</a></h5><ol><li><p>单列索引</p></li><li><p>组合索引</p><p>组合索引的使用，需要遵循<strong>最左前缀匹配原则（最左匹配原则）</strong>。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。</p></li></ol><h5 id="索引分类2" tabindex="-1">索引分类2 <a class="header-anchor" href="#索引分类2" aria-label="Permalink to &quot;索引分类2&quot;">​</a></h5><table><thead><tr><th style="text-align:center;">分类</th><th style="text-align:center;">含义</th><th style="text-align:center;">特点</th><th style="text-align:center;">关键字</th></tr></thead><tbody><tr><td style="text-align:center;">主键索引</td><td style="text-align:center;">针对于表中主键的索引</td><td style="text-align:center;">默认自动创建，只能有一个</td><td style="text-align:center;">PRIMARY</td></tr><tr><td style="text-align:center;">唯一索引</td><td style="text-align:center;">避免同一个表中某数据列中的值重复</td><td style="text-align:center;">可以有多个</td><td style="text-align:center;">UNIQUE</td></tr><tr><td style="text-align:center;">常规索引</td><td style="text-align:center;">可以定位特定数据</td><td style="text-align:center;">可以有多个</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">全文索引</td><td style="text-align:center;">全文索引查找的是文本中的关键字，而不是比较索引中的值</td><td style="text-align:center;">可以有多个</td><td style="text-align:center;">FULLTEXT</td></tr></tbody></table><h5 id="索引语法" tabindex="-1">索引语法 <a class="header-anchor" href="#索引语法" aria-label="Permalink to &quot;索引语法&quot;">​</a></h5><h6 id="创建索引" tabindex="-1"><strong>创建索引</strong> <a class="header-anchor" href="#创建索引" aria-label="Permalink to &quot;**创建索引**&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">CREATE</span><span style="color:#E1E4E8;"> [UNIQUE|FULLTEXT] </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> index_name </span><span style="color:#F97583;">ON</span><span style="color:#E1E4E8;"> table_name (col0,col1,...);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">CREATE</span><span style="color:#24292E;"> [UNIQUE|FULLTEXT] </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> index_name </span><span style="color:#D73A49;">ON</span><span style="color:#24292E;"> table_name (col0,col1,...);</span></span></code></pre></div><h6 id="查看索引" tabindex="-1"><strong>查看索引</strong> <a class="header-anchor" href="#查看索引" aria-label="Permalink to &quot;**查看索引**&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">SHOW </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> table_name;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">SHOW </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> table_name;</span></span></code></pre></div><h6 id="删除索引" tabindex="-1"><strong>删除索引</strong> <a class="header-anchor" href="#删除索引" aria-label="Permalink to &quot;**删除索引**&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">DROP</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> index_name </span><span style="color:#F97583;">ON</span><span style="color:#E1E4E8;"> table_name;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">DROP</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> index_name </span><span style="color:#D73A49;">ON</span><span style="color:#24292E;"> table_name;</span></span></code></pre></div><h4 id="索引下推-icp" tabindex="-1">索引下推(ICP) <a class="header-anchor" href="#索引下推-icp" aria-label="Permalink to &quot;索引下推(ICP)&quot;">​</a></h4><blockquote><p>执行查询<code>explain</code>看见<code>Extra</code>中显示了<code>Using index condition</code>，表示出现了<strong>索引下推</strong>(代表可以使用，但是不一定真实使用)</p><p>某种场景下ICP通过联合索引中本来就有的数据直接过滤，不需要再查到一堆无用的数据去Server层进行过滤，这样的话减少了回表的次数和返回的数据，IO次数减少了，对性能有很好的提升。</p><ol><li>首先，ICP适用于range、ref、eq_ref和ref_or_null的场景下</li><li>InnoDB和MyISAM都支持ICP，sql partition分表的话也可以使用</li><li>对于InndoDB而言，ICP只支持二级索引，因为主键索引它用不上</li><li>子查询不支持</li></ol><p>sql5.6以上的版本，默认就是开启ICP</p><p>关闭命令<code>SET optimizer_switch = &#39;index_condition_pushdown=off&#39;;</code></p></blockquote><h4 id="索引失效" tabindex="-1">索引失效 <a class="header-anchor" href="#索引失效" aria-label="Permalink to &quot;索引失效&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301625358.png" alt="image-20220319133051026"></p><blockquote><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>sql 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul></blockquote><h4 id="索引优化" tabindex="-1">索引优化 <a class="header-anchor" href="#索引优化" aria-label="Permalink to &quot;索引优化&quot;">​</a></h4><blockquote><p><strong>索引作用</strong></p><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><p><strong>索引使用条件</strong></p><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效(因为可能需要<strong>回表</strong>)</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul></blockquote><h5 id="独立列" tabindex="-1">独立列 <a class="header-anchor" href="#独立列" aria-label="Permalink to &quot;独立列&quot;">​</a></h5><blockquote><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引</p></blockquote><h5 id="多列索引" tabindex="-1">多列索引 <a class="header-anchor" href="#多列索引" aria-label="Permalink to &quot;多列索引&quot;">​</a></h5><blockquote><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好</p></blockquote><h5 id="索引列顺序" tabindex="-1">索引列顺序 <a class="header-anchor" href="#索引列顺序" aria-label="Permalink to &quot;索引列顺序&quot;">​</a></h5><blockquote><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。</p><p>选择性越高，每个记录的区分度越高，查询效率也越高</p></blockquote><h5 id="前缀索引" tabindex="-1">前缀索引 <a class="header-anchor" href="#前缀索引" aria-label="Permalink to &quot;前缀索引&quot;">​</a></h5><p>表结构当中经常会出现文本类型的字段，当字段类型为字符串（varchar,text）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时浪费大量的磁盘IO，影响查询效率，此时可以将字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">create</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">index</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">idx_xxx</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">on</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">table</span><span style="color:#E1E4E8;"> (column(N));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">create</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">index</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">idx_xxx</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">on</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">table</span><span style="color:#24292E;"> (column(N));</span></span></code></pre></div><p><strong>前缀长度</strong></p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和表记录的总数的比值，索引选择性越高，查询效率越高。唯一索引的选择性是1，这是做好的索引选择性，性能也是最好的。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 查询截取前N个字符的不重复的记录 / 所有记录树 为该字段的选择性</span></span>
<span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">count</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">DISTINCT</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">substring</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">NAME</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, N ))) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">count</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 查询截取前N个字符的不重复的记录 / 所有记录树 为该字段的选择性</span></span>
<span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">count</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">DISTINCT</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">substring</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">NAME</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, N ))) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">count</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301625892.png" alt="在这里插入图片描述"></p><blockquote><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p></blockquote><h5 id="覆盖索引" tabindex="-1">覆盖索引 <a class="header-anchor" href="#覆盖索引" aria-label="Permalink to &quot;覆盖索引&quot;">​</a></h5><p>使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引已经全部能够找到），减少<code>select * </code>。</p><p>在<code>Explain SQL</code>时关注Extra 列出现<code>using index condition</code>或者<code>NULL</code> 说明查找使用了索引，但是需要回表查询数据。</p><p><code>using where;using index</code>说明查找使用了索引，但是需要的数据都在索引列种能够找到，所以不需要回表查询。</p><p>当查询的字段不在索引种能够找到，从而查询聚集索引拿到数据，这样的操作称作回表。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301625085.png" alt="在这里插入图片描述"></p><blockquote><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul></blockquote><h5 id="sql-提示" tabindex="-1">SQL 提示 <a class="header-anchor" href="#sql-提示" aria-label="Permalink to &quot;SQL 提示&quot;">​</a></h5><p>SQL提示是优化数据库的一个重要手段，简单来说，在SQL语句种加入一些人为的提示来达到优化操作的目的。比如： 一个联合索引（name,id_card,status）和普通索引（name）到底用哪个索引呢？</p><h6 id="use-index" tabindex="-1">use index <a class="header-anchor" href="#use-index" aria-label="Permalink to &quot;use index&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 使用某个索引</span></span>
<span class="line"><span style="color:#E1E4E8;">explain </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> emp </span><span style="color:#F97583;">use</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">index</span><span style="color:#E1E4E8;">(idx_name_gen_add) </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">name</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;韦一笑&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 使用某个索引</span></span>
<span class="line"><span style="color:#24292E;">explain </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> emp </span><span style="color:#D73A49;">use</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">index</span><span style="color:#24292E;">(idx_name_gen_add) </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">name</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;韦一笑&#39;</span></span></code></pre></div><h6 id="ignore-index" tabindex="-1">ignore index <a class="header-anchor" href="#ignore-index" aria-label="Permalink to &quot;ignore index&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 忽略某个索引</span></span>
<span class="line"><span style="color:#E1E4E8;">explain </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> emp </span><span style="color:#F97583;">ignore</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">index</span><span style="color:#E1E4E8;">(idx_name_gen_add) </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">name</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;韦一笑&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 忽略某个索引</span></span>
<span class="line"><span style="color:#24292E;">explain </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> emp </span><span style="color:#D73A49;">ignore</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">index</span><span style="color:#24292E;">(idx_name_gen_add) </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">name</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;韦一笑&#39;</span></span></code></pre></div><h6 id="force-index" tabindex="-1">force index <a class="header-anchor" href="#force-index" aria-label="Permalink to &quot;force index&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">-- 强制使用某个索引</span></span>
<span class="line"><span style="color:#E1E4E8;">explain </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> emp </span><span style="color:#F97583;">force</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">index</span><span style="color:#E1E4E8;">(idx_name_gen_add) </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">name</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;韦一笑&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">-- 强制使用某个索引</span></span>
<span class="line"><span style="color:#24292E;">explain </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> emp </span><span style="color:#D73A49;">force</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">index</span><span style="color:#24292E;">(idx_name_gen_add) </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">name</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;韦一笑&#39;</span></span></code></pre></div><h5 id="索引选择性分析" tabindex="-1">索引选择性分析 <a class="header-anchor" href="#索引选择性分析" aria-label="Permalink to &quot;索引选择性分析&quot;">​</a></h5><blockquote><p>通过如下 SQL 得到全列选择性：</p><div class="language-cobol vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cobol</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">COUNT</span><span style="color:#E1E4E8;">(DISTINCT column_name) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">COUNT</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">*</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> table_name;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">COUNT</span><span style="color:#24292E;">(DISTINCT column_name) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">COUNT</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">*</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> table_name;</span></span></code></pre></div><p>通过如下 SQL 得到某一长度前缀的选择性：</p><div class="language-cobol vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cobol</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">SELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">COUNT</span><span style="color:#E1E4E8;">(DISTINCT </span><span style="color:#F97583;">LEFT</span><span style="color:#E1E4E8;">(column_name, prefix_length)) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">COUNT</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">*</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> table_name;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">SELECT</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">COUNT</span><span style="color:#24292E;">(DISTINCT </span><span style="color:#D73A49;">LEFT</span><span style="color:#24292E;">(column_name, prefix_length)) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">COUNT</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">*</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> table_name;</span></span></code></pre></div></blockquote><h5 id="索引优化总结" tabindex="-1">索引优化总结 <a class="header-anchor" href="#索引优化总结" aria-label="Permalink to &quot;索引优化总结&quot;">​</a></h5><blockquote><ul><li>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</li><li>数据量超过 300 的表应该有索引。</li><li>经常与其他表进行连接的表，在连接字段上应该建立索引。</li><li>经常出现在 WHERE 子句中的字段，特别是大表的字段，应该建立索引。</li><li>索引应该建在选择性高的字段上。</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引。</li><li>复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替。</li><li>正确选择复合索引中的主列字段，一般是选择性较好的字段。</li><li>经常同时以 AND 方式出现在 WHERE 子句中，则可以建立复合索引；否则考虑单字段索引。</li><li>如果复合索引中包含的字段经常单独出现在 WHERE 子句中，则分解为多个单字段索引。</li><li>如果复合索引所包含的字段超过 3 个，那么仔细考虑其必要性，考虑减少复合的字段。</li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引。</li><li>频繁进行数据操作的表，不要建立太多的索引。</li><li>删除无用的索引，避免对执行计划造成负面影响。</li><li>表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。</li><li>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</li></ul></blockquote><h4 id="索引设计原则" tabindex="-1">索引设计原则 <a class="header-anchor" href="#索引设计原则" aria-label="Permalink to &quot;索引设计原则&quot;">​</a></h4><ol><li>针对于数据量比较大，查询比较频繁的表</li><li>针对于常作为查询条件，排序，分组操作的字段建立索引。</li><li>尽量选择分区度高的列作为索引，尽量做唯一索引，区分度越高，效率越高。</li><li>如果是字符串且字符串长度较长，可以针对字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时联合索引喝多时候可以覆盖索引，节省存储空间避免回表。</li><li>索引越多，维护表结构的代价越大，影响增删改的效率。</li><li>如果所有列不能为空时，创建表时使用<code>NOT NULL</code>约束，当优化器知道每列包含<code>NULL</code> 值时，可以更好的确定哪个索引最有效地用于查询。</li></ol><h3 id="_1-4、事务" tabindex="-1">1.4、事务 <a class="header-anchor" href="#_1-4、事务" aria-label="Permalink to &quot;1.4、事务&quot;">​</a></h3><blockquote><p>事务是指满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p></blockquote><h4 id="事务原理" tabindex="-1">事务原理 <a class="header-anchor" href="#事务原理" aria-label="Permalink to &quot;事务原理&quot;">​</a></h4><p>InnoDB 引擎很重要的一部分就是支持事务。</p><p>事务是一组操作的集合，他是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同事成功，要么同事失败。</p><p>特性</p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库的数据改变就是永久的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301625261.png" alt="在这里插入图片描述"></p><h5 id="redo-log-1" tabindex="-1">redo log <a class="header-anchor" href="#redo-log-1" aria-label="Permalink to &quot;redo log&quot;">​</a></h5><p>我们所讲到的ACID 的持久性就是通过redo log 来保证的。</p><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，而后者在磁盘中当事务提交之后会把所有修改信息都存到该日志文件中，用于刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301625372.png" alt="在这里插入图片描述"></p><p>redo log 保证持久性。</p><h5 id="undo-log" tabindex="-1">undo log <a class="header-anchor" href="#undo-log" aria-label="Permalink to &quot;undo log&quot;">​</a></h5><p>回滚日志，用于记录数据被修改前的信息，作用包含2个：提供回滚和MVCC（多版本并发控制）。</p><p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当delete 一条记录时，undo log 中会记录一条对应的insert 的记录，当update 一条记录时，它记录一条相对应相反的update 记录。当执行rollback 时，就可以从undo log 中逻辑记录读取到相应的内容并进行回滚。</p><p>undo log 销毁：undo log 在事务执行时，并不会立即删除undo log ，因为这些日志可能还用于MVCC 。</p><p>undo log 存储：undo log 采用段的方式进行管理记录。存放在rollback segment 回滚段中，内部包含了1024个undo log segment 。</p><p>undo log 保证事务的原子性，而undo log + redo log 保证事务的一致性。</p><h4 id="隔离级别" tabindex="-1">隔离级别 <a class="header-anchor" href="#隔离级别" aria-label="Permalink to &quot;隔离级别&quot;">​</a></h4><p><strong>未提交读（READ UNCOMMITTED）</strong></p><p>事务中的修改，即使没有提交，对其他事务也是可见的。</p><p><strong>提交读（READ COMMITTED）</strong></p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。</p><p><strong>可重复读（REPEATABLE READ）</strong></p><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><p><strong>可串行化（SERIALIZABLE）</strong></p><p>强制事务串行执行。</p><p>需要加锁实现，而其它隔离级别通常不需要。</p><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻影读</th></tr></thead><tbody><tr><td style="text-align:center;">未提交读</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">提交读</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">可重复读</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">可串行化</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr></tbody></table><h4 id="事务问题" tabindex="-1">事务问题 <a class="header-anchor" href="#事务问题" aria-label="Permalink to &quot;事务问题&quot;">​</a></h4><p><code>脏读</code></p><p>脏读指的是不同事务下，当前事务可以读取到另外事务未提交的数据。</p><p><code>不可重复读</code></p><p>不可重复读指的是同一事务内多次读取同一数据集合，读取到的数据是不一样的情况。</p><p><code>幻读</code></p><p>在同一事务下，连续执行两次同样的 sql 语句可能返回不同的结果，第二次的 sql 语句可能会返回之前不存在的行。幻读是一种特殊的不可重复读问题。</p><h4 id="事务失效场景" tabindex="-1">事务失效场景 <a class="header-anchor" href="#事务失效场景" aria-label="Permalink to &quot;事务失效场景&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301625694.png" alt="image-20220114111224311"></p><h5 id="_1-访问权限问题" tabindex="-1">1.访问权限问题 <a class="header-anchor" href="#_1-访问权限问题" aria-label="Permalink to &quot;1.访问权限问题&quot;">​</a></h5><blockquote><p>java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p><p>spring要求被代理方法必须是<code>public</code>的</p><p><code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则<code>TransactionAttribute</code>返回null，即不支持事务。</p></blockquote><h5 id="_2-方法用final修饰" tabindex="-1">2. 方法用final修饰 <a class="header-anchor" href="#_2-方法用final修饰" aria-label="Permalink to &quot;2. 方法用final修饰&quot;">​</a></h5><blockquote><p>事务方法定义成final会导致事务失效</p><p>spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p><p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p><blockquote><p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p></blockquote></blockquote><h5 id="_3-方法内部调用" tabindex="-1">3.方法内部调用 <a class="header-anchor" href="#_3-方法内部调用" aria-label="Permalink to &quot;3.方法内部调用&quot;">​</a></h5><blockquote><p>举例</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Service</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UserService</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> UserMapper userMapper;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Transactional</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(UserModel </span><span style="color:#FFAB70;">userModel</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       userMapper.</span><span style="color:#B392F0;">insertUser</span><span style="color:#E1E4E8;">(userModel);</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">updateStatus</span><span style="color:#E1E4E8;">(userModel);</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Transactional</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">updateStatus</span><span style="color:#E1E4E8;">(UserModel </span><span style="color:#FFAB70;">userModel</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">doSameThing</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 直接调用了this对象的方法,updateStatus方法不会生成事务</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Service</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UserService</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> UserMapper userMapper;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Transactional</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(UserModel </span><span style="color:#E36209;">userModel</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">       userMapper.</span><span style="color:#6F42C1;">insertUser</span><span style="color:#24292E;">(userModel);</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">updateStatus</span><span style="color:#24292E;">(userModel);</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Transactional</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">updateStatus</span><span style="color:#24292E;">(UserModel </span><span style="color:#E36209;">userModel</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">doSameThing</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 直接调用了this对象的方法,updateStatus方法不会生成事务</span></span></code></pre></div><p><code>原因</code></p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Spring在扫描Bean的时候会自动为标注了@Transactional注解的类生成一个代理类（proxy）,当有注解的方法被调用的时候，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务的操作，但是同类中的方法互相调用，相当于this.B()，此时的B方法并非是代理类调用，而是直接通过原有的Bean直接调用，所以注解会失效。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Spring在扫描Bean的时候会自动为标注了@Transactional注解的类生成一个代理类（proxy）,当有注解的方法被调用的时候，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务的操作，但是同类中的方法互相调用，相当于this.B()，此时的B方法并非是代理类调用，而是直接通过原有的Bean直接调用，所以注解会失效。</span></span></code></pre></div></blockquote><p><code>解决方案:</code> <strong>通过AopContent类</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Servcie</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ServiceA</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">save</span><span style="color:#E1E4E8;">(User </span><span style="color:#FFAB70;">user</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">queryData1</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">queryData2</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">       ((ServiceA)AopContext.</span><span style="color:#B392F0;">currentProxy</span><span style="color:#E1E4E8;">()).</span><span style="color:#B392F0;">doSave</span><span style="color:#E1E4E8;">(user);</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Transactional</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">rollbackFor</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">Exception.class)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSave</span><span style="color:#E1E4E8;">(User </span><span style="color:#FFAB70;">user</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">addData1</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">updateData2</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Servcie</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ServiceA</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">save</span><span style="color:#24292E;">(User </span><span style="color:#E36209;">user</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">queryData1</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">queryData2</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">       ((ServiceA)AopContext.</span><span style="color:#6F42C1;">currentProxy</span><span style="color:#24292E;">()).</span><span style="color:#6F42C1;">doSave</span><span style="color:#24292E;">(user);</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Transactional</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">rollbackFor</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">Exception.class)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSave</span><span style="color:#24292E;">(User </span><span style="color:#E36209;">user</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">addData1</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">updateData2</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></blockquote><h5 id="_4-未被spring管理" tabindex="-1">4.未被spring管理 <a class="header-anchor" href="#_4-未被spring管理" aria-label="Permalink to &quot;4.未被spring管理&quot;">​</a></h5><blockquote><p>使用spring事务的前提是：对象要被spring管理，需要创建bean实例。</p><p>通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。</p></blockquote><h5 id="_5-多线程调用" tabindex="-1">5.多线程调用 <a class="header-anchor" href="#_5-多线程调用" aria-label="Permalink to &quot;5.多线程调用&quot;">​</a></h5><blockquote><p>在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p></blockquote><h5 id="_6-表不支持事务" tabindex="-1">6.表不支持事务 <a class="header-anchor" href="#_6-表不支持事务" aria-label="Permalink to &quot;6.表不支持事务&quot;">​</a></h5><blockquote><p>myisam<code>不支持事务</code></p><p>innodb<code>支持事务</code></p></blockquote><h5 id="_7-错误的传播特性" tabindex="-1">7.错误的传播特性 <a class="header-anchor" href="#_7-错误的传播特性" aria-label="Permalink to &quot;7.错误的传播特性&quot;">​</a></h5><blockquote><p>使用<code>@Transactional</code>注解时，是可以指定<code>propagation</code>参数的。</p><p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p><ul><li><code>REQUIRED</code> 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li><li><code>SUPPORTS</code> 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。</li><li><code>MANDATORY</code> 如果当前上下文中存在事务，否则抛出异常。</li><li><code>REQUIRES_NEW</code> 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</li><li><code>NOT_SUPPORTED</code> 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。</li><li><code>NEVER</code> 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。</li><li><code>NESTED</code> 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</li></ul><p>注解<code>@Transactional</code>中Propagation属性值设置错误</p><p>只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p></blockquote><h5 id="_8-未抛出异常" tabindex="-1">8.未抛出异常 <a class="header-anchor" href="#_8-未抛出异常" aria-label="Permalink to &quot;8.未抛出异常&quot;">​</a></h5><blockquote><p>业务代码中存在异常时，使用try…catch…语句块捕获，而catch语句块没有throw new RuntimeExecption异常</p></blockquote><h5 id="_9-嵌套事务回滚超出预期" tabindex="-1">9.嵌套事务回滚超出预期 <a class="header-anchor" href="#_9-嵌套事务回滚超出预期" aria-label="Permalink to &quot;9.嵌套事务回滚超出预期&quot;">​</a></h5><blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UserService</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> UserMapper userMapper;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> RoleService roleService;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Transactional</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(UserModel </span><span style="color:#FFAB70;">userModel</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">          userMapper.</span><span style="color:#B392F0;">insertUser</span><span style="color:#E1E4E8;">(userModel);</span></span>
<span class="line"><span style="color:#E1E4E8;">          roleService.</span><span style="color:#B392F0;">doOtherThing</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Service</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RoleService</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Transactional</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">propagation</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Propagation.NESTED)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doOtherThing</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">          System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;保存role表数据&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UserService</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> UserMapper userMapper;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> RoleService roleService;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Transactional</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(UserModel </span><span style="color:#E36209;">userModel</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> Exception {</span></span>
<span class="line"><span style="color:#24292E;">          userMapper.</span><span style="color:#6F42C1;">insertUser</span><span style="color:#24292E;">(userModel);</span></span>
<span class="line"><span style="color:#24292E;">          roleService.</span><span style="color:#6F42C1;">doOtherThing</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Service</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RoleService</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Transactional</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">propagation</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Propagation.NESTED)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doOtherThing</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">          System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;保存role表数据&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点</p></blockquote><blockquote><p>但事实是，insertUser也回滚了</p></blockquote><blockquote><p>因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。</p></blockquote><p><code>解决方案</code></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Slf4j</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Service</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UserService</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">       @</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> UserMapper userMapper;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">       @</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> RoleService roleService;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">       @</span><span style="color:#F97583;">Transactional</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(UserModel </span><span style="color:#FFAB70;">userModel</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            userMapper.</span><span style="color:#B392F0;">insertUser</span><span style="color:#E1E4E8;">(userModel);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 嵌套事务 try/catch</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                roleService.</span><span style="color:#B392F0;">doOtherThing</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Exception </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                log.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(e.</span><span style="color:#B392F0;">getMessage</span><span style="color:#E1E4E8;">(), e);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">       }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Slf4j</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Service</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UserService</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">       @</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> UserMapper userMapper;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">       @</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> RoleService roleService;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">       @</span><span style="color:#D73A49;">Transactional</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(UserModel </span><span style="color:#E36209;">userModel</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> Exception {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            userMapper.</span><span style="color:#6F42C1;">insertUser</span><span style="color:#24292E;">(userModel);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 嵌套事务 try/catch</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                roleService.</span><span style="color:#6F42C1;">doOtherThing</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Exception </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                log.</span><span style="color:#6F42C1;">error</span><span style="color:#24292E;">(e.</span><span style="color:#6F42C1;">getMessage</span><span style="color:#24292E;">(), e);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">       }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>将内部嵌套事务放在try/catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p></blockquote></blockquote><h5 id="_10-大事务问题" tabindex="-1">10.大事务问题 <a class="header-anchor" href="#_10-大事务问题" aria-label="Permalink to &quot;10.大事务问题&quot;">​</a></h5><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301626229.png" alt="image-20220114113044661"></p><h6 id="_1-编程式事务解决方案" tabindex="-1">1.编程式事务解决方案 <a class="header-anchor" href="#_1-编程式事务解决方案" aria-label="Permalink to &quot;1.编程式事务解决方案&quot;">​</a></h6><blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> TransactionTemplate transactionTemplate;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">save</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> User user) {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">queryData1</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">queryData2</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">   transactionTemplate.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">((status) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">           </span><span style="color:#B392F0;">addData1</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">           </span><span style="color:#B392F0;">updateData2</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">           </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Boolean.TRUE;</span></span>
<span class="line"><span style="color:#E1E4E8;">        })</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ```</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span></span>
<span class="line"><span style="color:#E1E4E8;">TransactionTemplate，在它的execute方法中，就实现了事务的功能</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">相较于`@</span><span style="color:#F97583;">Transactional</span><span style="color:#E1E4E8;">`注解声明式事务，我更建议大家使用，基于`TransactionTemplate`的编程式事务。主要原因如下：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF;">1.</span><span style="color:#E1E4E8;"> 避免由于spring aop问题，导致事务失效的问题。</span></span>
<span class="line"><span style="color:#79B8FF;">2.</span><span style="color:#E1E4E8;"> 能够更小粒度的控制事务的范围，更直观。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> TransactionTemplate transactionTemplate;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">save</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> User user) {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">queryData1</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">queryData2</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">   transactionTemplate.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">((status) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#6F42C1;">addData1</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#6F42C1;">updateData2</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Boolean.TRUE;</span></span>
<span class="line"><span style="color:#24292E;">        })</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    ```</span></span>
<span class="line"><span style="color:#24292E;">   </span></span>
<span class="line"><span style="color:#24292E;">TransactionTemplate，在它的execute方法中，就实现了事务的功能</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">相较于`@</span><span style="color:#D73A49;">Transactional</span><span style="color:#24292E;">`注解声明式事务，我更建议大家使用，基于`TransactionTemplate`的编程式事务。主要原因如下：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#005CC5;">1.</span><span style="color:#24292E;"> 避免由于spring aop问题，导致事务失效的问题。</span></span>
<span class="line"><span style="color:#005CC5;">2.</span><span style="color:#24292E;"> 能够更小粒度的控制事务的范围，更直观。</span></span></code></pre></div></blockquote><h6 id="_2-将查询-select-方法放到事务外" tabindex="-1">2.将查询(select)方法放到事务外 <a class="header-anchor" href="#_2-将查询-select-方法放到事务外" aria-label="Permalink to &quot;2.将查询(select)方法放到事务外&quot;">​</a></h6><blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> TransactionTemplate transactionTemplate;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">save</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> User user) {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">queryData1</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">queryData2</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">       transactionTemplate.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">((status) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">           </span><span style="color:#B392F0;">addData1</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">           </span><span style="color:#B392F0;">updateData2</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Boolean.TRUE;</span></span>
<span class="line"><span style="color:#E1E4E8;">        })</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> TransactionTemplate transactionTemplate;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">save</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> User user) {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">queryData1</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">queryData2</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">       transactionTemplate.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">((status) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#6F42C1;">addData1</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#6F42C1;">updateData2</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Boolean.TRUE;</span></span>
<span class="line"><span style="color:#24292E;">        })</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Servcie</span></span>
<span class="line"><span style="color:#E1E4E8;">publicclass ServiceA {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">save</span><span style="color:#E1E4E8;">(User user) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">queryData1</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">queryData2</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">       ((ServiceA)AopContext.</span><span style="color:#B392F0;">currentProxy</span><span style="color:#E1E4E8;">()).</span><span style="color:#B392F0;">doSave</span><span style="color:#E1E4E8;">(user);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">      @</span><span style="color:#F97583;">Transactional</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">rollbackFor</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">Exception.class)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSave</span><span style="color:#E1E4E8;">(User user) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">addData1</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">updateData2</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Servcie</span></span>
<span class="line"><span style="color:#24292E;">publicclass ServiceA {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">save</span><span style="color:#24292E;">(User user) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">queryData1</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">queryData2</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">       ((ServiceA)AopContext.</span><span style="color:#6F42C1;">currentProxy</span><span style="color:#24292E;">()).</span><span style="color:#6F42C1;">doSave</span><span style="color:#24292E;">(user);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">      @</span><span style="color:#D73A49;">Transactional</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">rollbackFor</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">Exception.class)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSave</span><span style="color:#24292E;">(User user) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">addData1</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">updateData2</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span></code></pre></div></blockquote><h6 id="_3-事务中避免远程调用" tabindex="-1">3.事务中避免远程调用 <a class="header-anchor" href="#_3-事务中避免远程调用" aria-label="Permalink to &quot;3.事务中避免远程调用&quot;">​</a></h6><h6 id="_4-事务中避免一次性处理太多数据" tabindex="-1">4.事务中避免一次性处理太多数据 <a class="header-anchor" href="#_4-事务中避免一次性处理太多数据" aria-label="Permalink to &quot;4.事务中避免一次性处理太多数据&quot;">​</a></h6><blockquote><p>分页处理，1000条数据，分50页，一次只处理20条数据，这样可以大大减少大事务的出现。</p></blockquote><h6 id="_5-非事务执行" tabindex="-1">5.非事务执行 <a class="header-anchor" href="#_5-非事务执行" aria-label="Permalink to &quot;5.非事务执行&quot;">​</a></h6><h6 id="_6-异步处理" tabindex="-1">6.异步处理 <a class="header-anchor" href="#_6-异步处理" aria-label="Permalink to &quot;6.异步处理&quot;">​</a></h6><h3 id="_1-5、mvcc" tabindex="-1">1.5、MVCC <a class="header-anchor" href="#_1-5、mvcc" aria-label="Permalink to &quot;1.5、MVCC&quot;">​</a></h3><h5 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h5><h6 id="当前读" tabindex="-1">当前读 <a class="header-anchor" href="#当前读" aria-label="Permalink to &quot;当前读&quot;">​</a></h6><p>读取的是当前记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。如：<code>select lock in share mode</code>，<code>select for update</code>，<code>update</code>，<code>insert</code>，<code>update</code>,<code>delete</code>（排他锁）都是一种当前读。</p><h6 id="快照读" tabindex="-1">快照读 <a class="header-anchor" href="#快照读" aria-label="Permalink to &quot;快照读&quot;">​</a></h6><p>简单的select(不加锁)就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>RC 每次select，都生成快照读（因为每次都生成快照，所以会读到其他事务提交）。</li><li>RR 开启事务第一个select 语句才是快照读。</li><li>Serializable 快照读会退化为当前读。</li></ul><h6 id="mvcc" tabindex="-1">MVCC <a class="header-anchor" href="#mvcc" aria-label="Permalink to &quot;MVCC&quot;">​</a></h6><p>Mulit-Version Concurrency Control 多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为sql 实现的MVCC 提供了一个非阻塞读功能。MVCC 的具体实现，还需要依赖于数据库记录中的三个隐式字段、unlog 日志 readview。</p><h5 id="隐藏字段" tabindex="-1">隐藏字段 <a class="header-anchor" href="#隐藏字段" aria-label="Permalink to &quot;隐藏字段&quot;">​</a></h5><p>InnoDB 在创建表的时候会多创建2个字段，分别是<code>DB_TRX_ID</code>，<code>DB_ROLL_PTR</code>，<s><code>DB_ROW_ID</code></s>。</p><table><thead><tr><th style="text-align:center;">隐式字段</th><th style="text-align:center;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">DB_TRX_ID</td><td style="text-align:center;">最近修改事务ID，记录插入这条记录或者最后修改该记录的事务ID</td></tr><tr><td style="text-align:center;">DB_ROLL_PTR</td><td style="text-align:center;">回滚指针，指向这条记录的上一个版本，用于配合undo log ,指向上一个版本</td></tr><tr><td style="text-align:center;">DB_ROW_ID</td><td style="text-align:center;">隐藏主键，如果表结果没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><h5 id="undo-log-版本链" tabindex="-1">undo log 版本链 <a class="header-anchor" href="#undo-log-版本链" aria-label="Permalink to &quot;undo log 版本链&quot;">​</a></h5><p>回滚日志，在insert update delete 的时候产生的便于数据回滚的日志。</p><p>当insert 的时候，产生的undo log 日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete 的时候产生的undo log 日志不仅在回滚是需要，在快照读时也需要，不会被立即删除。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301626253.png" alt="在这里插入图片描述"></p><p>不同事务或者相同事务对同一条记录进行修改，会导致该记录的undo log 生成一条记录版本链表，链表的头部是最新的旧记录，尾部是最旧的记录。</p><h5 id="readview-介绍" tabindex="-1">readview 介绍 <a class="header-anchor" href="#readview-介绍" aria-label="Permalink to &quot;readview 介绍&quot;">​</a></h5><p>读视图是快照读SQL 执行时MVCC 提取数据的一句，记录并维护系统当前活跃的事务（未提交的）ID</p><p>read view 包括了四个核心字段：</p><table><thead><tr><th style="text-align:center;">字段</th><th style="text-align:center;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">m_ids</td><td style="text-align:center;">当前活跃的事务ID集合</td></tr><tr><td style="text-align:center;">min_trx_id</td><td style="text-align:center;">最小活跃事务ID</td></tr><tr><td style="text-align:center;">max_trx_id</td><td style="text-align:center;">预分配事务ID，当前最大事务ID+1（事务ID是自增的）</td></tr><tr><td style="text-align:center;">creator_trx_id</td><td style="text-align:center;">Read View 创建者的事务ID</td></tr></tbody></table><p cases="">$$ 版本链数据访问规则 \begin</p><ol><li>trx—id=creator—trx—id, &amp;可以访问该版本 (当前事务更改的)\</li><li>trx—id &lt; min—trx—id, &amp;可以访问该版本（数据已经提交）\</li><li>trx—id &gt; max—trx—id, &amp;不可以访问该版本（当前事务是在ReadView 生成之后开启的）\</li><li>min—trx—id \le trx—id \le max—trx—id, &amp;如果trx—id不在m-ids中是可以访问该版本的（事务已经提交） \end{cases} $$</li></ol><p>不同的事务隔离级别，生成的readview 的时机不同。</p><p>RC 每次都生成 readview ，RR 只在事务第一次执行快照读的时候生成readview，后续复用该readview。</p><h5 id="原理分析-rc" tabindex="-1">原理分析（RC） <a class="header-anchor" href="#原理分析-rc" aria-label="Permalink to &quot;原理分析（RC）&quot;">​</a></h5><p><strong>RC 每次都生成 readview 。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301626479.png" alt="在这里插入图片描述"></p><h5 id="原理分析-rr" tabindex="-1">原理分析（RR） <a class="header-anchor" href="#原理分析-rr" aria-label="Permalink to &quot;原理分析（RR）&quot;">​</a></h5><p><strong>事务在第一次执行快照读时生成ReadView，后续复用该ReadView。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301626509.png" alt="在这里插入图片描述"></p><p>MVCC 主要还是通过隐藏字段（事务id，回滚指针）、undo log 版本链，readview 实现，MVCC + 锁保证了事务的隔离性。</p><h3 id="_1-6、锁" tabindex="-1">1.6、锁 <a class="header-anchor" href="#_1-6、锁" aria-label="Permalink to &quot;1.6、锁&quot;">​</a></h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库种，除传统的计算机资源（CPU，RAM，I/O）的争用以外，数据也是一种提供多用户共享的资源。如何保证数据并发访问的一致性，有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更复杂。</p><p>按照锁的粒度来分，sql中的锁分为以下三类</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：每次操作锁住对于的行数据。</li></ul><h4 id="全局锁" tabindex="-1">全局锁 <a class="header-anchor" href="#全局锁" aria-label="Permalink to &quot;全局锁&quot;">​</a></h4><p>对整个数据库实例枷锁，枷锁后整个实例就处于制度状态，后续的DML的写语句，DDL语句，以及更新操作的事务提交语句都将被阻塞。通常用于备份数据<code>sqldump</code>。</p><h4 id="表级锁" tabindex="-1">表级锁 <a class="header-anchor" href="#表级锁" aria-label="Permalink to &quot;表级锁&quot;">​</a></h4><p>表级锁，每次操作锁住整张表。锁粒度打，发视锁冲突的概率高，并发度最低，应用在MyISAM，InnoDB等存储引擎中。</p><p>对于表级锁，主要分三类</p><ol><li>表锁</li><li>元数据锁</li><li>意向锁</li></ol><h5 id="表锁-1" tabindex="-1">表锁 <a class="header-anchor" href="#表锁-1" aria-label="Permalink to &quot;表锁&quot;">​</a></h5><p>表锁分为2类</p><ol><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ol><p>加锁：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">lock tables </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">read/</span><span style="color:#E1E4E8;">write</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">lock tables </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">read/</span><span style="color:#24292E;">write</span></span></code></pre></div><p>释放锁：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">unlock</span><span style="color:#E1E4E8;"> tables</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">unlock</span><span style="color:#24292E;"> tables</span></span></code></pre></div><h6 id="读锁" tabindex="-1">读锁 <a class="header-anchor" href="#读锁" aria-label="Permalink to &quot;读锁&quot;">​</a></h6><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301626007.png" alt="在这里插入图片描述"></p><p>客户端1在表上加锁，客户端1和其他客户端都只能够查询，不能够写。当客户端1去写入数据会直接提示 <code>Table &#39;xxx&#39; was locked with a READ lock and can&#39;t be updated</code>，当其他客户端写入数据时，会直接阻塞，直到客户端1解锁。</p><h6 id="写锁" tabindex="-1">写锁 <a class="header-anchor" href="#写锁" aria-label="Permalink to &quot;写锁&quot;">​</a></h6><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301626831.png" alt="在这里插入图片描述"></p><p>客户端1在表上加锁，只有客户端1能够读写。当其他客户端读写数据时，都会直接阻塞，直到客户端1解锁。</p><h5 id="元数据锁" tabindex="-1">元数据锁 <a class="header-anchor" href="#元数据锁" aria-label="Permalink to &quot;元数据锁&quot;">​</a></h5><p>元数据锁（meta data lock ), MDL 加锁过程是系统自动控制，无需显示使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML和DDL冲突，保证读写的正确性</strong>。</p><p>在sql 5.5 中引用了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当表结构进行变更操作的时候，加上MDL写锁（排他）。</p><table><thead><tr><th style="text-align:center;">对应SQL</th><th style="text-align:center;">锁类型</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">lock tables xxx read/write</td><td style="text-align:center;">SHARED_READ_ONLY/SHARED_NO_READ_WRITE</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">select ,select... lock in share mode</td><td style="text-align:center;">SHARED_READ</td><td style="text-align:center;">与SHARED_READ，SHARED_WRITE兼容。与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center;">insert ,update, delete, select... for update</td><td style="text-align:center;">SHARED_WRITE</td><td style="text-align:center;">与SHARED_READ，SHARED_WRITE兼容。与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center;">alter table...</td><td style="text-align:center;">EXCLUSIVE</td><td style="text-align:center;">与其他的MDL都互斥</td></tr></tbody></table><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> object_type,object_schema,object_name,lock_type,lock_duration </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">performace_schema</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">metadata_locks</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> object_type,object_schema,object_name,lock_type,lock_duration </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">performace_schema</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">metadata_locks</span><span style="color:#24292E;">;</span></span></code></pre></div><p>当开启一个事务的时候不会产生元数据锁，只有增删查改，修改表结构的时候才会看到自动加锁。</p><h5 id="意向锁" tabindex="-1">意向锁 <a class="header-anchor" href="#意向锁" aria-label="Permalink to &quot;意向锁&quot;">​</a></h5><p>为了避免DML 在执行时，加的行锁与表锁的冲突，在InnoDB 中应如何了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><p>不用逐行检查行锁，而是检查意向锁的情况，如果意向锁和当前加的锁是兼容的，如果兼容直接加锁，如果不兼容就会处于阻塞状态，知道A线程提交事务，解锁意向锁。</p><table><thead><tr><th style="text-align:center;">意向共享锁（IS）</th><th style="text-align:center;">意向拍打锁（IX）</th></tr></thead><tbody><tr><td style="text-align:center;">由语句select ... lock in share mode添加。</td><td style="text-align:center;">由 insert，update，delete，select ... for update添加。</td></tr><tr><td style="text-align:center;">与表锁共享锁read 兼容，与表锁排他write锁互斥</td><td style="text-align:center;">与表锁共享锁read ，表锁排他write锁互斥。意向锁之间不会互斥</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><p>通过以下SQL 查看意向所以及行锁的加锁情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> object_schema,object_name,index_name,lock_type,lock_mode,lock_data </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">performance_schema</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">data_locks</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> object_schema,object_name,index_name,lock_type,lock_mode,lock_data </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">performance_schema</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">data_locks</span><span style="color:#24292E;">;</span></span></code></pre></div><p>意向锁主要解决的问题是在InnoDB 引擎在加表锁和行锁的冲突问题。</p><h4 id="行级锁" tabindex="-1">行级锁 <a class="header-anchor" href="#行级锁" aria-label="Permalink to &quot;行级锁&quot;">​</a></h4><p>行级锁，每次操作锁住对应的行数据。锁的力度小，发生锁冲突的概率低，并发度最高，应用在InnoDB 存储引擎中。</p><p>InnoDB 的数据是基于索引组织的。行锁是通过对表锁上的索引项加锁实现的，而不是对记录加的锁。对于行级锁，主要分一下三类：</p><ul><li><p>行锁（Record Lock）：锁定单个记录的锁，防止其他事务对此进行update 和 delete。在RC、RR 隔离级别下都支持。</p></li><li><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引间隙不变，防止其他事务在这个间隙进行insert ，产生幻读。在RR 隔离级别下都支持。</p></li><li><p>临间锁（Next-key Lock）：行锁和间隙锁的组合，同时锁住数据，并锁住数据前面的间隙Gap 。在RR 隔离级别下支持。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627191.png" alt="在这里插入图片描述"></p></li></ul><h5 id="行锁" tabindex="-1">行锁 <a class="header-anchor" href="#行锁" aria-label="Permalink to &quot;行锁&quot;">​</a></h5><p>InnoDB 实现了一下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务读取一行，阻止其他事物获得相同数据集的排他锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事物相同数据集的共享锁和排他锁。</li></ul><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">S 共享锁</th><th style="text-align:center;">X 排他锁</th></tr></thead><tbody><tr><td style="text-align:center;">S 共享锁</td><td style="text-align:center;">兼容</td><td style="text-align:center;">冲突</td></tr><tr><td style="text-align:center;">X 排他锁</td><td style="text-align:center;">冲突</td><td style="text-align:center;">冲突</td></tr></tbody></table><table><thead><tr><th style="text-align:center;">SQL</th><th style="text-align:center;">行锁类型</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">INSERT...</td><td style="text-align:center;">排他</td><td style="text-align:center;">自动加锁</td></tr><tr><td style="text-align:center;">UPDATE...</td><td style="text-align:center;">排他</td><td style="text-align:center;">自动加锁</td></tr><tr><td style="text-align:center;">DELETE...</td><td style="text-align:center;">排他</td><td style="text-align:center;">自动加锁</td></tr><tr><td style="text-align:center;">SELECT</td><td style="text-align:center;">不加锁</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">SELECT LOCK IN SHARE MODE</td><td style="text-align:center;">共享</td><td style="text-align:center;">需要手动加LOCK IN SHARE MODE</td></tr><tr><td style="text-align:center;">SELECT FOR UPDATE</td><td style="text-align:center;">排他</td><td style="text-align:center;">需要手动加 FOR UPDATE</td></tr></tbody></table><p>默认情况下，InnoDB 在RR 事物隔离级运行 InnoDB 使用 Next-key Lock 锁进行搜索和索引扫描防止幻读。</p><ol><li>针对唯一所有检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB 的行锁是针对于索引加的锁，不通过索引检索数据，那么InnoDB 将对表中所有的记录加锁，此时就会升级为表锁。</li></ol><h5 id="间隙锁-临键锁" tabindex="-1">间隙锁/临键锁 <a class="header-anchor" href="#间隙锁-临键锁" aria-label="Permalink to &quot;间隙锁/临键锁&quot;">​</a></h5><ul><li>索引上的等值查询（唯一索引）,给不存在的记录加锁，优化为间隙锁。</li><li>索引上的等值查询（普通查询），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询（唯一索引）会访问到不满足条件的第一个值位置。</li></ul><p><strong>注意：间隙锁唯一的目的是防止其他事物插入间隙，间隙锁可以共存，一个事务采用的间隙所不会阻塞另一个间隙上采用的间隙锁。</strong></p><h4 id="锁算法" tabindex="-1">锁算法 <a class="header-anchor" href="#锁算法" aria-label="Permalink to &quot;锁算法&quot;">​</a></h4><h5 id="record-lock" tabindex="-1">Record Lock <a class="header-anchor" href="#record-lock" aria-label="Permalink to &quot;Record Lock&quot;">​</a></h5><blockquote><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p></blockquote><h5 id="gap-lock" tabindex="-1">Gap Lock <a class="header-anchor" href="#gap-lock" aria-label="Permalink to &quot;Gap Lock&quot;">​</a></h5><blockquote><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</span></span></code></pre></div></blockquote><h5 id="next-key-lock" tabindex="-1">Next-Key Lock <a class="header-anchor" href="#next-key-lock" aria-label="Permalink to &quot;Next-Key Lock&quot;">​</a></h5><blockquote><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">(-∞, 10]</span></span>
<span class="line"><span style="color:#e1e4e8;">(10, 11]</span></span>
<span class="line"><span style="color:#e1e4e8;">(11, 13]</span></span>
<span class="line"><span style="color:#e1e4e8;">(13, 20]</span></span>
<span class="line"><span style="color:#e1e4e8;">(20, +∞)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">(-∞, 10]</span></span>
<span class="line"><span style="color:#24292e;">(10, 11]</span></span>
<span class="line"><span style="color:#24292e;">(11, 13]</span></span>
<span class="line"><span style="color:#24292e;">(13, 20]</span></span>
<span class="line"><span style="color:#24292e;">(20, +∞)</span></span></code></pre></div></blockquote><blockquote><p>在 InnoDB 存储引擎中，SELECT 操作的不可重复读问题通过 MVCC 得到了解决</p><p>而 UPDATE、DELETE 的不可重复读问题通过 Record Lock 解决，</p><p>INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决的。</p></blockquote><h4 id="死锁问题" tabindex="-1">死锁问题 <a class="header-anchor" href="#死锁问题" aria-label="Permalink to &quot;死锁问题&quot;">​</a></h4><blockquote><p>排查死锁问题步骤</p><p>（1）查看死锁日志 show engine innodb status;</p><p>（2）找出死锁Sql</p><p>（3）分析sql加锁情况</p><p>（4）模拟死锁案发</p><p>（5）分析死锁日志</p><p>（6）分析死锁结果</p></blockquote><h4 id="什么-sql-语句会加行锁" tabindex="-1">什么 SQL 语句会加行锁？ <a class="header-anchor" href="#什么-sql-语句会加行锁" aria-label="Permalink to &quot;什么 SQL 语句会加行锁？&quot;">​</a></h4><p><code>InnoDB</code> 引擎是支持行级锁的，而 MyISAM 引擎不支持行级锁。</p><p>普通的 select 语句是不会对记录加锁，它属于快照读，是通过 MVCC（多版本并发控制）实现的。</p><p>要在查询时对记录加行级锁，可以采用如下方式:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 对读取的记录加共享锁(S型锁)</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> ... lock </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> share mode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 对读取的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> ... </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 对读取的记录加共享锁(S型锁)</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> ... lock </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> share mode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"># 对读取的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> ... </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>1.上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。</p></blockquote><p>除了这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且都是独占锁(X型锁)。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 对操作的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#E1E4E8;">updaet </span><span style="color:#F97583;">table</span><span style="color:#E1E4E8;"> .... </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 对操作的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#F97583;">delete</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">table</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 对操作的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#24292E;">updaet </span><span style="color:#D73A49;">table</span><span style="color:#24292E;"> .... </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"># 对操作的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#D73A49;">delete</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">table</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>共享锁与独占锁的解释:</p><p>1.共享锁（S锁）满足读读共享，读写互斥。</p><p>2.独占锁（X锁）满足写写互斥、读写互斥。</p></blockquote><p>不同<code>隔离级别</code>下，行级锁的种类是不同的。</p><p>在<code>读已提交</code>隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。</p><p>在<code>可重复读</code>隔离级别下(<code>Mysql默认隔离级别</code>)，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻 读），所以行级锁的种类主要有三类:</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><p><code>Record Lock</code></p><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><p>执行如下 sql:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">mysql </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">mysql </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> t_test </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">mysql </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">mysql </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> t_test </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>1.事务会对表中主键 id = 1 的这条记录加上 X 型的记录锁，如果这时候其他事务对这条记录进行删除或者更新操作，那么这些操作都会被阻塞。</p><p>2.其他事务插入一条 id = 1 的新记录并不会被阻塞，会报主键冲突的错误，这是因为主键有唯一性的约束。</p><p>3.当事务执行 commit 后，事务过程中生成的锁都会被释放。</p></blockquote><p><code>Gap Lock</code></p><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><blockquote><p>假设表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p></blockquote><p>间隙锁之间是兼容的，即<code>两个事务可以同时持有包含共同间隙范围的间隙锁</code>，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。</p><p><code>Next-Key Lock</code></p><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><blockquote><p>假设表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务既不能插入 id = 4 记录，也不能修改和删除 id = 5 这条记录。next-key lock 即能保护该记录，又能阻止其他事务将新记录插入到被保护记录前面的间隙中。</p></blockquote><p>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被<code>阻塞</code>的。</p><h4 id="mysql-是怎么加行级锁的" tabindex="-1">MySQL 是怎么加行级锁的？ <a class="header-anchor" href="#mysql-是怎么加行级锁的" aria-label="Permalink to &quot;MySQL 是怎么加行级锁的？&quot;">​</a></h4><p>加锁的对象是<code>索引</code>，加锁的基本单位是 <code>next-key lock</code>，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。</p><p>next-key lock 在一些场景下会<code>退化</code>成记录锁或间隙锁。</p><p>在<code>能使用记录锁或者间隙锁就能避免幻读现象</code>的场景下， next-key lock 就会退化成退化成记录锁或间隙锁。</p><p>举例如下:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">CREATE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> `</span><span style="color:#B392F0;">user</span><span style="color:#E1E4E8;">` (</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">`id`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">bigint</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">NOT NULL</span><span style="color:#E1E4E8;"> AUTO_INCREMENT,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">`name`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">varchar</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">30</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">COLLATE</span><span style="color:#E1E4E8;"> utf8mb4_unicode_ci </span><span style="color:#F97583;">NOT NULL</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">`age`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">NOT NULL</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">PRIMARY KEY</span><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">`id`</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">KEY</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`index_age`</span><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">`age`</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">USING</span><span style="color:#E1E4E8;"> BTREE</span></span>
<span class="line"><span style="color:#E1E4E8;">) ENGINE</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">InnoDB </span><span style="color:#F97583;">DEFAULT</span><span style="color:#E1E4E8;"> CHARSET</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">utf8mb4 </span><span style="color:#F97583;">COLLATE=</span><span style="color:#E1E4E8;">utf8mb4_unicode_ci;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">CREATE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> `</span><span style="color:#6F42C1;">user</span><span style="color:#24292E;">` (</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">`id`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">bigint</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">NOT NULL</span><span style="color:#24292E;"> AUTO_INCREMENT,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">`name`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">varchar</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">30</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">COLLATE</span><span style="color:#24292E;"> utf8mb4_unicode_ci </span><span style="color:#D73A49;">NOT NULL</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">`age`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">NOT NULL</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">PRIMARY KEY</span><span style="color:#24292E;"> (</span><span style="color:#032F62;">`id`</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">KEY</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`index_age`</span><span style="color:#24292E;"> (</span><span style="color:#032F62;">`age`</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">USING</span><span style="color:#24292E;"> BTREE</span></span>
<span class="line"><span style="color:#24292E;">) ENGINE</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">InnoDB </span><span style="color:#D73A49;">DEFAULT</span><span style="color:#24292E;"> CHARSET</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">utf8mb4 </span><span style="color:#D73A49;">COLLATE=</span><span style="color:#24292E;">utf8mb4_unicode_ci;</span></span></code></pre></div><blockquote><p>1.id 是主键索引（唯一索引），age 是普通索引（非唯一索引），name 是普通列</p><p>2.实验环境的 MySQL 版本是 8.0.28，隔离级别是「可重复读」。</p></blockquote><p><code>唯一索引等值查询</code></p><p>用唯一索引进行等值查询时:</p><ul><li><p>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的next-key lock 会退化成「记录锁」。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>1.事务 A 会为 id 为 1 的这条记录就会加上 X 型的记录锁。</p></blockquote></li></ul><blockquote><p>2.如果有其他事务，对 id 为 1 的记录进行更新或者删除操作的话，这些操作都会被阻塞，因为更新或者删除操作也会对记录加 X 型的记录锁，而 X 锁和 X 锁之间是互斥关系。</p></blockquote><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 查看事务执行 </span><span style="color:#F97583;">SQL</span><span style="color:#E1E4E8;"> 过程中加锁</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">performance_schema</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">data_locks</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 查看事务执行 </span><span style="color:#D73A49;">SQL</span><span style="color:#24292E;"> 过程中加锁</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">performance_schema</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">data_locks</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><ol><li>LOCK_TYPE 中的 RECORD 表示行级锁,TABLE表示表锁(案例里是X 类型的意向锁)</li><li>如果 LOCK_MODE 为 X ，说明是 next-key 锁</li><li>如果 LOCK_MODE 为 X, REC_NOT_GAP ，说明是记录锁(对应案例查询sql)</li><li>如果 LOCK_MODE 为 X, GAP ，说明是间隙锁；</li></ol></blockquote><p><strong>总结</strong></p><blockquote><p>问题: 为什么唯一索引等值查询并且查询记录存在的场景下，该记录的索引中的 next-key lock 会退化成记录锁？</p><p>原因就是<code>在唯一索引等值查询并且查询记录存在的场景下，仅靠记录锁也能避免幻读</code>的问题。</p><p>幻读的定义就是，当一个事务前后两次查询的结果集，不相同时，就认为发生幻读。所以，要避免幻读就是避免结果集某一条记录被其他事务删除，或者有其他事务插入了一条新记录，这样前后两次查询的结果集就不会出现不相同的情况。</p><ul><li>由于主键具有唯一性，所以其他事务插入 id = 1 的时候，会因为主键冲突，导致无法插入 id = 1 的新记录。事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题</li><li>由于对 id = 1 加了记录锁，其他事务无法删除该记录，这样事务 A 在多次查询 id = 1的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。</li></ul></blockquote><ul><li><p>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">performance_schema</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">data_locks</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">performance_schema</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">data_locks</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>1.从上图可以看到，共加了两个锁，分别是 表锁：X 类型的意向锁 和 行锁：<code>X 类型的间隙锁</code></p></blockquote></li></ul><blockquote><p>2.事务 在 id = 5 记录的主键索引上加的是间隙锁，锁住的范围是 (1, 5)</p><p>3.如果有其他事务插入 id 值为 2、3、4 这一些记录的话，这些插入语句都会发生阻塞。</p><p>4.如果其他事务插入的 id = 1 或者 id = 5 的记录话，并不会发生阻塞，而是报主键冲突的错误，因为表中已经存在 id = 1 和 id = 5 的记录了。</p></blockquote><p><strong>总结</strong></p><blockquote><p>问题: 为什么唯一索引等值查询并且查询记录「不存在」的场景下，在索引树找到第一条大于该查询记录的记录后，要将该记录的索引中的 next-key lock 会退化成「间隙锁」？</p><p>原因就是<code>在唯一索引等值查询并且查询记录不存在的场景下，仅靠间隙锁就能避免幻读</code>的问题。</p><ul><li>为什么 id = 5 记录上的主键索引的锁不可以是 next-key lock？如果是 next-key lock，就意味着其他事务无法删除 id = 5 这条记录，但是这次的案例是查询 id = 2 的记录，只要保证前后两次查询 id = 2 的结果集相同，就能避免幻读的问题了，所以即使 id =5被删除，也不会有什么影响，那就没必须加 next-key lock，因此只需要在 id = 5 加间隙锁，避免其他事务插入 id = 2 的新记录就行了。</li><li>为什么不可以针对不存在的记录加记录锁？锁是加在索引上的，而这个场景下查询的记录是不存在的，自然就没办法锁住这条不存在的记录。</li></ul></blockquote><p><code>唯一索引范围查询</code></p><p>当唯一索引进行范围查询时，会<code>对每一个扫描到的索引加 next-key 锁</code>，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁：</p><ul><li><p>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会退化成记录锁。</p><p><strong>实验一</strong>：针对「大于」的范围查询的情况</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">15</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">15</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>加锁变化过程如下：</p></blockquote></li></ul><blockquote><p>1.最开始要找的第一行是 id = 20，由于查询该记录不是一个等值查询（不是大于等于条件查询），所以对该主键索引加的是范围为 (15, 20] 的 next-key 锁；</p><p>2.由于是范围查找，就会继续往后找存在的记录，虽然我们看见表中最后一条记录是 id =20 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该主键索引加的是范围为 (20, +∞] 的 next-key锁。</p><p>3.停止扫描。</p><p>可以得知，事务 在主键索引上加了两个 X 型 的 next-key 锁：</p><ul><li>在 id = 20 这条记录的主键索引上，加了范围为 (15, 20] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。</li><li>在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞] 的next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。</li></ul></blockquote><p><strong>实验二</strong>：针对「大于等于」的范围查询的情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">15</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">15</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>事务 加锁变化过程如下：</p><p>1.最开始要找的第一行是 id = 15，由于查询该记录是一个等值查询（等于 15），所以该主键索引的 next-key 锁会退化成记录锁，也就是仅锁住 id = 15 这一行记录。</p><p>2.由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 20，于是对该主键索引加的是范围为 (15, 20] 的 next-key 锁；</p><p>3.接着扫描到第三行的时候，扫描到了特殊记录（ supremum pseudo-record），于是对该主键索引加的是范围为 (20, +∞] 的 next-key 锁。</p><p>4.停止扫描。</p></blockquote><ul><li><p>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：</p><ul><li><p>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</p><p><strong>实验一</strong>：针对「小于」的范围查询时，查询条件值的记录「不存在」表中的情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">6</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>事务 加锁变化过程如下：</p></blockquote></li></ul></li></ul><blockquote><p>1.最开始要找的第一行是 id = 1，于是对该主键索引加的是范围为 (-∞, 1] 的 next-key锁；</p><p>2.由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，所以对该主键索引加的是范围为 (1, 5] 的 next-key 锁；</p><p>3.由于扫描到的第二行记录（id = 5），满足 id &lt; 6 条件，而且也没有达到终止扫描的条件，接着会继续扫描。</p><p>4.扫描到的第三行是 id = 10，该记录不满足 id &lt; 6 条件的记录，所以 id = 10 这一行记录的锁会<code>退化成间隙锁</code>，于是对该主键索引加的是范围为 (5, 10) 的间隙锁。</p><p>5.由于扫描到的第三行记录（id = 10），不满足 id &lt; 6 条件，达到了终止扫描的条件，于是停止扫描</p></blockquote><pre><code>&gt;事务  在主键索引上加了三个 X 型的锁:
</code></pre><blockquote><p>1.在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录</p><p>2.在 id = 5 这条记录的主键索引上，加了范围为 (1, 5] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。</p><p>3.在 id = 10 这条记录的主键索引上，加了范围为 (5, 10) 的间隙锁，意味着其他事务无法插入 id 值为 6、7、8、9 的这一些新记录。</p></blockquote><ul><li><p>当条件值的记录在表中，如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁</p><p><strong>实验二</strong>：针对「小于等于」的范围查询时，查询条件值的记录「存在」表中的情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>事务 加锁变化过程如下：</p></blockquote></li></ul><blockquote><ol><li>最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；</li><li>由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，于是对该记录加的是范围为 (1, 5] 的 next-key 锁。</li><li>由于主键索引具有唯一性，不会存在两个 id = 5 的记录，所以不会再继续扫描，于是停止扫描。</li></ol></blockquote><pre><code>**实验三**：再来看针对「小于」的范围查询时，查询条件值的记录「存在」表中的情况。
  
```sql
</code></pre><p>begin; select * from user where id &lt; 5 for update;</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">  </span></span>
<span class="line"><span style="color:#e1e4e8;">  &gt;事务 加锁变化过程如下：</span></span>
<span class="line"><span style="color:#e1e4e8;">&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">  &gt;1. 最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；</span></span>
<span class="line"><span style="color:#e1e4e8;">&gt;2. 由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，该记录是第一条不满足 id &lt; 5 条件的记录，于是**该记录的锁会退化为间隙锁，锁范围是(1,5)**。</span></span>
<span class="line"><span style="color:#e1e4e8;">  &gt;3. 由于找到了第一条不满足 id &lt; 5 条件的记录，于是停止扫描。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">`非唯一索引等值查询`</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">用非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">- 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key</span></span>
<span class="line"><span style="color:#e1e4e8;">锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。</span></span>
<span class="line"><span style="color:#e1e4e8;">- 当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">**实验一**：针对非唯一索引等值查询时，查询的值不存在的情况</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">​```sql</span></span>
<span class="line"><span style="color:#e1e4e8;"># 假设事务对非唯一索引（age）进行了等值查询，且表中不存在 age = 25 的记录。</span></span>
<span class="line"><span style="color:#e1e4e8;">begin;</span></span>
<span class="line"><span style="color:#e1e4e8;">select * from user where age = 25 for update;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">  </span></span>
<span class="line"><span style="color:#24292e;">  &gt;事务 加锁变化过程如下：</span></span>
<span class="line"><span style="color:#24292e;">&gt;</span></span>
<span class="line"><span style="color:#24292e;">  &gt;1. 最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；</span></span>
<span class="line"><span style="color:#24292e;">&gt;2. 由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，该记录是第一条不满足 id &lt; 5 条件的记录，于是**该记录的锁会退化为间隙锁，锁范围是(1,5)**。</span></span>
<span class="line"><span style="color:#24292e;">  &gt;3. 由于找到了第一条不满足 id &lt; 5 条件的记录，于是停止扫描。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">`非唯一索引等值查询`</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">用非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">- 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key</span></span>
<span class="line"><span style="color:#24292e;">锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。</span></span>
<span class="line"><span style="color:#24292e;">- 当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">**实验一**：针对非唯一索引等值查询时，查询的值不存在的情况</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">​```sql</span></span>
<span class="line"><span style="color:#24292e;"># 假设事务对非唯一索引（age）进行了等值查询，且表中不存在 age = 25 的记录。</span></span>
<span class="line"><span style="color:#24292e;">begin;</span></span>
<span class="line"><span style="color:#24292e;">select * from user where age = 25 for update;</span></span></code></pre></div><blockquote><p>事务 A 加锁变化过程如下： 1.定位到第一条不符合查询条件的二级索引记录，即扫描到 age = 29，于是<strong>该二级索引的 next-key 锁会退化成间隙锁，范围是 (19,29 )</strong>。</p><p>2.停止查询</p></blockquote><blockquote><p>当有一个事务持有二级索引的间隙锁 (19, 29) 时，什么情况下，可以让其他事务的插入age = 19 或者 age = 29 记录的语句成功？又是什么情况下，插入 age = 19 或者 age = 29 记录时的语句会被阻塞？</p><p><strong>插入语句在插入一条记录之前，需要先定位到该记录在 B+树 的位置，如果插入的位置的下一条记录的索引上有间隙锁，才会发生阻塞。</strong></p><p><code>二级索引树是按照二级索引值（age列）按顺序存放的，在相同的二级索引值情况下， 再按主键 id 的顺序存放。知道了这个前提，我们才能知道执行插入语句的时候，插入的位置的下一条记录是谁。</code></p><p>当有一个事务持有二级索引的间隙锁 (19, 29) 时，插入 age = 19 或者 age = 29记录的语句是否可以执行成功，关键还要考虑插入记录的主键值，因为「二级索引值（age列）+主键值（id列）」才可以确定插入的位置，确定了插入位置后，就要<code>看插入的位置的下一条记录是否有间隙锁，如果有间隙锁，就会发生阻塞，如果没有间隙锁，则可以插入成功</code>。</p></blockquote><blockquote><p>LOCK_DATA：29，10 解释:</p><ul><li>LOCK_DATA 第一个数值，也就是 29， 它代表的是 age 值。LOCK_DATA 第一个数值是 next-key 锁和间隙锁锁住的范围的右边界值。</li><li>LOCK_DATA 第二个数值，也就是 10， 它代表的是 id 值。</li></ul><p>之所以 LOCK_DATA 要多显示一个数值（ID值），是因为针对「当某个事务持有非唯一索引的 (19, 29 ) 间隙锁的时候，其他事务是否可以插入 age = 29 新记录」的问题，还需要考虑插入记录的 id 值。而 <code>LOCK_DATA 的第二个数值，就是说明在插入 age = 29 新记录时，哪些范围的 id 值是不可以插入的</code>。</p><p>LOCK_DATA：29，10 + LOCK_MODE : X, GAP 解读:</p><p>事务 在 age = 29 记录的二级索引上（INDEX_NAME: index_age ），加了 age 值范围为 (19, 29) 的 X 型间隙锁，同时<code>针对其他事务插入 age 值为 29 的新记录时，不允许插入的新记录的 id 值小于 10</code>,如果插入的新记录的 id 值大于 20，则可以插入成功。</p></blockquote><p><strong>实验二</strong>：针对非唯一索引等值查询时，查询的值存在的情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 假设事务 A 对非唯一索引（age）进行了等值查询，且表中存在 age </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">22</span><span style="color:#E1E4E8;"> 的记录</span></span>
<span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> age </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">22</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 假设事务 A 对非唯一索引（age）进行了等值查询，且表中存在 age </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">22</span><span style="color:#24292E;"> 的记录</span></span>
<span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> age </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">22</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>事务 加锁变化过程如下：</p><p>1.由于不是唯一索引，所以肯定存在值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，最开始要找的第一行是 age = 22，于是对该二级索引记录加上范围为(19, 22] 的 next-key 锁。同时，因为 age = 22 符合查询条件，于是对 age = 22 的记录的主键索引加上记录锁，即对 id = 20 这一行加记录锁。</p><p>2.接着继续扫描，扫描到的第二行是 age = 29，该记录是第一个不符合条件的二级索引记 录，所以该二级索引的 next-key 锁会退化成间隙锁，范围是 (22, 29)。</p><p>3.停止查询。</p></blockquote><blockquote><p>从上图的分析，可以看到，事务 A 对二级索引（INDEX_NAME: index_age ）加了两个 X 型锁</p></blockquote><p><code>非唯一索引范围查询</code></p><p>非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于<code>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁</code>。</p><p><code>没有加索引的查询</code></p><p>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，<code>每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表</code>，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</p><p>update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。</p><h3 id="_1-7、分库分表" tabindex="-1">1.7、分库分表 <a class="header-anchor" href="#_1-7、分库分表" aria-label="Permalink to &quot;1.7、分库分表&quot;">​</a></h3><blockquote><p>分库分表包括分库和分表两个部分，通常包括：垂直分库、水平分库、垂直分表、水平分表四种方式。</p></blockquote><h4 id="垂直分表" tabindex="-1">垂直分表 <a class="header-anchor" href="#垂直分表" aria-label="Permalink to &quot;垂直分表&quot;">​</a></h4><blockquote><p>定义：将一个表按照字段分成多表，每个表存储其中一部分字段。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">它带来的提升是：</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">.为了避免IO争抢并减少锁表的几率</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">.充分发挥热门数据的操作效率</span></span>
<span class="line"><span style="color:#E1E4E8;">一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的商品描述。所以，当表数据量很大时，可以将表按字段切开，将热门字段、冷门字段分开放置在不同库中，这些库可以放在不同的存储设备上，避免IO争抢。垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">通常我们按以下原则进行垂直拆分:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">. 把不常用的字段单独放在一张表;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">. 把text，blob等大字段拆分出来放在附表中;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">. 经常组合查询的列放在一张表中;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">它带来的提升是：</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">.为了避免IO争抢并减少锁表的几率</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">.充分发挥热门数据的操作效率</span></span>
<span class="line"><span style="color:#24292E;">一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的商品描述。所以，当表数据量很大时，可以将表按字段切开，将热门字段、冷门字段分开放置在不同库中，这些库可以放在不同的存储设备上，避免IO争抢。垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">通常我们按以下原则进行垂直拆分:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">. 把不常用的字段单独放在一张表;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">. 把text，blob等大字段拆分出来放在附表中;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">. 经常组合查询的列放在一张表中;</span></span></code></pre></div></blockquote><h4 id="垂直分库" tabindex="-1">垂直分库 <a class="header-anchor" href="#垂直分库" aria-label="Permalink to &quot;垂直分库&quot;">​</a></h4><blockquote><p>定义：垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">它带来的提升是：</span></span>
<span class="line"><span style="color:#E1E4E8;">   解决业务层面的耦合，业务清晰</span></span>
<span class="line"><span style="color:#E1E4E8;">   能对不同业务的数据进行分级管理、维护、监控、扩展等</span></span>
<span class="line"><span style="color:#E1E4E8;">   高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈</span></span>
<span class="line"><span style="color:#E1E4E8;">垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">它带来的提升是：</span></span>
<span class="line"><span style="color:#24292E;">   解决业务层面的耦合，业务清晰</span></span>
<span class="line"><span style="color:#24292E;">   能对不同业务的数据进行分级管理、维护、监控、扩展等</span></span>
<span class="line"><span style="color:#24292E;">   高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈</span></span>
<span class="line"><span style="color:#24292E;">垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题</span></span></code></pre></div></blockquote><h4 id="水平分库" tabindex="-1">水平分库 <a class="header-anchor" href="#水平分库" aria-label="Permalink to &quot;水平分库&quot;">​</a></h4><blockquote><p>定义：水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">它带来的提升是：</span></span>
<span class="line"><span style="color:#E1E4E8;">   解决了单库大数据，高并发的性能瓶颈</span></span>
<span class="line"><span style="color:#E1E4E8;">   提高了系统的稳定性及可用性</span></span>
<span class="line"><span style="color:#E1E4E8;">当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平分库了，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但由于同一个表被分配在不同的数据库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">它带来的提升是：</span></span>
<span class="line"><span style="color:#24292E;">   解决了单库大数据，高并发的性能瓶颈</span></span>
<span class="line"><span style="color:#24292E;">   提高了系统的稳定性及可用性</span></span>
<span class="line"><span style="color:#24292E;">当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平分库了，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但由于同一个表被分配在不同的数据库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度</span></span></code></pre></div></blockquote><h4 id="水平分表" tabindex="-1">水平分表 <a class="header-anchor" href="#水平分表" aria-label="Permalink to &quot;水平分表&quot;">​</a></h4><blockquote><p>定义：水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">它带来的提升是：</span></span>
<span class="line"><span style="color:#E1E4E8;">优化单一表数据量过大而产生的性能问题</span></span>
<span class="line"><span style="color:#E1E4E8;">避免IO争抢并减少锁表的几率库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，使得单个表的数据量变小，提高检索性能。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">它带来的提升是：</span></span>
<span class="line"><span style="color:#24292E;">优化单一表数据量过大而产生的性能问题</span></span>
<span class="line"><span style="color:#24292E;">避免IO争抢并减少锁表的几率库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，使得单个表的数据量变小，提高检索性能。</span></span></code></pre></div></blockquote><h4 id="sharding-策略" tabindex="-1">Sharding 策略 <a class="header-anchor" href="#sharding-策略" aria-label="Permalink to &quot;Sharding 策略&quot;">​</a></h4><ul><li>哈希取模：hash(key)%N</li><li>范围：可以是 ID 范围也可以是时间范围</li><li>映射表：使用单独的一个数据库来存储映射关系</li></ul><h4 id="分库分表带来的问题" tabindex="-1">分库分表带来的问题 <a class="header-anchor" href="#分库分表带来的问题" aria-label="Permalink to &quot;分库分表带来的问题&quot;">​</a></h4><blockquote><p>事务一致性问题 - 分布式事务解决方案</p><p>跨节点关联查询 - 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><p>跨节点分页、排序函数</p><p>主键避重 - 单独设计全局主键，避免跨库主键重复问题</p><ul><li>使用全局唯一 ID （GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器（如 Twitter 的 Snowflake 算法）</li></ul><p>公共表</p></blockquote><h3 id="_1-8、主从复制" tabindex="-1">1.8、主从复制 <a class="header-anchor" href="#_1-8、主从复制" aria-label="Permalink to &quot;1.8、主从复制&quot;">​</a></h3><blockquote><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。</p></blockquote><h4 id="主从复制原理" tabindex="-1">主从复制原理 <a class="header-anchor" href="#主从复制原理" aria-label="Permalink to &quot;主从复制原理&quot;">​</a></h4><blockquote><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li>I/O 线程 ：负责从主服务器上读取- 二进制日志，并写入从服务器的中继日志（Relay log）。</li><li>SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627087.png" alt="image-20220319124728758"></p><ul><li>sql主库在事务提交时会把数据变更作为事件记录在二进制日志Binlog中；</li><li>主库推送二进制日志文件Binlog中的事件到从库的中继日志Relay Log中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；</li><li>sql通过三个线程来完成主从库间的数据复制，其中Binlog Dump线程跑在主库上，I/O线程和SQL线程跑着从库上；</li><li>当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I/O线程，I/O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用，如下图所示。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627022.png" alt="image-20220319130219491"></p></blockquote><h4 id="实例搭建" tabindex="-1">实例搭建 <a class="header-anchor" href="#实例搭建" aria-label="Permalink to &quot;实例搭建&quot;">​</a></h4><h5 id="主实例搭建" tabindex="-1">主实例搭建 <a class="header-anchor" href="#主实例搭建" aria-label="Permalink to &quot;主实例搭建&quot;">​</a></h5><ul><li>运行sql主实例：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker run -p 3307:3306 --name sql-master \</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-master/log:/var/log/sql \</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-master/data:/var/lib/sql \</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-master/conf:/etc/sql \</span></span>
<span class="line"><span style="color:#e1e4e8;">-e sql_ROOT_PASSWORD=root  \</span></span>
<span class="line"><span style="color:#e1e4e8;">-d sql:5.7</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker run -p 3307:3306 --name sql-master \</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-master/log:/var/log/sql \</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-master/data:/var/lib/sql \</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-master/conf:/etc/sql \</span></span>
<span class="line"><span style="color:#24292e;">-e sql_ROOT_PASSWORD=root  \</span></span>
<span class="line"><span style="color:#24292e;">-d sql:5.7</span></span></code></pre></div><ul><li>在sql的配置文件夹<code>/mydata/sql-master/conf</code>中创建一个配置文件<code>my.cnf</code>：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">touch my.cnf</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">touch my.cnf</span></span></code></pre></div><ul><li>修改配置文件my.cnf，配置信息如下：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">[sqld]</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#e1e4e8;">server_id=101</span></span>
<span class="line"><span style="color:#e1e4e8;">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog-ignore-db=sql</span></span>
<span class="line"><span style="color:#e1e4e8;">## 开启二进制日志功能</span></span>
<span class="line"><span style="color:#e1e4e8;">log-bin=mall-sql-bin</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog_cache_size=1M</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog_format=mixed</span></span>
<span class="line"><span style="color:#e1e4e8;">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span>
<span class="line"><span style="color:#e1e4e8;">expire_logs_days=7</span></span>
<span class="line"><span style="color:#e1e4e8;">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span>
<span class="line"><span style="color:#e1e4e8;">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#e1e4e8;">slave_skip_errors=1062</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">[sqld]</span></span>
<span class="line"><span style="color:#24292e;">## 设置server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#24292e;">server_id=101</span></span>
<span class="line"><span style="color:#24292e;">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#24292e;">binlog-ignore-db=sql</span></span>
<span class="line"><span style="color:#24292e;">## 开启二进制日志功能</span></span>
<span class="line"><span style="color:#24292e;">log-bin=mall-sql-bin</span></span>
<span class="line"><span style="color:#24292e;">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#24292e;">binlog_cache_size=1M</span></span>
<span class="line"><span style="color:#24292e;">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#24292e;">binlog_format=mixed</span></span>
<span class="line"><span style="color:#24292e;">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span>
<span class="line"><span style="color:#24292e;">expire_logs_days=7</span></span>
<span class="line"><span style="color:#24292e;">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span>
<span class="line"><span style="color:#24292e;">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#24292e;">slave_skip_errors=1062</span></span></code></pre></div><ul><li>修改完配置后重启实例：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker restart sql-master</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker restart sql-master</span></span></code></pre></div><ul><li>进入<code>sql-master</code>容器中：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker exec -it sql-master /bin/bash</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker exec -it sql-master /bin/bash</span></span></code></pre></div><ul><li>在容器中使用sql的登录命令连接到客户端：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql -uroot -proot</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql -uroot -proot</span></span></code></pre></div><ul><li>创建数据同步用户：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span></span>
<span class="line"><span style="color:#e1e4e8;">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;slave&#39;@&#39;%&#39;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span></span>
<span class="line"><span style="color:#24292e;">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;slave&#39;@&#39;%&#39;;</span></span></code></pre></div><h5 id="从实例搭建" tabindex="-1">从实例搭建 <a class="header-anchor" href="#从实例搭建" aria-label="Permalink to &quot;从实例搭建&quot;">​</a></h5><ul><li>运行sql从实例：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker run -p 3308:3306 --name sql-slave \</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-slave/log:/var/log/sql \</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-slave/data:/var/lib/sql \</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-slave/conf:/etc/sql \</span></span>
<span class="line"><span style="color:#e1e4e8;">-e sql_ROOT_PASSWORD=root  \</span></span>
<span class="line"><span style="color:#e1e4e8;">-d sql:5.7</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker run -p 3308:3306 --name sql-slave \</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-slave/log:/var/log/sql \</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-slave/data:/var/lib/sql \</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-slave/conf:/etc/sql \</span></span>
<span class="line"><span style="color:#24292e;">-e sql_ROOT_PASSWORD=root  \</span></span>
<span class="line"><span style="color:#24292e;">-d sql:5.7</span></span></code></pre></div><ul><li>在sql的配置文件夹<code>/mydata/sql-slave/conf</code>中创建一个配置文件<code>my.cnf</code>：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">touch my.cnf</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">touch my.cnf</span></span></code></pre></div><ul><li>修改配置文件my.cnf：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">[sqld]</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#e1e4e8;">server_id=102</span></span>
<span class="line"><span style="color:#e1e4e8;">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog-ignore-db=sql</span></span>
<span class="line"><span style="color:#e1e4e8;">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span>
<span class="line"><span style="color:#e1e4e8;">log-bin=mall-sql-slave1-bin</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog_cache_size=1M</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog_format=mixed</span></span>
<span class="line"><span style="color:#e1e4e8;">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span>
<span class="line"><span style="color:#e1e4e8;">expire_logs_days=7</span></span>
<span class="line"><span style="color:#e1e4e8;">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span>
<span class="line"><span style="color:#e1e4e8;">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#e1e4e8;">slave_skip_errors=1062</span></span>
<span class="line"><span style="color:#e1e4e8;">## relay_log配置中继日志</span></span>
<span class="line"><span style="color:#e1e4e8;">relay_log=mall-sql-relay-bin</span></span>
<span class="line"><span style="color:#e1e4e8;">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span>
<span class="line"><span style="color:#e1e4e8;">log_slave_updates=1</span></span>
<span class="line"><span style="color:#e1e4e8;">## slave设置为只读（具有super权限的用户除外）</span></span>
<span class="line"><span style="color:#e1e4e8;">read_only=1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">[sqld]</span></span>
<span class="line"><span style="color:#24292e;">## 设置server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#24292e;">server_id=102</span></span>
<span class="line"><span style="color:#24292e;">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#24292e;">binlog-ignore-db=sql</span></span>
<span class="line"><span style="color:#24292e;">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span>
<span class="line"><span style="color:#24292e;">log-bin=mall-sql-slave1-bin</span></span>
<span class="line"><span style="color:#24292e;">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#24292e;">binlog_cache_size=1M</span></span>
<span class="line"><span style="color:#24292e;">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#24292e;">binlog_format=mixed</span></span>
<span class="line"><span style="color:#24292e;">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span>
<span class="line"><span style="color:#24292e;">expire_logs_days=7</span></span>
<span class="line"><span style="color:#24292e;">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span>
<span class="line"><span style="color:#24292e;">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#24292e;">slave_skip_errors=1062</span></span>
<span class="line"><span style="color:#24292e;">## relay_log配置中继日志</span></span>
<span class="line"><span style="color:#24292e;">relay_log=mall-sql-relay-bin</span></span>
<span class="line"><span style="color:#24292e;">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span>
<span class="line"><span style="color:#24292e;">log_slave_updates=1</span></span>
<span class="line"><span style="color:#24292e;">## slave设置为只读（具有super权限的用户除外）</span></span>
<span class="line"><span style="color:#24292e;">read_only=1</span></span></code></pre></div><ul><li>修改完配置后重启实例：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker restart sql-slave</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker restart sql-slave</span></span></code></pre></div><h5 id="主从连接" tabindex="-1">主从连接 <a class="header-anchor" href="#主从连接" aria-label="Permalink to &quot;主从连接&quot;">​</a></h5><ul><li>连接到主数据库的sql客户端，查看主数据库状态：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">show master status;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">show master status;</span></span></code></pre></div><ul><li>主数据库状态显示如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627221.png" alt="图片"></p><ul><li>进入<code>sql-slave</code>容器中：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker exec -it sql-slave /bin/bash</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker exec -it sql-slave /bin/bash</span></span></code></pre></div><ul><li>在容器中使用sql的登录命令连接到客户端：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql -uroot -proot</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql -uroot -proot</span></span></code></pre></div><ul><li>在从数据库中配置主从复制：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">change master to master_host=&#39;192.168.6.132&#39;, master_user=&#39;slave&#39;, master_password=&#39;123456&#39;, master_port=3307, master_log_file=&#39;mall-sql-bin.000001&#39;, master_log_pos=617, master_connect_retry=30;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">change master to master_host=&#39;192.168.6.132&#39;, master_user=&#39;slave&#39;, master_password=&#39;123456&#39;, master_port=3307, master_log_file=&#39;mall-sql-bin.000001&#39;, master_log_pos=617, master_connect_retry=30;</span></span></code></pre></div><ul><li><p>主从复制命令参数说明：</p></li><li><ul><li>master_host：主数据库的IP地址；</li><li>master_port：主数据库的运行端口；</li><li>master_user：在主数据库创建的用于同步数据的用户账号；</li><li>master_password：在主数据库创建的用于同步数据的用户密码；</li><li>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</li><li>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</li><li>master_connect_retry：连接失败重试的时间间隔，单位为秒。</li></ul></li><li><p>查看主从同步状态：</p></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">show slave status \G;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">show slave status \G;</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627909.jpeg" alt="图片"></p><ul><li>开启主从同步：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">start slave;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">start slave;</span></span></code></pre></div><ul><li>查看从数据库状态发现已经同步：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627581.png" alt="图片"></p><h5 id="主从复制测试" tabindex="-1">主从复制测试 <a class="header-anchor" href="#主从复制测试" aria-label="Permalink to &quot;主从复制测试&quot;">​</a></h5><blockquote><p>主从复制的测试方法有很多，可以在主实例中创建一个数据库，看看从实例中是否有该数据库，如果有，表示主从复制已经搭建成功。</p></blockquote><h3 id="_1-9、读写分离" tabindex="-1">1.9、读写分离 <a class="header-anchor" href="#_1-9、读写分离" aria-label="Permalink to &quot;1.9、读写分离&quot;">​</a></h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627486.png" alt="image-20220319124748987"></p></div></div></main><footer class="VPDocFooter" data-v-6b87e69f data-v-ef5dee53><!--[--><!--]--><!----><nav class="prev-next" data-v-ef5dee53><div class="pager" data-v-ef5dee53><!----></div><div class="pager" data-v-ef5dee53><a class="pager-link next" href="/database/mysql.html" data-v-ef5dee53><span class="desc" data-v-ef5dee53>Next page</span><span class="title" data-v-ef5dee53>1.MySQL</span></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"6f439892\",\"ai_ai学习路线.md\":\"f1ec74ab\",\"中间件_framework_alibaba_alibaba.md\":\"4f0e6d97\",\"中间件_framework_alibaba_nacos.md\":\"0b1681bd\",\"中间件_framework_alibaba_zookeeper.md\":\"fbbd27f1\",\"中间件_framework_alibaba_dubbo.md\":\"2df2211e\",\"中间件_framework_springcloud_springcloud.md\":\"03463651\",\"中间件_framework_springcloud_springcloudstream.md\":\"63c1344c\",\"中间件_开源中间件_权限框架_satoken.md\":\"82d07115\",\"中间件_开源中间件_工作流_flowable.md\":\"686aa25a\",\"中间件_开源中间件_工作流_compileflow.md\":\"43146eb6\",\"中间件_数据库中间件_db_oracle_oracle.md\":\"4d7b792d\",\"中间件_开源中间件_工作流_liteflow.md\":\"8412d254\",\"中间件_数据库中间件_db_postgresql_postgresql.md\":\"88a1d8bf\",\"java_java响应式编程.md\":\"60d43578\",\"中间件_开源中间件_权限框架_权限设计概述.md\":\"69e4316e\",\"中间件_framework_springcloud_springcloudgateway.md\":\"e0dc1db5\",\"中间件_搜索中间件_elasticsearch.md\":\"60893209\",\"中间件_开源中间件_分布式任务_xxljob.md\":\"6d08f1d3\",\"中间件_消息中间件_kafka.md\":\"5258044d\",\"中间件_开源中间件_权限框架_oauth2.md\":\"97f35c6c\",\"中间件_缓存中间件_memcached.md\":\"94b870fc\",\"大数据_k8s_k8s.md\":\"77596fd1\",\"大数据_大数据学习路线.md\":\"2721a489\",\"中间件_缓存中间件_redisson.md\":\"2d8dc88b\",\"系统设计_日志系统设计.md\":\"effd107d\",\"系统设计_如何做好架构设计.md\":\"1ef7446a\",\"系统设计_分布式事务设计.md\":\"17fbe2de\",\"中间件_数据库中间件_db_mongodb_mongodb.md\":\"078ae00b\",\"java_jvm_jvm调优.md\":\"7b9c74c4\",\"系统设计_多级缓存架构设计.md\":\"b77ff776\",\"中间件_framework_springcloud_hystrix.md\":\"6cd873f0\",\"中间件_framework_alibaba_sentinel.md\":\"a9921067\",\"中间件_framework_springcloud_openfeign.md\":\"62dd65b9\",\"生产问题记录_20230721q1.md\":\"c050ca0b\",\"生产问题记录_20230621q1.md\":\"a46f91f6\",\"更新日志_index.md\":\"6995e49d\",\"中间件_开源中间件_服务器_nginx.md\":\"260829eb\",\"系统设计_分布式id设计.md\":\"43ad86c5\",\"规范_数据库设计规范.md\":\"199aeedd\",\"系统设计_秒杀系统设计.md\":\"00e3d327\",\"中间件_数据库中间件_orm_mybatis.md\":\"a56cfde7\",\"规范_redis规范.md\":\"fe15cf46\",\"规范_mysql规范.md\":\"bd2056fb\",\"中间件_缓存中间件_redis.md\":\"8fc571ca\",\"生产问题记录_20230519q1.md\":\"bfd131eb\",\"中间件_数据库中间件_分库分表_shardingjdbc.md\":\"d8f755bf\",\"中间件_开源中间件_分布式任务_powerjob.md\":\"57cd6469\",\"大数据_数仓分层.md\":\"0d71c195\",\"中间件_framework_springboot_springboot.md\":\"1019a3d9\",\"中间件_数据库中间件_db_tidb_tidb.md\":\"505028c3\",\"系统设计_订单系统设计.md\":\"727c95eb\",\"中间件_数据库中间件_连接池_druid.md\":\"0e8879af\",\"系统设计_灰度架构设计.md\":\"32144397\",\"中间件_开源中间件_服务器_openresty.md\":\"c2417e21\",\"中间件_开源中间件_工作流_工作流概述.md\":\"9f413cc4\",\"中间件_消息中间件_rabbitmq.md\":\"3c38ad78\",\"知识速查库_linux常用命令.md\":\"3c0c4a4d\",\"知识速查库_常用docker镜像.md\":\"94798ce6\",\"中间件_消息中间件_rocketmq.md\":\"8eea5013\",\"中间件_framework_alibaba_seata.md\":\"4ee2df9b\",\"生产性能优化_20230802q1.md\":\"f63f8d81\",\"中间件_数据库中间件_orm_mybatisplus.md\":\"a19b5464\",\"中间件_数据库中间件_etl_canal.md\":\"4e86dba0\",\"中间件_开源中间件_服务器_netty.md\":\"61c5de9b\",\"java_java新特性.md\":\"bfa8ee68\",\"生产问题记录_20231020q1.md\":\"2499452f\",\"生产问题记录_index.md\":\"27c548b7\",\"中间件_消息中间件_pulsar.md\":\"37bffa09\",\"中间件_数据库中间件_db_mysql_mysql.md\":\"1bf51dc8\",\"知识速查库_日常开发小结.md\":\"1d724ad2\",\"系统设计_mysql-es数据初始化同步方案.md\":\"8876aa47\",\"java_jvm_jvm基础.md\":\"077e3511\",\"工具集_index.md\":\"a173c3f5\",\"中间件_framework_spring_spring.md\":\"172aff25\",\"java_java基础.md\":\"0263fc29\",\"java_juc_java多线程.md\":\"650d940f\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"某不知名小开发\",\"description\":\"在线文档\",\"base\":\"/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"siteTitle\":\"伟酱\",\"logo\":\"/logo.png\",\"nav\":[{\"text\":\"更新日志\",\"link\":\"/更新日志/index\"},{\"text\":\"经验\",\"items\":[{\"text\":\"生产问题记录\",\"link\":\"/生产问题记录/index\"},{\"text\":\"生产性能优化\",\"link\":\"/生产性能优化/20230802q1\"},{\"text\":\"知识速查库\",\"link\":\"/知识速查库/日常开发小结\"},{\"text\":\"工具集\",\"link\":\"/工具集/index\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/liuxiaowei2018\"}],\"search\":{\"provider\":\"local\"},\"lastUpdated\":\"Last Updated\",\"smoothScroll\":true,\"sidebar\":{\"/java\":[{\"text\":\"Java SE\",\"collapsible\":true,\"items\":[{\"text\":\"Java基础\",\"link\":\"/java/java基础\"},{\"text\":\"Java新特性\",\"link\":\"/java/java新特性\"},{\"text\":\"Java响应式编程\",\"link\":\"/java/java响应式编程\"}]}],\"/java/juc\":[{\"text\":\"Java SE\",\"collapsible\":true,\"items\":[{\"text\":\"Java并发编程\",\"link\":\"/java/juc/java多线程\"}]}],\"/java/jvm\":[{\"text\":\"Java SE\",\"collapsible\":true,\"items\":[{\"text\":\"Jvm基础\",\"link\":\"/java/jvm/jvm基础\"},{\"text\":\"Jvm调优\",\"link\":\"/java/jvm/jvm调优\"}]}],\"/中间件/framework\":[{\"text\":\"常用开发框架\",\"collapsible\":true,\"items\":[{\"text\":\"spring\",\"link\":\"/中间件/framework/spring/spring\"},{\"text\":\"springBoot\",\"link\":\"/中间件/framework/springboot/springBoot\"}]}],\"/中间件/framework/springcloud\":[{\"text\":\"SpringCloud\",\"collapsible\":true,\"items\":[{\"text\":\"springCloudOpenFeign\",\"link\":\"/中间件/framework/springcloud/openFeign\"},{\"text\":\"springCloudHystrix\",\"link\":\"/中间件/framework/springcloud/hystrix\"},{\"text\":\"springCloudGateway\",\"link\":\"/中间件/framework/springcloud/springCloudGateway\"},{\"text\":\"springCloudStream\",\"link\":\"/中间件/framework/springcloud/springCloudStream\"}]}],\"/中间件/framework/alibaba\":[{\"text\":\"阿里中间件\",\"collapsible\":true,\"items\":[{\"text\":\"dubbo\",\"link\":\"/中间件/framework/alibaba/dubbo\"},{\"text\":\"nacos\",\"link\":\"/中间件/framework/alibaba/nacos\"},{\"text\":\"seata\",\"link\":\"/中间件/framework/alibaba/seata\"},{\"text\":\"sentinel\",\"link\":\"/中间件/framework/alibaba/sentinel\"},{\"text\":\"zookeeper\",\"link\":\"/中间件/framework/alibaba/zookeeper\"}]}],\"/中间件/数据库中间件\":[{\"text\":\"数据库中间件\",\"collapsible\":true,\"items\":[]}],\"/中间件/数据库中间件/db\":[{\"text\":\"数据库\",\"collapsible\":true,\"items\":[{\"text\":\"1.MySQL\",\"link\":\"/database/mysql\"},{\"text\":\"3.Oracle\",\"link\":\"/database/oracle\"},{\"text\":\"4.PostgreSQL\",\"link\":\"/database/postgreSQL\"},{\"text\":\"5.MongoDB\",\"link\":\"/database/mongoDB\"},{\"text\":\"6.TiDB\",\"link\":\"/database/tiDB\"}]}],\"/中间件/数据库中间件/orm\":[{\"text\":\"数据库中间件-orm框架\",\"collapsible\":true,\"items\":[{\"text\":\"mybatis\",\"link\":\"/中间件/数据库中间件/orm/mybatis\"},{\"text\":\"mybatisPlus\",\"link\":\"/中间件/数据库中间件/orm/mybatisPlus\"}]}],\"/中间件/数据库中间件/连接池\":[{\"text\":\"数据库中间件-连接池\",\"collapsible\":true,\"items\":[{\"text\":\"druid\",\"link\":\"/中间件/数据库中间件/连接池/druid\"}]}],\"/中间件/数据库中间件/分库分表\":[{\"text\":\"数据库中间件-连接池\",\"collapsible\":true,\"items\":[{\"text\":\"shardingJdbc\",\"link\":\"/中间件/数据库中间件/分库分表/shardingJdbc\"}]}],\"/中间件/数据库中间件/etl\":[{\"text\":\"数据库中间件-ETL\",\"collapsible\":true,\"items\":[{\"text\":\"canal\",\"link\":\"/中间件/数据库中间件/etl/canal\"}]}],\"/中间件/缓存中间件\":[{\"text\":\"缓存\",\"collapsible\":true,\"items\":[{\"text\":\"1.redis\",\"link\":\"/中间件/缓存中间件/redis\"},{\"text\":\"2.redisson\",\"link\":\"/中间件/缓存中间件/redisson\"},{\"text\":\"3.memcached\",\"link\":\"/中间件/缓存中间件/memcached\"}]}],\"/中间件/消息中间件\":[{\"text\":\"消息中间件\",\"collapsible\":true,\"items\":[{\"text\":\"rabbitMQ\",\"link\":\"/中间件/消息中间件/rabbitMQ\"},{\"text\":\"rocketMQ\",\"link\":\"/中间件/消息中间件/rocketMQ\"},{\"text\":\"kafka\",\"link\":\"/中间件/消息中间件/kafka\"},{\"text\":\"pulsar\",\"link\":\"/中间件/消息中间件/pulsar\"}]}],\"/中间件/搜索中间件\":[{\"text\":\"搜索中间件\",\"collapsible\":true,\"items\":[{\"text\":\"elasticsearch\",\"link\":\"/中间件/搜索中间件/elasticsearch\"}]}],\"/中间件/开源中间件/分布式任务\":[{\"text\":\"分布式任务\",\"collapsible\":true,\"items\":[{\"text\":\"xxlJob\",\"link\":\"/中间件/开源中间件/分布式任务/xxlJob\"},{\"text\":\"powerJob\",\"link\":\"/中间件/开源中间件/分布式任务/powerJob\"}]}],\"/中间件/开源中间件/工作流\":[{\"text\":\"工作流\",\"collapsible\":true,\"items\":[{\"text\":\"flowable\",\"link\":\"/中间件/开源中间件/工作流/flowable\"},{\"text\":\"compileflow\",\"link\":\"/中间件/开源中间件/工作流/compileflow\"},{\"text\":\"liteflow\",\"link\":\"/中间件/开源中间件/工作流/liteflow\"}]}],\"/中间件/开源中间件/权限框架\":[{\"text\":\"权限框架\",\"collapsible\":true,\"items\":[{\"text\":\"oauth2\",\"link\":\"/中间件/开源中间件/权限框架/oauth2\"},{\"text\":\"saToken\",\"link\":\"/中间件/开源中间件/权限框架/saToken\"}]}],\"/中间件/开源中间件/服务器\":[{\"text\":\"服务器\",\"collapsible\":true,\"items\":[{\"text\":\"nginx\",\"link\":\"/中间件/开源中间件/服务器/nginx\"},{\"text\":\"netty\",\"link\":\"/中间件/开源中间件/服务器/netty\"},{\"text\":\"openResty\",\"link\":\"/中间件/开源中间件/服务器/openresty\"}]}],\"/系统设计\":[{\"text\":\"系统设计\",\"collapsible\":true,\"items\":[{\"text\":\"1.如何做好架构设计\",\"link\":\"/系统设计/如何做好架构设计\"},{\"text\":\"2.分布式ID设计\",\"link\":\"/系统设计/分布式ID设计\"},{\"text\":\"3.多级缓存架构设计\",\"link\":\"/系统设计/多级缓存架构设计\"},{\"text\":\"4.日志系统设计\",\"link\":\"/系统设计/日志系统设计\"},{\"text\":\"5.分布式事务设计\",\"link\":\"/系统设计/分布式事务设计\"},{\"text\":\"6.灰度架构设计\",\"link\":\"/系统设计/灰度架构设计\"},{\"text\":\"7.秒杀系统设计\",\"link\":\"/系统设计/秒杀系统设计\"},{\"text\":\"8.订单系统设计\",\"link\":\"/系统设计/订单系统设计\"},{\"text\":\"9.Mysql-ES数据初始化同步方案\",\"link\":\"/系统设计/Mysql-ES数据初始化同步方案\"}]}],\"/生产问题记录\":[{\"text\":\"生产问题记录\",\"collapsible\":true,\"items\":[{\"text\":\"1.如何排查线上问题\",\"link\":\"/生产问题记录/index\"},{\"text\":\"2.线上服务器端口故障问题记录\",\"link\":\"/生产问题记录/20230519q1\"},{\"text\":\"3.线上pod 反复重启问题记录\",\"link\":\"/生产问题记录/20230621q1\"},{\"text\":\"4.线上pod OMM问题记录\",\"link\":\"/生产问题记录/20230721q1\"},{\"text\":\"5.线上pod 死锁问题记录\",\"link\":\"/生产问题记录/20231020q1\"}]}],\"/生产性能优化\":[{\"text\":\"生产性能优化\",\"collapsible\":true,\"items\":[{\"text\":\"接口性能优化1-2023.08.02\",\"link\":\"/生产性能优化/20230802q1\"}]}],\"/知识速查库\":[{\"text\":\"知识速查库\",\"collapsible\":true,\"items\":[{\"text\":\"1.日常开发小结\",\"link\":\"/知识速查库/日常开发小结\"},{\"text\":\"2.linux常用命令\",\"link\":\"/知识速查库/linux常用命令\"},{\"text\":\"3.常用docker镜像\",\"link\":\"/知识速查库/常用docker镜像\"}]}]}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}");</script>
    
  </body>
</html>