import{_ as n,o as l,c as p,Q as a,k as s}from"./chunks/framework.8048b864.js";const b=JSON.parse('{"title":"并发编程-多线程基础","description":"","frontmatter":{},"headers":[],"relativePath":"java/juc/多线程基础.md","filePath":"java/juc/多线程基础.md","lastUpdated":1719210606000}'),o={name:"java/juc/多线程基础.md"},e=a('<h1 id="并发编程-多线程基础" tabindex="-1">并发编程-多线程基础 <a class="header-anchor" href="#并发编程-多线程基础" aria-label="Permalink to &quot;并发编程-多线程基础&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#创建线程">创建线程</a></li><li><a href="#线程状态">线程状态</a></li><li><a href="#线程常用方法">线程常用方法</a></li><li><a href="#cas">CAS</a><ul><li><a href="#aba问题及解决方案">ABA问题及解决方案</a></li></ul></li><li><a href="#fork-join框架">Fork/Join框架</a></li><li><a href="#jmm内存模型">JMM内存模型</a><ul><li><a href="#重排序原理">重排序原理</a></li><li><a href="#happens-before原则">happens-before原则</a></li></ul></li></ul></nav><h2 id="创建线程" tabindex="-1">创建线程 <a class="header-anchor" href="#创建线程" aria-label="Permalink to &quot;创建线程&quot;">​</a></h2><p>Java中创建线程主要有以下这几种方式：</p><ul><li>定义<code>Thread</code>类的子类，并重写该类的<code>run</code>方法</li><li>定义<code>Runnable</code>接口的实现类，并重写该接口的<code>run()</code>方法</li><li>定义<code>Callable</code>接口的实现类，并重写该接口的<code>call()</code>方法，一般配合<code>Future</code>使用</li><li><code>线程池</code></li></ul><h2 id="线程状态" tabindex="-1">线程状态 <a class="header-anchor" href="#线程状态" aria-label="Permalink to &quot;线程状态&quot;">​</a></h2><p>线程共有6种状态，分别是NEW（初始化）、RUNNABLE（可运行）、WAITING（等待）、TIMED_WAITING（超时等待）、BLOCKED（阻塞）、TERMINATED（终止）。</p><ul><li><p>NEW（初始化）</p><p>表示创建线程对象之后，还没有调用start方法。</p></li><li><p>RUNNABLE（可运行）</p><p>表示调用start方法之后，等待CPU调度。为了便于理解，通常又把RUNNABLE分别RUNNING（运行中）和READY（就绪）。处在RUNNING（运行中）状态的线程可以调用yield方法，让出CPU时间片，然后跟其他处于READY（就绪）一起等待被调度。</p></li><li><p>WAITING（等待）</p><p>处于RUNNABLE状态的线程调用wait方法之后，就处于等待状态，需要其他线程显示地唤醒。</p></li><li><p>TIMED_WAITING（超时等待）</p><p>处于RUNNABLE状态的线程调用wait(long)方法之后，就处于等待状态，需要其他线程显示地唤醒。</p></li><li><p>BLOCKED（阻塞）</p><p>等待进入synchronized方法/代码块，处于阻塞状态。</p></li><li><p>TERMINATED（终止）</p><p>表示线程已经执行结束。</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4f70edc2db14a36abc09aa2e0e4d2e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20221006232449786.png"></p><h2 id="线程常用方法" tabindex="-1">线程常用方法 <a class="header-anchor" href="#线程常用方法" aria-label="Permalink to &quot;线程常用方法&quot;">​</a></h2>',10),t=s("table",null,[s("thead",null,[s("tr",null,[s("th",null,"方法定义"),s("th",null,"含义"),s("th",null,"使用方式")])]),s("tbody",null,[s("tr",null,[s("td",{"……":""},"public synchronized void start()"),s("td",null,"启动线程"),s("td",null,"MyThread myThread = new MyThread(); myThread.start();")]),s("tr",null,[s("td",null,"public static native Thread currentThread();"),s("td",null,"获取当前线程实例对象"),s("td",null,"Thread thread = Thread.currentThread();")]),s("tr",null,[s("td",null,"public static native void yield();"),s("td",null,"让出CPU时间片"),s("td",null,"Thread.yield();")]),s("tr",null,[s("td",null,"public static native void sleep(long millis);"),s("td",null,"睡眠指定时间"),s("td",null,"Thread.sleep(1L);")]),s("tr",null,[s("td",{"……":""},"public void interrupt()"),s("td",null,"中断线程"),s("td",null,"MyThread myThread = new MyThread(); myThread.interrupt();")]),s("tr",null,[s("td",{"……":""},"public static boolean interrupted()"),s("td",null,"判断线程是否已中断"),s("td",null,"MyThread myThread = new MyThread(); boolean interrupted = myThread.isInterrupted();")]),s("tr",null,[s("td",null,"public final native boolean isAlive();"),s("td",null,"判断线程是否是存活状态"),s("td",null,"MyThread myThread = new MyThread(); boolean alive = myThread.isAlive();")]),s("tr",null,[s("td",{"……":""},"public final String getName()"),s("td",null,"获取线程名称"),s("td",null,"MyThread myThread = new MyThread(); String name = myThread.getName();")]),s("tr",null,[s("td",{"……":""},"public State getState()"),s("td",null,"获取线程状态"),s("td",null,"MyThread myThread = new MyThread(); Thread.State state = myThread.getState();")]),s("tr",null,[s("td",{"……":""},"public long getId()"),s("td",null,"获取线程ID"),s("td",null,"MyThread myThread = new MyThread(); long id = myThread.getId();")]),s("tr",null,[s("td",{"……":""},"public final void join()"),s("td",null,"等待其他线程执行完再执行"),s("td",null,"MyThread myThread = new MyThread(); myThread.join();")])])],-1),r=a(`<h2 id="cas" tabindex="-1">CAS <a class="header-anchor" href="#cas" aria-label="Permalink to &quot;CAS&quot;">​</a></h2><blockquote><p>CAS的全称为compare and swap,对应到CPU指令为<code>cmpxchg</code></p></blockquote><p>CAS 有三个操作数：当前值A、内存值V、要修改的新值B</p><p>假设 当前值A 跟 内存值V 相等，那就将 内存值V 改成B</p><p>假设 当前值A 跟 内存值V 不相等，要么就重试，要么就放弃更新</p><h3 id="aba问题及解决方案" tabindex="-1">ABA问题及解决方案 <a class="header-anchor" href="#aba问题及解决方案" aria-label="Permalink to &quot;ABA问题及解决方案&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291843735.png" alt="image-20220406101540742"></p><p>线程1和线程2同时开始对<code>a</code>的值进行CAS修改，但是线程1的速度比较快，将a的值修改为2之后紧接着又修改回1，这时线程2才开始进行判断，发现a的值是1，所以CAS操作成功。</p><p>很明显，这里的1已经不是一开始的那个1了，而是被重新赋值的1，这也是CAS操作存在的问题（无锁虽好，但是问题多多），它只会机械地比较当前值是不是预期值，但是并不会关心当前值是否被修改过，这种问题称之为<code>ABA</code>问题。</p><p><strong>采用 AtomicStampedReference 解决ABA问题</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    String a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Hello&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    String b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;World&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    AtomicStampedReference&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; reference </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> AtomicStampedReference&lt;&gt;(a, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">//在构造时需要指定初始值和对应的版本号</span></span>
<span class="line"><span style="color:#E1E4E8;">    reference.</span><span style="color:#B392F0;">attemptStamp</span><span style="color:#E1E4E8;">(a, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//可以中途对版本号进行修改，注意要填写当前的引用对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(reference.</span><span style="color:#B392F0;">compareAndSet</span><span style="color:#E1E4E8;">(a, b, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">));   </span><span style="color:#6A737D;">//CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    String a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    String b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;World&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    AtomicStampedReference&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; reference </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> AtomicStampedReference&lt;&gt;(a, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">//在构造时需要指定初始值和对应的版本号</span></span>
<span class="line"><span style="color:#24292E;">    reference.</span><span style="color:#6F42C1;">attemptStamp</span><span style="color:#24292E;">(a, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//可以中途对版本号进行修改，注意要填写当前的引用对象</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(reference.</span><span style="color:#6F42C1;">compareAndSet</span><span style="color:#24292E;">(a, b, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">));   </span><span style="color:#6A737D;">//CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="fork-join框架" tabindex="-1">Fork/Join框架 <a class="header-anchor" href="#fork-join框架" aria-label="Permalink to &quot;Fork/Join框架&quot;">​</a></h2><ul><li><p>使用多线程拆分任务</p></li><li><p>利用工作窃取算法,提高线程的利用率</p><ul><li><p>**工作窃取算法：**是指某个线程从其他队列里窃取任务来执行。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291847277.png" alt="image-20220406181701396"></p></li><li><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ForkJoinPool pool </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ForkJoinPool</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(pool.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">)).</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//继承RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RecursiveTask</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> start;   </span><span style="color:#6A737D;">//比如我们要计算一个范围内所有数的和，那么就需要限定一下范围，这里用了两个int存放</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> end;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">start</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">end</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.start </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> start;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.end </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> end;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> Integer </span><span style="color:#B392F0;">compute</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(end </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> start </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">125</span><span style="color:#E1E4E8;">) {    </span><span style="color:#6A737D;">//每个任务最多计算125个数的和，如果大于继续拆分，小于就可以开始算了</span></span>
<span class="line"><span style="color:#E1E4E8;">                SubTask subTask1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;">(start, (end </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> start) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                subTask1.</span><span style="color:#B392F0;">fork</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//会继续划分子任务执行</span></span>
<span class="line"><span style="color:#E1E4E8;">                SubTask subTask2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;">((end </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> start) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, end);</span></span>
<span class="line"><span style="color:#E1E4E8;">                subTask2.</span><span style="color:#B392F0;">fork</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//会继续划分子任务执行</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> subTask1.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> subTask2.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//越玩越有递归那味了</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 开始计算 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">start</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;-&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">end</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 的值!&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> start; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> end; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    res </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res;   </span><span style="color:#6A737D;">//返回的结果会作为join的结果</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Main</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#24292E;">        ForkJoinPool pool </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ForkJoinPool</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(pool.</span><span style="color:#6F42C1;">submit</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">)).</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//继承RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RecursiveTask</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> start;   </span><span style="color:#6A737D;">//比如我们要计算一个范围内所有数的和，那么就需要限定一下范围，这里用了两个int存放</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> end;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">start</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">end</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.start </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> start;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.end </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> end;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> Integer </span><span style="color:#6F42C1;">compute</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(end </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> start </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">125</span><span style="color:#24292E;">) {    </span><span style="color:#6A737D;">//每个任务最多计算125个数的和，如果大于继续拆分，小于就可以开始算了</span></span>
<span class="line"><span style="color:#24292E;">                SubTask subTask1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;">(start, (end </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> start) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                subTask1.</span><span style="color:#6F42C1;">fork</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//会继续划分子任务执行</span></span>
<span class="line"><span style="color:#24292E;">                SubTask subTask2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;">((end </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> start) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, end);</span></span>
<span class="line"><span style="color:#24292E;">                subTask2.</span><span style="color:#6F42C1;">fork</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//会继续划分子任务执行</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> subTask1.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> subTask2.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//越玩越有递归那味了</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 开始计算 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">start</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;-&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">end</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 的值!&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> start; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> end; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    res </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res;   </span><span style="color:#6A737D;">//返回的结果会作为join的结果</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></li></ul></li></ul><p>Arrays工具类提供的并行排序也是利用了ForkJoinPool来实现：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">parallelSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] a) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a.length, p, g;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> MIN_ARRAY_SORT_GRAN </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">        (p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ForkJoinPool.</span><span style="color:#B392F0;">getCommonPoolParallelism</span><span style="color:#E1E4E8;">()) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        DualPivotQuicksort.</span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(a, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArraysParallelSortHelpers.FJByte.Sorter</span></span>
<span class="line"><span style="color:#E1E4E8;">            (</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, a, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[n], </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, n, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">             ((g </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> (p </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)) </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> MIN_ARRAY_SORT_GRAN) </span><span style="color:#F97583;">?</span></span>
<span class="line"><span style="color:#E1E4E8;">             MIN_ARRAY_SORT_GRAN </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> g).</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">parallelSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] a) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a.length, p, g;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> MIN_ARRAY_SORT_GRAN </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">        (p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ForkJoinPool.</span><span style="color:#6F42C1;">getCommonPoolParallelism</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        DualPivotQuicksort.</span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(a, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArraysParallelSortHelpers.FJByte.Sorter</span></span>
<span class="line"><span style="color:#24292E;">            (</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, a, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[n], </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, n, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">             ((g </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> (p </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)) </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> MIN_ARRAY_SORT_GRAN) </span><span style="color:#D73A49;">?</span></span>
<span class="line"><span style="color:#24292E;">             MIN_ARRAY_SORT_GRAN </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> g).</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="jmm内存模型" tabindex="-1">JMM内存模型 <a class="header-anchor" href="#jmm内存模型" aria-label="Permalink to &quot;JMM内存模型&quot;">​</a></h2><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291843567.png" alt="image-20220405200130691"></p><p>JMM（Java Memory Model）内存模型规定如下：</p><ul><li>所有的变量全部存储在主内存（注意这里包括下面提到的变量，指的都是会出现竞争的变量，包括成员变量、静态变量等，而局部变量这种属于线程私有，不包括在内）</li><li>每条线程有着自己的工作内存（可以类比CPU的高速缓存）线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li><li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li></ul><p>也就是说，每一条线程如果要操作主内存中的数据，那么得先拷贝到自己的工作内存中，并对工作内存中数据的副本进行操作，操作完成之后，也需要从工作副本中将结果拷贝回主内存中，具体的操作就是<code>Save</code>（保存）和<code>Load</code>（加载）操作。</p><p>具体实现：</p><ul><li>主内存：对应堆中存放对象的实例的部分。</li><li>工作内存：对应线程的虚拟机栈的部分区域，虚拟机可能会对这部分内存进行优化，将其放在CPU的寄存器或是高速缓存中。比如在访问数组时，由于数组是一段连续的内存空间，所以可以将一部分连续空间放入到CPU高速缓存中，那么之后如果我们顺序读取这个数组，那么大概率会直接缓存命中。</li></ul><h3 id="重排序原理" tabindex="-1">重排序原理 <a class="header-anchor" href="#重排序原理" aria-label="Permalink to &quot;重排序原理&quot;">​</a></h3><p>在编译或执行时，为了优化程序的执行效率，编译器或处理器常常会对指令进行重排序，有以下情况：</p><ol><li>编译器重排序：Java编译器通过对Java代码语义的理解，根据优化规则对代码指令进行重排序。</li><li>机器指令级别的重排序：现代处理器很高级，能够自主判断和变更机器指令的执行顺序。</li></ol><p>指令重排序能够在不改变结果（单线程）的情况下，优化程序的运行效率</p><h3 id="happens-before原则" tabindex="-1">happens-before原则 <a class="header-anchor" href="#happens-before原则" aria-label="Permalink to &quot;happens-before原则&quot;">​</a></h3><p>JMM提出了<code>happens-before</code>（先行发生）原则，定义一些禁止编译优化的场景，来向各位程序员做一些保证，只要我们是按照原则进行编程，那么就能够保持并发编程的正确性。具体如下：</p><ul><li>**程序次序规则：**同一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。 <ul><li>同一个线程内，代码的执行结果是有序的。其实就是，可能会发生指令重排，但是保证代码的执行结果一定是和按照顺序执行得到的一致，程序前面对某一个变量的修改一定对后续操作可见的，不可能会出现前面才把a修改为1，接着读a居然是修改前的结果，这也是程序运行最基本的要求。</li></ul></li><li>**监视器锁规则：**对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。 <ul><li>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。比如前一个线程将变量<code>x</code>的值修改为了<code>12</code>并解锁，之后另一个线程拿到了这把锁，对之前线程的操作是可见的，可以得到<code>x</code>是前一个线程修改后的结果<code>12</code>（所以synchronized是有happens-before规则的）</li></ul></li><li>**volatile变量规则：**对一个volatile变量的写操作happens-before后续对这个变量的读操作。 <ul><li>就是如果一个线程先去写一个<code>volatile</code>变量，紧接着另一个线程去读这个变量，那么这个写操作的结果一定对读的这个变量的线程可见。</li></ul></li><li>**线程启动规则：**主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。 <ul><li>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li></ul></li><li>**线程加入规则：**如果线程A执行操作<code>join()</code>线程B并成功返回，那么线程B中的任意操作happens-before线程A<code>join()</code>操作成功返回。</li><li>**传递性规则：**如果A happens-before B，B happens-before C，那么A happens-before C。</li></ul><p>从happens-before原则的角度，来解释一下下面的程序结果：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(b </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">) System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(a); </span></span>
<span class="line"><span style="color:#E1E4E8;">        }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Main</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(b </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">) System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(a); </span></span>
<span class="line"><span style="color:#24292E;">        }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>我们定义以上出现的操作：</p><ul><li>**A：**将变量<code>a</code>的值修改为<code>10</code></li><li>**B：**将变量<code>b</code>的值修改为<code>a + 1</code></li><li>**C：**主线程启动了一个新的线程，并在新的线程中获取<code>b</code>，进行判断，如果大于<code>10</code>那么就打印<code>a</code></li></ul><p>我们来分析，由于是同一个线程，并且<strong>B</strong>是一个赋值操作且读取了<strong>A</strong>，那么按照<strong>程序次序规则</strong>，A happens-before B，接着在B之后，马上执行了C，按照<strong>线程启动规则</strong>，在新的线程启动之前，当前线程之前的所有操作对新的线程是可见的，所以 B happens-before C，最后根据<strong>传递性规则</strong>，由于A happens-before B，B happens-before C，所以A happens-before C，因此在新的线程中会输出<code>a</code>修改后的结果<code>10</code>。</p>`,34),c=[e,t,r];function E(y,i,d,F,u,A){return l(),p("div",null,c)}const D=n(o,[["render",E]]);export{b as __pageData,D as default};
