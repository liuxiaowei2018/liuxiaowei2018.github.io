import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.8048b864.js";const p="/assets/image-20230619143510442.ce5453e0.png",o="/assets/image-20230619143621191.3cdc6c9e.png",e="/assets/image-20230619143818004.ee7d56b4.png",t="/assets/image-20230619143933160.9689d898.png",c="/assets/image-20230619144005098.9fcde229.png",r="/assets/image-20230619144035048.d3292f14.png",E="/assets/image-20230619144059376.96e4c4e3.png",y="/assets/image-20230619144551194.f07c55ad.png",i="/assets/image-20230619145650721.75ac1bfe.png",d="/assets/image-20230619145857597.5d69922a.png",u="/assets/image-20230619145943765.7f36691f.png",h="/assets/image-20230619145959823.ed8e630a.png",F="/assets/image-20230619151313298.9efa1a75.png",B=JSON.parse('{"title":"树","description":"","frontmatter":{},"headers":[],"relativePath":"alg/structure/树.md","filePath":"alg/structure/树.md","lastUpdated":1697785485000}'),A={name:"alg/structure/树.md"},D=l(`<h1 id="树" tabindex="-1">树 <a class="header-anchor" href="#树" aria-label="Permalink to &quot;树&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#_1、二叉树">1、二叉树</a><ul><li><a href="#常见术语">常见术语</a></li><li><a href="#基本操作">基本操作</a></li><li><a href="#常见二叉树类型">常见二叉树类型</a></li><li><a href="#二叉树遍历">二叉树遍历</a></li></ul></li><li><a href="#_2、二叉搜索树">2、二叉搜索树</a></li><li><a href="#_3、avl-树">3、AVL 树</a></li></ul></nav><h2 id="_1、二叉树" tabindex="-1">1、二叉树 <a class="header-anchor" href="#_1、二叉树" aria-label="Permalink to &quot;1、二叉树&quot;">​</a></h2><p>「二叉树 Binary Tree」是一种非线性数据结构，代表着祖先与后代之间的派生关系，体现着“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含一个「值」和两个「指针」。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 二叉树节点类 */</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> val;         </span><span style="color:#6A737D;">// 节点值</span></span>
<span class="line"><span style="color:#E1E4E8;">    TreeNode left;   </span><span style="color:#6A737D;">// 左子节点指针</span></span>
<span class="line"><span style="color:#E1E4E8;">    TreeNode right;  </span><span style="color:#6A737D;">// 右子节点指针</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">x</span><span style="color:#E1E4E8;">) { val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> x; }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 二叉树节点类 */</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> val;         </span><span style="color:#6A737D;">// 节点值</span></span>
<span class="line"><span style="color:#24292E;">    TreeNode left;   </span><span style="color:#6A737D;">// 左子节点指针</span></span>
<span class="line"><span style="color:#24292E;">    TreeNode right;  </span><span style="color:#6A737D;">// 右子节点指针</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">x</span><span style="color:#24292E;">) { val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x; }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>节点的两个指针分别指向「左子节点」和「右子节点」，同时该节点被称为这两个子节点的「父节点」。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的「左子树」，同理可得「右子树」。</p><p><strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树</strong>。例如，在以下示例中，若将“节点 2”视为父节点，则其左子节点和右子节点分别是“节点 4”和“节点 5”，左子树是“节点 4 及其以下节点形成的树”，右子树是“节点 5 及其以下节点形成的树”。</p><p><img src="`+p+'" alt="image-20230619143510442"></p><h3 id="常见术语" tabindex="-1">常见术语 <a class="header-anchor" href="#常见术语" aria-label="Permalink to &quot;常见术语&quot;">​</a></h3><ul><li>「根节点 Root Node」：位于二叉树顶层的节点，没有父节点；</li><li>「叶节点 Leaf Node」：没有子节点的节点，其两个指针均指向 None ；</li><li>节点的「层 Level」：从顶至底递增，根节点所在层为 1 ；</li><li>节点的「度 Degree」：节点的子节点的数量。在二叉树中，度的范围是 0, 1, 2 ；</li><li>「边 Edge」：连接两个节点的线段，即节点指针；</li><li>二叉树的「高度」：从根节点到最远叶节点所经过的边的数量；</li><li>节点的「深度 Depth」 ：从根节点到该节点所经过的边的数量；</li><li>节点的「高度 Height」：从最远叶节点到该节点所经过的边的数量</li></ul><p><img src="'+o+`" alt="image-20230619143621191"></p><h3 id="基本操作" tabindex="-1">基本操作 <a class="header-anchor" href="#基本操作" aria-label="Permalink to &quot;基本操作&quot;">​</a></h3><p><strong>初始化二叉树</strong>。与链表类似，首先初始化节点，然后构建引用指向（即指针）。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 初始化节点</span></span>
<span class="line"><span style="color:#E1E4E8;">TreeNode n1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">TreeNode n2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">TreeNode n3 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">TreeNode n4 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">TreeNode n5 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 构建引用指向（即指针）</span></span>
<span class="line"><span style="color:#E1E4E8;">n1.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n2;</span></span>
<span class="line"><span style="color:#E1E4E8;">n1.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n3;</span></span>
<span class="line"><span style="color:#E1E4E8;">n2.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n4;</span></span>
<span class="line"><span style="color:#E1E4E8;">n2.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n5;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 初始化节点</span></span>
<span class="line"><span style="color:#24292E;">TreeNode n1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">TreeNode n2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">TreeNode n3 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">TreeNode n4 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">TreeNode n5 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 构建引用指向（即指针）</span></span>
<span class="line"><span style="color:#24292E;">n1.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> n2;</span></span>
<span class="line"><span style="color:#24292E;">n1.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> n3;</span></span>
<span class="line"><span style="color:#24292E;">n2.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> n4;</span></span>
<span class="line"><span style="color:#24292E;">n2.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> n5;</span></span></code></pre></div><p><strong>插入与删除节点</strong>。与链表类似，通过修改指针来实现插入与删除节点</p><p><img src="`+e+`" alt="image-20230619143818004"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">TreeNode P </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 在 n1 -&gt; n2 中间插入节点 P</span></span>
<span class="line"><span style="color:#E1E4E8;">n1.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> P;</span></span>
<span class="line"><span style="color:#E1E4E8;">P.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n2;</span></span>
<span class="line"><span style="color:#6A737D;">// 删除节点 P</span></span>
<span class="line"><span style="color:#E1E4E8;">n1.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n2;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">TreeNode P </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 在 n1 -&gt; n2 中间插入节点 P</span></span>
<span class="line"><span style="color:#24292E;">n1.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> P;</span></span>
<span class="line"><span style="color:#24292E;">P.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> n2;</span></span>
<span class="line"><span style="color:#6A737D;">// 删除节点 P</span></span>
<span class="line"><span style="color:#24292E;">n1.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> n2;</span></span></code></pre></div><blockquote><p>需要注意的是，插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除操作通常是由一套操作配合完成的，以实现有实际意义的操作。</p></blockquote><h3 id="常见二叉树类型" tabindex="-1">常见二叉树类型 <a class="header-anchor" href="#常见二叉树类型" aria-label="Permalink to &quot;常见二叉树类型&quot;">​</a></h3><h4 id="完美二叉树" tabindex="-1">完美二叉树 <a class="header-anchor" href="#完美二叉树" aria-label="Permalink to &quot;完美二叉树&quot;">​</a></h4><p>「完美二叉树 Perfect Binary Tree」除了最底层外，其余所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 0 ，其余所有节点的度都为 2 ；若树高度为 ℎ ，则节点总数为 2ℎ+1−1 ，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。</p><blockquote><p>完美二叉树常被称为「满二叉树」，请注意区分。</p></blockquote><p><img src="`+t+'" alt="image-20230619143933160"></p><h4 id="完全二叉树" tabindex="-1">完全二叉树 <a class="header-anchor" href="#完全二叉树" aria-label="Permalink to &quot;完全二叉树&quot;">​</a></h4><p>「完全二叉树 Complete Binary Tree」只有最底层的节点未被填满，且最底层节点尽量靠左填充。</p><p><img src="'+c+'" alt="image-20230619144005098"></p><h4 id="完满二叉树" tabindex="-1">完满二叉树 <a class="header-anchor" href="#完满二叉树" aria-label="Permalink to &quot;完满二叉树&quot;">​</a></h4><p>「完满二叉树 Full Binary Tree」除了叶节点之外，其余所有节点都有两个子节点。</p><p><img src="'+r+'" alt="image-20230619144035048"></p><h4 id="平衡二叉树" tabindex="-1">平衡二叉树 <a class="header-anchor" href="#平衡二叉树" aria-label="Permalink to &quot;平衡二叉树&quot;">​</a></h4><p>「平衡二叉树 Balanced Binary Tree」中任意节点的左子树和右子树的高度之差的绝对值不超过 1 。</p><p><img src="'+E+`" alt="image-20230619144059376"></p><p>在最佳和最差结构下，二叉树的叶节点数量、节点总数、高度等达到极大或极小值。</p><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">完美二叉树</th><th style="text-align:left;">链表</th></tr></thead><tbody><tr><td style="text-align:left;">第 n 层的节点数量</td><td style="text-align:left;">2^i−1</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">树的高度为 ℎ 时的叶节点数量</td><td style="text-align:left;">2ℎ</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">树的高度为 ℎ 时的节点总数</td><td style="text-align:left;">2^(ℎ+1)−1</td><td style="text-align:left;">ℎ+1</td></tr><tr><td style="text-align:left;">树的节点总数为 n 时的高度</td><td style="text-align:left;">log2⁡^(n+1)−1</td><td style="text-align:left;">n−1</td></tr></tbody></table><h3 id="二叉树遍历" tabindex="-1">二叉树遍历 <a class="header-anchor" href="#二叉树遍历" aria-label="Permalink to &quot;二叉树遍历&quot;">​</a></h3><p>二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等。</p><h4 id="层序遍历" tabindex="-1">层序遍历 <a class="header-anchor" href="#层序遍历" aria-label="Permalink to &quot;层序遍历&quot;">​</a></h4><p>「层序遍历 Level-Order Traversal」从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。</p><p>层序遍历本质上属于「广度优先搜索 Breadth-First Traversal」，体现了一种“一圈一圈向外扩展”的逐层搜索方式。</p><p>广度优先遍历通常借助「队列」来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 层序遍历 */</span></span>
<span class="line"><span style="color:#E1E4E8;">List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Integer</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">levelOrder</span><span style="color:#E1E4E8;">(TreeNode root) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化队列，加入根节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    Queue&lt;</span><span style="color:#F97583;">TreeNode</span><span style="color:#E1E4E8;">&gt; queue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedList&lt;&gt;() {{ </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root); }};</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化一个列表，用于保存遍历序列</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; list </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">queue.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        TreeNode node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> queue.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 队列出队</span></span>
<span class="line"><span style="color:#E1E4E8;">        list.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(node.val);           </span><span style="color:#6A737D;">// 保存节点值</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.left </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            queue.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(node.left);   </span><span style="color:#6A737D;">// 左子节点入队</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.right </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            queue.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(node.right);  </span><span style="color:#6A737D;">// 右子节点入队</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> list;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 层序遍历 */</span></span>
<span class="line"><span style="color:#24292E;">List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Integer</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">levelOrder</span><span style="color:#24292E;">(TreeNode root) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化队列，加入根节点</span></span>
<span class="line"><span style="color:#24292E;">    Queue&lt;</span><span style="color:#D73A49;">TreeNode</span><span style="color:#24292E;">&gt; queue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedList&lt;&gt;() {{ </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root); }};</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化一个列表，用于保存遍历序列</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; list </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">queue.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        TreeNode node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> queue.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 队列出队</span></span>
<span class="line"><span style="color:#24292E;">        list.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(node.val);           </span><span style="color:#6A737D;">// 保存节点值</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.left </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            queue.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(node.left);   </span><span style="color:#6A737D;">// 左子节点入队</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.right </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            queue.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(node.right);  </span><span style="color:#6A737D;">// 右子节点入队</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> list;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h5 id="复杂度分析" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h5><p><strong>时间复杂度</strong>：所有节点被访问一次，使用 O(n) 时间，其中 n为节点数量。</p><p><strong>空间复杂度</strong>：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 (n+1)/2 个节点，占用 O(n) 空间。</p><h4 id="前序、中序、后序遍历" tabindex="-1">前序、中序、后序遍历 <a class="header-anchor" href="#前序、中序、后序遍历" aria-label="Permalink to &quot;前序、中序、后序遍历&quot;">​</a></h4><p>前序、中序和后序遍历都属于「深度优先遍历 Depth-First Traversal」，它体现了一种“先走到尽头，再回溯继续”的遍历方式。</p><blockquote><ul><li>前序遍历：<strong>先输出父节点</strong>，再遍历左子树和右子树</li><li>中序遍历：先遍历左子树，<strong>再输出父节点</strong>，再遍历右子树</li><li>后序遍历：先遍历左子树，再遍历右子树，<strong>最后输出父节点</strong></li></ul></blockquote><blockquote><p><code>看输出父节点的顺序，就确定是前序、中序还是后序。</code></p></blockquote><h5 id="前序遍历" tabindex="-1">前序遍历 <a class="header-anchor" href="#前序遍历" aria-label="Permalink to &quot;前序遍历&quot;">​</a></h5><ul><li>1.先输出当前节点（初始的时候是root节点）</li><li>2.如果左子节点不为空，则递归继续前序遍历</li><li>3.如果右子节点不为空，则递归继续前序遍历</li></ul><h5 id="中序遍历" tabindex="-1">中序遍历 <a class="header-anchor" href="#中序遍历" aria-label="Permalink to &quot;中序遍历&quot;">​</a></h5><ul><li>1.如果当前节点的左子节点不为空，则递归中序遍历</li><li>2.输出当前节点</li><li>3.如果当前的右子节点不为空，则递归中序遍历</li></ul><h5 id="后序遍历" tabindex="-1">后序遍历 <a class="header-anchor" href="#后序遍历" aria-label="Permalink to &quot;后序遍历&quot;">​</a></h5><ul><li>1.如果当前节点的左子节点不为空，则递归后序遍历</li><li>2.如果当前节点的右子节点不为空，则递归后序遍历</li><li>3.输出当前节点</li></ul><p>如下图所示，左侧是深度优先遍历的示意图，右上方是对应的递归实现代码。深度优先遍历就像是绕着整个二叉树的外围“走”一圈，在这个过程中，在每个节点都会遇到三个位置，分别对应前序遍历、中序遍历和后序遍历。</p><p><img src="`+y+`" alt="image-20230619144551194"></p><p>​ <code>二叉搜索树的前、中、后序遍历</code></p><table><thead><tr><th style="text-align:left;">位置</th><th style="text-align:left;">含义</th><th style="text-align:left;">此处访问节点时对应</th></tr></thead><tbody><tr><td style="text-align:left;">橙色圆圈处</td><td style="text-align:left;">刚进入此节点，即将访问该节点的左子树</td><td style="text-align:left;">前序遍历 Pre-Order Traversal</td></tr><tr><td style="text-align:left;">蓝色圆圈处</td><td style="text-align:left;">已访问完左子树，即将访问右子树</td><td style="text-align:left;">中序遍历 In-Order Traversal</td></tr><tr><td style="text-align:left;">紫色圆圈处</td><td style="text-align:left;">已访问完左子树和右子树，即将返回</td><td style="text-align:left;">后序遍历 Post-Order Traversal</td></tr></tbody></table><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 前序遍历 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(TreeNode root) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">    list.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(root.left);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(root.right);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 中序遍历 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">inOrder</span><span style="color:#E1E4E8;">(TreeNode root) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">inOrder</span><span style="color:#E1E4E8;">(root.left);</span></span>
<span class="line"><span style="color:#E1E4E8;">    list.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">inOrder</span><span style="color:#E1E4E8;">(root.right);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 后序遍历 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(TreeNode root) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root.left);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root.right);</span></span>
<span class="line"><span style="color:#E1E4E8;">    list.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 前序遍历 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(TreeNode root) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span>
<span class="line"><span style="color:#24292E;">    list.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(root.left);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(root.right);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 中序遍历 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">inOrder</span><span style="color:#24292E;">(TreeNode root) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">inOrder</span><span style="color:#24292E;">(root.left);</span></span>
<span class="line"><span style="color:#24292E;">    list.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">inOrder</span><span style="color:#24292E;">(root.right);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 后序遍历 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(TreeNode root) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root.left);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root.right);</span></span>
<span class="line"><span style="color:#24292E;">    list.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_2、二叉搜索树" tabindex="-1">2、二叉搜索树 <a class="header-anchor" href="#_2、二叉搜索树" aria-label="Permalink to &quot;2、二叉搜索树&quot;">​</a></h2><p>「二叉搜索树 Binary Search Tree」满足以下条件：</p><ol><li>对于根节点，左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值；</li><li>任意节点的左、右子树也是二叉搜索树，即同样满足条件 <code>1</code> ；</li></ol><p><img src="`+i+`" alt="image-20230619145650721"></p><h4 id="查找节点" tabindex="-1">查找节点 <a class="header-anchor" href="#查找节点" aria-label="Permalink to &quot;查找节点&quot;">​</a></h4><p>给定目标节点值 <code>num</code> ，可以根据二叉搜索树的性质来查找。我们声明一个节点 <code>cur</code> ，从二叉树的根节点 <code>root</code> 出发，循环比较节点值 <code>cur.val</code> 和 <code>num</code> 之间的大小关系</p><ul><li>若 <code>cur.val &lt; num</code> ，说明目标节点在 <code>cur</code> 的右子树中，因此执行 <code>cur = cur.right</code> ；</li><li>若 <code>cur.val &gt; num</code> ，说明目标节点在 <code>cur</code> 的左子树中，因此执行 <code>cur = cur.left</code> ；</li><li>若 <code>cur.val = num</code> ，说明找到目标节点，跳出循环并返回该节点；</li></ul><p>二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用 O(log⁡n) 时间。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 查找节点 */</span></span>
<span class="line"><span style="color:#E1E4E8;">TreeNode </span><span style="color:#B392F0;">search</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> num) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    TreeNode cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 循环查找，越过叶节点后跳出</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (cur </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 目标节点在 cur 的右子树中</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cur.val </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> num)</span></span>
<span class="line"><span style="color:#E1E4E8;">            cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 目标节点在 cur 的左子树中</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cur.val </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> num)</span></span>
<span class="line"><span style="color:#E1E4E8;">            cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 找到目标节点，跳出循环</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回目标节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 查找节点 */</span></span>
<span class="line"><span style="color:#24292E;">TreeNode </span><span style="color:#6F42C1;">search</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> num) {</span></span>
<span class="line"><span style="color:#24292E;">    TreeNode cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 循环查找，越过叶节点后跳出</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (cur </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 目标节点在 cur 的右子树中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cur.val </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> num)</span></span>
<span class="line"><span style="color:#24292E;">            cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur.right;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 目标节点在 cur 的左子树中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cur.val </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> num)</span></span>
<span class="line"><span style="color:#24292E;">            cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur.left;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 找到目标节点，跳出循环</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回目标节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> cur;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="插入节点" tabindex="-1">插入节点 <a class="header-anchor" href="#插入节点" aria-label="Permalink to &quot;插入节点&quot;">​</a></h4><p>给定一个待插入元素 <code>num</code> ，为了保持二叉搜索树“左子树 &lt; 根节点 &lt; 右子树”的性质，插入操作分为两步：</p><ol><li><strong>查找插入位置</strong>：与查找操作相似，从根节点出发，根据当前节点值和 <code>num</code> 的大小关系循环向下搜索，直到越过叶节点（遍历至 None ）时跳出循环；</li><li><strong>在该位置插入节点</strong>：初始化节点 <code>num</code> ，将该节点置于 None 的位置；</li></ol><p>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。</p><p><img src="`+d+`" alt="image-20230619145857597"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 插入节点 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">insert</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> num) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若树为空，直接提前返回</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    TreeNode cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root, pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 循环查找，越过叶节点后跳出</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (cur </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 找到重复节点，直接返回</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cur.val </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> num)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 插入位置在 cur 的右子树中</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cur.val </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> num)</span></span>
<span class="line"><span style="color:#E1E4E8;">            cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 插入位置在 cur 的左子树中</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">            cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 插入节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    TreeNode node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">(num);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (pre.val </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> num)</span></span>
<span class="line"><span style="color:#E1E4E8;">        pre.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">        pre.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 插入节点 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">insert</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> num) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若树为空，直接提前返回</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    TreeNode cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root, pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 循环查找，越过叶节点后跳出</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (cur </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 找到重复节点，直接返回</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cur.val </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> num)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 插入位置在 cur 的右子树中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cur.val </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> num)</span></span>
<span class="line"><span style="color:#24292E;">            cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur.right;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 插入位置在 cur 的左子树中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">            cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur.left;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 插入节点</span></span>
<span class="line"><span style="color:#24292E;">    TreeNode node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">(num);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (pre.val </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> num)</span></span>
<span class="line"><span style="color:#24292E;">        pre.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">        pre.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>为了插入节点，我们需要利用辅助节点 <code>pre</code> 保存上一轮循环的节点，这样在遍历至 None 时，我们可以获取到其父节点，从而完成节点插入操作。</p><p>与查找节点相同，插入节点使用 O(log⁡n) 时间。</p><h4 id="删除节点" tabindex="-1">删除节点 <a class="header-anchor" href="#删除节点" aria-label="Permalink to &quot;删除节点&quot;">​</a></h4><p>与插入节点类似，我们需要在删除操作后维持二叉搜索树的“左子树 &lt; 根节点 &lt; 右子树”的性质。首先，我们需要在二叉树中执行查找操作，获取待删除节点。接下来，根据待删除节点的子节点数量，删除操作需分为三种情况：</p><p>当待删除节点的子节点数量 =0 时，表示待删除节点是叶节点，可以直接删除。</p><p><img src="`+u+'" alt="image-20230619145943765"></p><p>当待删除节点的子节点数量 =1 时，将待删除节点替换为其子节点即可。</p><p><img src="'+h+`" alt="image-20230619145959823"></p><p>当待删除节点的子节点数量 =2 时，删除操作分为三步：</p><ol><li>找到待删除节点在“中序遍历序列”中的下一个节点，记为 <code>tmp</code> ；</li><li>在树中递归删除节点 <code>tmp</code> ；</li><li>用 <code>tmp</code> 的值覆盖待删除节点的值；</li></ol><p>删除节点操作同样使用 O(log⁡n) 时间，其中查找待删除节点需要 O(log⁡n) 时间，获取中序遍历后继节点需要 O(log⁡n) 时间。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 删除节点 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> num) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若树为空，直接提前返回</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    TreeNode cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root, pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 循环查找，越过叶节点后跳出</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (cur </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 找到待删除节点，跳出循环</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cur.val </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> num)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 待删除节点在 cur 的右子树中</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cur.val </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> num)</span></span>
<span class="line"><span style="color:#E1E4E8;">            cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 待删除节点在 cur 的左子树中</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">            cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若无待删除节点，则直接返回</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cur </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 子节点数量 = 0 or 1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cur.left </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> cur.right </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 当子节点数量 = 0 / 1 时， child = null / 该子节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        TreeNode child </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur.left </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> cur.left </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> cur.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 删除节点 cur</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cur </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> root) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (pre.left </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> cur)</span></span>
<span class="line"><span style="color:#E1E4E8;">                pre.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> child;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">                pre.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> child;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 若删除节点为根节点，则重新指定根节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> child;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 子节点数量 = 2</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 获取中序遍历中 cur 的下一个节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        TreeNode tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (tmp.left </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 递归删除节点 tmp</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(tmp.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 用 tmp 覆盖 cur</span></span>
<span class="line"><span style="color:#E1E4E8;">        cur.val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp.val;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 删除节点 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> num) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若树为空，直接提前返回</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    TreeNode cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root, pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 循环查找，越过叶节点后跳出</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (cur </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 找到待删除节点，跳出循环</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cur.val </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> num)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 待删除节点在 cur 的右子树中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cur.val </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> num)</span></span>
<span class="line"><span style="color:#24292E;">            cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur.right;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 待删除节点在 cur 的左子树中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">            cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur.left;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若无待删除节点，则直接返回</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cur </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 子节点数量 = 0 or 1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cur.left </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> cur.right </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 当子节点数量 = 0 / 1 时， child = null / 该子节点</span></span>
<span class="line"><span style="color:#24292E;">        TreeNode child </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur.left </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> cur.left </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> cur.right;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 删除节点 cur</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cur </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> root) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (pre.left </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> cur)</span></span>
<span class="line"><span style="color:#24292E;">                pre.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> child;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">                pre.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> child;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 若删除节点为根节点，则重新指定根节点</span></span>
<span class="line"><span style="color:#24292E;">            root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> child;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 子节点数量 = 2</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 获取中序遍历中 cur 的下一个节点</span></span>
<span class="line"><span style="color:#24292E;">        TreeNode tmp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur.right;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (tmp.left </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            tmp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tmp.left;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 递归删除节点 tmp</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(tmp.val);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 用 tmp 覆盖 cur</span></span>
<span class="line"><span style="color:#24292E;">        cur.val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tmp.val;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="排序" tabindex="-1">排序 <a class="header-anchor" href="#排序" aria-label="Permalink to &quot;排序&quot;">​</a></h4><p>二叉树的中序遍历遵循“左 → 根 → 右”的遍历顺序，而二叉搜索树满足“左子节点 &lt; 根节点 &lt; 右子节点”的大小关系。因此，在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：<strong>二叉搜索树的中序遍历序列是升序的</strong>。</p><p>利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需 O(n) 时间，无需额外排序，非常高效。</p><p><img src="`+F+'" alt="image-20230619151313298"></p><h2 id="_3、avl-树" tabindex="-1">3、AVL 树 <a class="header-anchor" href="#_3、avl-树" aria-label="Permalink to &quot;3、AVL 树&quot;">​</a></h2><p>AVL 树既是二叉搜索树也是平衡二叉树，同时满足这两类二叉树的所有性质，因此也被称为「平衡二叉搜索树 balanced binary search tree」。</p>',92),g=[D];function f(m,v,b,C,T,k){return n(),a("div",null,g)}const _=s(A,[["render",f]]);export{B as __pageData,_ as default};
