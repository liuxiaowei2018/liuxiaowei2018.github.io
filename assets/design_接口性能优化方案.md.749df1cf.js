import{_ as a,o as s,c as l,Q as o}from"./chunks/framework.8048b864.js";const e="/assets/image-20220103162932748.75263699.png",p="/assets/image-20220103163013740.d527e4ba.png",n="/assets/image-20220103163130498.2e918a6d.png",t="/assets/image-20220103163818105.afb323dc.png",k=JSON.parse('{"title":"架构设计","description":"","frontmatter":{},"headers":[],"relativePath":"design/接口性能优化方案.md","filePath":"design/接口性能优化方案.md","lastUpdated":1684476376000}'),r={name:"design/接口性能优化方案.md"},c=o('<h1 id="架构设计" tabindex="-1">架构设计 <a class="header-anchor" href="#架构设计" aria-label="Permalink to &quot;架构设计&quot;">​</a></h1><h2 id="接口性能优化方案" tabindex="-1">接口性能优化方案 <a class="header-anchor" href="#接口性能优化方案" aria-label="Permalink to &quot;接口性能优化方案&quot;">​</a></h2><h3 id="_1-索引" tabindex="-1">1.索引 <a class="header-anchor" href="#_1-索引" aria-label="Permalink to &quot;1.索引&quot;">​</a></h3><blockquote><p>通过查看线上日志或者监控报告，查到某个接口用到的某条sql语句耗时比较长。</p><p>这时可能会有下面这些疑问：</p><ol><li>该sql语句加索引了没？</li><li>加的索引生效了没？</li><li>mysql选错索引了没？</li></ol></blockquote><h4 id="_1-1-没加索引" tabindex="-1">1.1 没加索引 <a class="header-anchor" href="#_1-1-没加索引" aria-label="Permalink to &quot;1.1 没加索引&quot;">​</a></h4><blockquote><p>sql语句中<code>where</code>条件的关键字段，或者<code>order by</code>后面的排序字段，忘了加索引，这个问题在项目中很常见。</p><p>项目刚开始的时候，由于表中的数据量小，加不加索引sql查询性能差别不大。</p><p>后来，随着业务的发展，表中数据量越来越多，就不得不加索引了。</p><p>可以通过命令：能单独查看某张表的索引情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">show </span><span style="color:#F97583;">index</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`order`</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">show </span><span style="color:#D73A49;">index</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`order`</span><span style="color:#24292E;">;</span></span></code></pre></div><p>也可以通过命令：查看整张表的建表语句，里面同样会显示索引情况</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">show </span><span style="color:#F97583;">create</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">table</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`order`</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">show </span><span style="color:#D73A49;">create</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">table</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`order`</span><span style="color:#24292E;">;</span></span></code></pre></div><h6 id="添加索引" tabindex="-1">添加索引： <a class="header-anchor" href="#添加索引" aria-label="Permalink to &quot;添加索引：&quot;">​</a></h6><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">ALTER</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`order`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ADD</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> idx_name (</span><span style="color:#F97583;">name</span><span style="color:#E1E4E8;">); #通过ALTER TABLE命令可以添加索引</span></span>\n<span class="line"><span style="color:#F97583;">CREATE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">INDEX</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">idx_name</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ON</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`order`</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">name</span><span style="color:#E1E4E8;">);	   #通过CREATE INDEX命令添加索引</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">ALTER</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`order`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ADD</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> idx_name (</span><span style="color:#D73A49;">name</span><span style="color:#24292E;">); #通过ALTER TABLE命令可以添加索引</span></span>\n<span class="line"><span style="color:#D73A49;">CREATE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">INDEX</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">idx_name</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ON</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`order`</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">name</span><span style="color:#24292E;">);	   #通过CREATE INDEX命令添加索引</span></span></code></pre></div><p>tips:目前在mysql中如果想要通过命令修改索引，只能先删除索引，再重新添加新的。</p></blockquote><h4 id="_1-2-索引没生效" tabindex="-1">1.2 索引没生效 <a class="header-anchor" href="#_1-2-索引没生效" aria-label="Permalink to &quot;1.2 索引没生效&quot;">​</a></h4><blockquote><p>使用<code>explain</code>命令，查看mysql的执行计划，它会显示索引的使用情况。</p><p><img src="'+e+'" alt="image-20220103162932748"></p><p>索引失效的常见原因：</p><p><img src="'+p+'" alt="image-20220103163013740"></p></blockquote><h4 id="_1-3-选错索引" tabindex="-1">1.3 选错索引 <a class="header-anchor" href="#_1-3-选错索引" aria-label="Permalink to &quot;1.3 选错索引&quot;">​</a></h4><blockquote><p>mysql会选错索引。</p><p>必要时可以使用<code>force index</code>来强制查询sql走某个索引。</p></blockquote><h3 id="_2-sql优化" tabindex="-1">2.sql优化 <a class="header-anchor" href="#_2-sql优化" aria-label="Permalink to &quot;2.sql优化&quot;">​</a></h3><blockquote><p><img src="'+n+'" alt="image-20220103163130498"></p></blockquote><h3 id="_3-远程调用" tabindex="-1">3.远程调用 <a class="header-anchor" href="#_3-远程调用" aria-label="Permalink to &quot;3.远程调用&quot;">​</a></h3><blockquote><p>串行调用远程接口性能是非常不好的，调用远程接口总的耗时为所有的远程接口耗时之和。</p><p>优化远程接口性能</p></blockquote><h4 id="_3-1-并行调用" tabindex="-1">3.1 并行调用 <a class="header-anchor" href="#_3-1-并行调用" aria-label="Permalink to &quot;3.1 并行调用&quot;">​</a></h4><blockquote><p>在java8之前可以通过实现<code>Callable</code>接口，获取线程返回结果。</p><p>java8以后通过<code>CompleteFuture</code>类实现该功能。这里以<code>CompleteFuture</code>为例：</p></blockquote><h4 id="_3-2-数据异构" tabindex="-1">3.2 数据异构 <a class="header-anchor" href="#_3-2-数据异构" aria-label="Permalink to &quot;3.2 数据异构&quot;">​</a></h4><blockquote><p>在高并发的场景下，为了提升接口性能，远程接口调用大概率会被去掉，而改成保存冗余数据的数据异构方案</p><p>但需要注意的是，如果使用了数据异构方案，就可能会出现数据一致性问题。</p></blockquote><h3 id="_4-重复调用" tabindex="-1">4.重复调用 <a class="header-anchor" href="#_4-重复调用" aria-label="Permalink to &quot;4.重复调用&quot;">​</a></h3><h4 id="_4-1-循环查数据库" tabindex="-1">4.1 循环查数据库 <a class="header-anchor" href="#_4-1-循环查数据库" aria-label="Permalink to &quot;4.1 循环查数据库&quot;">​</a></h4><blockquote><p>提供一个根据用户id集合批量查询用户的接口，只远程调用一次，就能查询出所有的数据。</p><p>这里有个需要注意的地方是：id集合的大小要做限制，最好一次不要请求太多的数据。要根据实际情况而定，建议控制每次请求的记录条数在500以内</p></blockquote><h4 id="_4-2-死循环" tabindex="-1">4.2 死循环 <a class="header-anchor" href="#_4-2-死循环" aria-label="Permalink to &quot;4.2 死循环&quot;">​</a></h4><h4 id="_4-3-无限递归" tabindex="-1">4.3 无限递归 <a class="header-anchor" href="#_4-3-无限递归" aria-label="Permalink to &quot;4.3 无限递归&quot;">​</a></h4><blockquote><p>建议写递归方法时，设定一个递归的深度，比如：分类最大等级有4级，则深度可以设置为4。然后在递归方法中做判断，如果深度大于4时，则自动返回，这样就能避免无限循环的情况。</p></blockquote><h3 id="_5-异步处理" tabindex="-1">5.异步处理 <a class="header-anchor" href="#_5-异步处理" aria-label="Permalink to &quot;5.异步处理&quot;">​</a></h3><blockquote><p>核心逻辑可以同步执行，同步写库。非核心逻辑，可以异步执行，异步写库。</p></blockquote><h4 id="_5-1-线程池" tabindex="-1">5.1 线程池 <a class="header-anchor" href="#_5-1-线程池" aria-label="Permalink to &quot;5.1 线程池&quot;">​</a></h4><blockquote><p>使用线程池有个小问题就是：如果服务器重启了，或者是需要被执行的功能出现异常了，无法重试，会丢数据。</p></blockquote><h4 id="_5-2-mq" tabindex="-1">5.2 mq <a class="header-anchor" href="#_5-2-mq" aria-label="Permalink to &quot;5.2 mq&quot;">​</a></h4><blockquote><p>发送了mq消息到mq服务器。然后由mq消费者消费消息</p></blockquote><h3 id="_6-避免大事务" tabindex="-1">6.避免大事务 <a class="header-anchor" href="#_6-避免大事务" aria-label="Permalink to &quot;6.避免大事务&quot;">​</a></h3><blockquote><p><img src="'+t+`" alt="image-20220103163818105"></p><p>从图中能够看出，大事务问题可能会造成接口超时，对接口的性能有直接的影响。</p><p>该如何优化大事务呢？</p><ol><li><p>少用<code>@Transactional</code>注解</p></li><li><p>将查询(select)方法放到事务外</p></li><li><p>事务中避免远程调用</p></li><li><p>事务中避免一次性处理太多数据</p></li><li><p>有些功能可以非事务执行</p></li><li><p>有些功能可以异步处理</p></li></ol></blockquote><h3 id="_7-锁粒度" tabindex="-1">7.锁粒度 <a class="header-anchor" href="#_7-锁粒度" aria-label="Permalink to &quot;7.锁粒度&quot;">​</a></h3><blockquote><p>在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。</p><p>为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，会：加锁。</p><p>但如果锁加得不好，导致锁的粒度太粗，也会非常影响接口性能。</p></blockquote><h4 id="_7-1-synchronized" tabindex="-1">7.1 <code>synchronized</code> <a class="header-anchor" href="#_7-1-synchronized" aria-label="Permalink to &quot;7.1 \`synchronized\`&quot;">​</a></h4><blockquote><p>在方法上加锁 (锁的粒度有点粗)和 在代码块上加锁(锁的粒度变小)。</p><p>synchronized只能保证一个节点加锁是有效的，但如果有多个节点如何加锁呢?</p></blockquote><h4 id="_7-2-redis分布式锁" tabindex="-1">7.2 redis分布式锁 <a class="header-anchor" href="#_7-2-redis分布式锁" aria-label="Permalink to &quot;7.2 redis分布式锁&quot;">​</a></h4><h4 id="_7-3-数据库分布式锁" tabindex="-1">7.3 数据库分布式锁 <a class="header-anchor" href="#_7-3-数据库分布式锁" aria-label="Permalink to &quot;7.3 数据库分布式锁&quot;">​</a></h4><blockquote><p>mysql数据库中主要有三种锁：</p><ul><li><p>表锁：加锁快，不会出现死锁。但锁定粒度大，发生锁冲突的概率最高，并发度最低。</p></li><li><p>行锁：加锁慢，会出现死锁。但锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p></li><li><p>间隙锁：开销和加锁时间界于表锁和行锁之间。它会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般。</p></li></ul><p>并发度越高，意味着接口性能越好。</p><p>所以数据库锁的优化方向是：</p><p>优先使用行锁，其次使用间隙锁，再其次使用表锁。</p></blockquote><h3 id="_8-分页处理" tabindex="-1">8.分页处理 <a class="header-anchor" href="#_8-分页处理" aria-label="Permalink to &quot;8.分页处理&quot;">​</a></h3><h4 id="_8-1-同步调用" tabindex="-1">8.1 同步调用 <a class="header-anchor" href="#_8-1-同步调用" aria-label="Permalink to &quot;8.1 同步调用&quot;">​</a></h4><h4 id="_8-2-异步调用" tabindex="-1">8.2 异步调用 <a class="header-anchor" href="#_8-2-异步调用" aria-label="Permalink to &quot;8.2 异步调用&quot;">​</a></h4><blockquote><p>使用<code>CompletableFuture</code>类，多个线程异步调用远程接口，最后汇总结果统一返回</p></blockquote><h3 id="_9-加缓存" tabindex="-1">9.加缓存 <a class="header-anchor" href="#_9-加缓存" aria-label="Permalink to &quot;9.加缓存&quot;">​</a></h3><blockquote><p>解决接口性能问题，加缓存是一个非常高效的方法。</p><p>但不能为了缓存而缓存，还是要看具体的业务场景。毕竟加了缓存，会导致接口的复杂度增加，它会带来数据不一致问题。</p></blockquote><h4 id="_9-1-redis缓存" tabindex="-1">9.1 redis缓存 <a class="header-anchor" href="#_9-1-redis缓存" aria-label="Permalink to &quot;9.1 redis缓存&quot;">​</a></h4><h4 id="_9-2-二级缓存" tabindex="-1">9.2 二级缓存 <a class="header-anchor" href="#_9-2-二级缓存" aria-label="Permalink to &quot;9.2 二级缓存&quot;">​</a></h4><blockquote><p>基于内存的缓存</p><p>实现参考<code>caffeine</code></p></blockquote><h3 id="_10-分库分表" tabindex="-1">10.分库分表 <a class="header-anchor" href="#_10-分库分表" aria-label="Permalink to &quot;10.分库分表&quot;">​</a></h3><blockquote><p>路由的算法挺多的：</p><ul><li><p>根据id取模，比如：id=7，有4张表，则7%4=3，模为3，路由到用户表3。</p></li><li><p>给id指定一个区间范围，比如：id的值是0-10万，则数据存在用户表0，id的值是10-20万，则数据存在用户表1。</p></li><li><p>一致性hash算法</p></li></ul><p>分库分表主要有两个方向：垂直和水平。</p><p>说实话垂直方向（即业务方向）更简单。</p><p>在水平方向（即数据方向）上，分库和分表的作用，其实是有区别的，不能混为一谈。</p><ul><li><p>分库：是为了解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。</p></li><li><p>分表：是为了解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。此外还可以解决消耗cpu资源问题。</p></li><li><p>分库分表：可以解决 数据库连接资源不足、磁盘IO的性能瓶颈、检索数据耗时 和 消耗cpu资源等问题。</p></li></ul><p>如果在有些业务场景中，用户并发量很大，但是需要保存的数据量很少，这时可以只分库，不分表。</p><p>如果在有些业务场景中，用户并发量不大，但是需要保存的数量很多，这时可以只分表，不分库。</p><p>如果在有些业务场景中，用户并发量大，并且需要保存的数量也很多时，可以分库分表。</p></blockquote><h3 id="_11-辅助功能" tabindex="-1">11.辅助功能 <a class="header-anchor" href="#_11-辅助功能" aria-label="Permalink to &quot;11.辅助功能&quot;">​</a></h3><h4 id="_11-1-开启慢查询日志" tabindex="-1">11.1 开启慢查询日志 <a class="header-anchor" href="#_11-1-开启慢查询日志" aria-label="Permalink to &quot;11.1 开启慢查询日志&quot;">​</a></h4><blockquote><p>通常情况下，为了定位sql的性能瓶颈，需要开启mysql的慢查询日志。把超过指定时间的sql语句，单独记录下来，方面以后分析和定位问题。</p><p>开启慢查询日志需要重点关注三个参数：</p><ul><li><p><code>slow_query_log</code> 慢查询开关</p></li><li><p><code>slow_query_log_file</code> 慢查询日志存放的路径</p></li><li><p><code>long_query_time</code> 超过多少秒才会记录日志</p></li></ul><p>通过mysql的<code>set</code>命令可以设置：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">set</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">global</span><span style="color:#E1E4E8;"> slow_query_log</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&#39;ON&#39;</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#F97583;">set</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">global</span><span style="color:#E1E4E8;"> slow_query_log_file</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&#39;/usr/local/mysql/data/slow.log&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">set</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">global</span><span style="color:#E1E4E8;"> long_query_time</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">set</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">global</span><span style="color:#24292E;"> slow_query_log</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&#39;ON&#39;</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#D73A49;">set</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">global</span><span style="color:#24292E;"> slow_query_log_file</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&#39;/usr/local/mysql/data/slow.log&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">set</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">global</span><span style="color:#24292E;"> long_query_time</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span></code></pre></div><p>设置完之后，如果某条sql的执行时间超过了2秒，会被自动记录到slow.log文件中。</p><p>当然也可以直接修改配置文件my.cnf （需要重启mysql服务）</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">[mysqld]</span></span>
<span class="line"><span style="color:#E1E4E8;">slow_query_log </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ON</span></span>
<span class="line"><span style="color:#E1E4E8;">slow_query_log_file </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">usr</span><span style="color:#F97583;">/local/</span><span style="color:#E1E4E8;">mysql</span><span style="color:#F97583;">/data/</span><span style="color:#79B8FF;">slow</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">log</span></span>
<span class="line"><span style="color:#E1E4E8;">long_query_time </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">[mysqld]</span></span>
<span class="line"><span style="color:#24292E;">slow_query_log </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ON</span></span>
<span class="line"><span style="color:#24292E;">slow_query_log_file </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">/</span><span style="color:#24292E;">usr</span><span style="color:#D73A49;">/local/</span><span style="color:#24292E;">mysql</span><span style="color:#D73A49;">/data/</span><span style="color:#005CC5;">slow</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">log</span></span>
<span class="line"><span style="color:#24292E;">long_query_time </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span></span></code></pre></div></blockquote><h4 id="_11-2-监控" tabindex="-1">11.2 监控 <a class="header-anchor" href="#_11-2-监控" aria-label="Permalink to &quot;11.2 监控&quot;">​</a></h4><blockquote><p>Prometheus</p><p>官方文档: <a href="https://prometheus.io/" target="_blank" rel="noreferrer">https://prometheus.io/</a></p><p>可以用它监控如下信息：</p><ul><li><p>接口响应时间</p></li><li><p>调用第三方服务耗时</p></li><li><p>慢查询sql耗时</p></li><li><p>cpu使用情况</p></li><li><p>内存使用情况</p></li><li><p>磁盘使用情况</p></li><li><p>数据库使用情况</p></li></ul></blockquote><h4 id="_11-3-链路跟踪" tabindex="-1">11.3 链路跟踪 <a class="header-anchor" href="#_11-3-链路跟踪" aria-label="Permalink to &quot;11.3 链路跟踪&quot;">​</a></h4><blockquote><p>skywalking</p><p>官网：<a href="https://skywalking.apache.org/" target="_blank" rel="noreferrer">https://skywalking.apache.org/</a></p><p>skywalking中可以通过<code>traceId</code>（全局唯一的id），串联一个接口请求的完整链路。</p></blockquote>`,57),i=[c];function d(h,y,u,E,q,b){return s(),l("div",null,i)}const m=a(r,[["render",d]]);export{k as __pageData,m as default};
