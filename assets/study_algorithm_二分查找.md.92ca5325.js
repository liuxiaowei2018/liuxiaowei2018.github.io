import{_ as a,c as e,o,N as t}from"./chunks/framework.0799945b.js";const r="/assets/image-20221201130819516.13226fd3.png",l="/assets/1b2db5cd444bb9d2d0b913b91bdded61.961fbc57.gif",f=JSON.parse('{"title":"数据结构","description":"","frontmatter":{},"headers":[],"relativePath":"study/algorithm/二分查找.md"}'),i={name:"study/algorithm/二分查找.md"},s=t('<h1 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#二分查找算法">二分查找算法</a><ul><li><a href="#原理">原理</a></li><li><a href="#局限性">局限性</a></li><li><a href="#实现">实现</a></li></ul></li></ul></nav><h2 id="二分查找算法" tabindex="-1">二分查找算法 <a class="header-anchor" href="#二分查找算法" aria-label="Permalink to &quot;二分查找算法&quot;">​</a></h2><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><p>二分查找（Binary Search）算法，也叫<code>折半查找</code>算法。二分查找的思想非常简单，有点类似分治的思想。二分查找针对的是一个有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p><p>以<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020" target="_blank" rel="noreferrer">数组</a><code>1, 2, 4, 5, 6, 7, 9, 12, 15, 19, 23, 26, 29, 34, 39</code>，在数组中查找<code>26</code>为例，制作了一张查找过程图，其中<code>low</code>标示左下标，<code>high</code>标示右下标，<code>mid</code>标示中间值下标</p><p><img src="'+r+'" alt="image-20221201130819516"></p><p>二分查找的过程就像上图一样，<code>如果中间值大于查找值，则往数组的左边继续查找，如果小于查找值这往右边继续查找</code>。</p><p>二分查找的思想虽然非常简单，但是查找速度非常长，<code>二分查找的时间复杂度为O(logn)</code>。虽然二分查找的时间复杂度为O(logn)但是比很多O(1)的速度都要快，因为O(1)可能标示一个非常大的数值，比例O(1000)。</p><p>​ 二分查找与遍历查找的效率对比图</p><p><img src="'+l+'" alt="img"></p><h3 id="局限性" tabindex="-1">局限性 <a class="header-anchor" href="#局限性" aria-label="Permalink to &quot;局限性&quot;">​</a></h3><h4 id="二分查找依赖数组结构" tabindex="-1">二分查找依赖数组结构 <a class="header-anchor" href="#二分查找依赖数组结构" aria-label="Permalink to &quot;二分查找依赖数组结构&quot;">​</a></h4><blockquote><p>二分查找需要利用下标随机访问元素，使用链表等其他数据结构则无法实现二分查找。</p></blockquote><h4 id="二分查找针对的是有序数据" tabindex="-1">二分查找针对的是有序数据 <a class="header-anchor" href="#二分查找针对的是有序数据" aria-label="Permalink to &quot;二分查找针对的是有序数据&quot;">​</a></h4><blockquote><p>二分查找需要的数据必须是有序的。如果数据没有序，需要先排序，排序的时间复杂度最低是 O(nlogn)。</p><p>所以如果针对的是一组静态的数据，没有频繁地插入、删除，可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p><p>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用</p></blockquote><h4 id="数据量太小或太大不适合二分查找" tabindex="-1">数据量太小或太大不适合二分查找 <a class="header-anchor" href="#数据量太小或太大不适合二分查找" aria-label="Permalink to &quot;数据量太小或太大不适合二分查找&quot;">​</a></h4><h3 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h3><h4 id="迭代实现" tabindex="-1">迭代实现 <a class="header-anchor" href="#迭代实现" aria-label="Permalink to &quot;迭代实现&quot;">​</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"></span></code></pre></div>',20),c=[s];function d(n,h,p,u,_,b){return o(),e("div",null,c)}const q=a(i,[["render",d]]);export{f as __pageData,q as default};
