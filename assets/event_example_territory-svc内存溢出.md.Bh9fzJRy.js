import{_ as a,c as e,o as t,a4 as o}from"./chunks/framework.PLIGnzYk.js";const u=JSON.parse('{"title":"生产事件","description":"","frontmatter":{},"headers":[],"relativePath":"event/example/territory-svc内存溢出.md","filePath":"event/example/territory-svc内存溢出.md","lastUpdated":1727778851000}'),i={name:"event/example/territory-svc内存溢出.md"},s=o('<h1 id="生产事件" tabindex="-1">生产事件 <a class="header-anchor" href="#生产事件" aria-label="Permalink to &quot;生产事件&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#territory-svc-omm">territory-svc OMM</a><ul><li><a href="#_1-1、问题描述">1.1、问题描述</a></li><li><a href="#_1-2、问题定位">1.2、问题定位</a></li><li><a href="#_1-3、解决方案">1.3、解决方案</a></li></ul></li></ul></nav><h2 id="territory-svc-omm" tabindex="-1">territory-svc OMM <a class="header-anchor" href="#territory-svc-omm" aria-label="Permalink to &quot;territory-svc OMM&quot;">​</a></h2><h3 id="_1-1、问题描述" tabindex="-1">1.1、问题描述 <a class="header-anchor" href="#_1-1、问题描述" aria-label="Permalink to &quot;1.1、问题描述&quot;">​</a></h3><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810952.png" alt="image-20230721171634888"></p><blockquote><p>容器stable/mdm-territory-svc-latest-56db9dbbb9-n8sw7 发生OMM 自动重启</p></blockquote><h3 id="_1-2、问题定位" tabindex="-1">1.2、问题定位 <a class="header-anchor" href="#_1-2、问题定位" aria-label="Permalink to &quot;1.2、问题定位&quot;">​</a></h3><ol><li><p>pod中java服务 territory-svc JVM参数如下：</p><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810995.png" alt="image-20230721173900736"></p></li><li><p>已配置-XX:+HeapDumpOnOutOfMemoryError，当发生内存溢出时，会自动dump文件。</p></li><li><p>运维工具将dump文件推送至OSS</p></li><li><p>OK! 那我们直接把DUMP文件下载下来，分析一下！</p></li></ol><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810382.png" alt="image-20230721172159999"></p><p><code>将DUMP文件导入MAT进行分析</code></p><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810085.png" alt="image-20230721172247250"></p><blockquote><p>到这里能大概猜测到是在操作数据库的时候数据量太大导致堆内存溢出</p></blockquote><p><code>通过Histogram定位大内存对象</code></p><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810976.png" alt="image-20230721172442785"></p><blockquote><p>这里发现了一个我们业务中定义的对象 com.softium.territory.tery.po.TerritoryDepartmentPO</p></blockquote><p><code>通过tread_overview定位线程</code></p><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810857.png" alt="image-20230721172610335"></p><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810686.png" alt="image-20230721172732275"></p><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810910.png" alt="image-20230721172746177"></p><blockquote><p>查看线程堆栈 这里我们可以通过搜索 业务代码中的包名 来定位业务代码</p></blockquote><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810692.png" alt="image-20230721173029986"></p><blockquote><p>到这里我们定位到出现问题的代码了 我们看一下这段代码</p></blockquote><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011812000.png" alt="image-20230721173329345"></p><blockquote><p>显然，这里查询数据库时遇到极端条件，导致大量数据查询甚至全表查询，方法内返回的 List TerritoryDepartmentPO对象很大</p></blockquote><h3 id="_1-3、解决方案" tabindex="-1">1.3、解决方案 <a class="header-anchor" href="#_1-3、解决方案" aria-label="Permalink to &quot;1.3、解决方案&quot;">​</a></h3><h4 id="代码优化" tabindex="-1">代码优化 <a class="header-anchor" href="#代码优化" aria-label="Permalink to &quot;代码优化&quot;">​</a></h4><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011811328.png" alt="image-20230721174144645"></p><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011811862.png" alt="image-20230721174157701"></p><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011810947.png" alt="image-20230721174400683"></p><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011811469.png" alt="image-20230721174555334"></p><blockquote><p>1.这里返回参数需要的只有 productIds ，显然没有必要去查表的所有字段</p><p>2.jvm内存去重 改为数据库去重 ，把压力传递给数据库</p><p>3.查询命中了数据库索引了，虽然这次的问题瓶颈不在数据库，这里我们只返回product_id字段后 使用了 索引下推 ，顺便给数据库做了一波优化</p></blockquote><h4 id="jvm优化" tabindex="-1">JVM优化 <a class="header-anchor" href="#jvm优化" aria-label="Permalink to &quot;JVM优化&quot;">​</a></h4><p>考虑是否要重新合理分配一下 该POD JVM 堆内存</p><blockquote><p>-Xms2048m -Xmx4096m</p></blockquote><p><code>解决问题！</code></p>',35),c=[s];function r(l,n,p,m,h,g){return t(),e("div",null,c)}const _=a(i,[["render",r]]);export{u as __pageData,_ as default};
