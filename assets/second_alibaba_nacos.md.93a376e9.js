import{_ as a,o as e,c as o,Q as i}from"./chunks/framework.8048b864.js";const r="/assets/image-20220909170526705.ff64ab80.png",c="/assets/image-20220909170632059.3bb00a9d.png",s="/assets/image-20220909170852667.42756cb7.png",t="/assets/image-20220909172040657.012e4b10.png",l="/assets/image-20220909172232717.dd363504.png",N=JSON.parse('{"title":"Nacos","description":"","frontmatter":{},"headers":[],"relativePath":"second/alibaba/nacos.md","filePath":"second/alibaba/nacos.md","lastUpdated":1698401521000}'),n={name:"second/alibaba/nacos.md"},d=i('<h1 id="nacos" tabindex="-1">Nacos <a class="header-anchor" href="#nacos" aria-label="Permalink to &quot;Nacos&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#_1、nacos入门">1、Nacos入门</a></li><li><a href="#_2、nacos应用">2、Nacos应用</a><ul><li><a href="#_2-1、动态刷新配置">2.1、动态刷新配置</a></li></ul></li><li><a href="#_3、nacos扩展">3、Nacos扩展</a><ul><li><a href="#_3-1、nacos架构">3.1、Nacos架构</a></li></ul></li></ul></nav><h2 id="_1、nacos入门" tabindex="-1">1、Nacos入门 <a class="header-anchor" href="#_1、nacos入门" aria-label="Permalink to &quot;1、Nacos入门&quot;">​</a></h2><h2 id="_2、nacos应用" tabindex="-1">2、Nacos应用 <a class="header-anchor" href="#_2、nacos应用" aria-label="Permalink to &quot;2、Nacos应用&quot;">​</a></h2><h3 id="_2-1、动态刷新配置" tabindex="-1">2.1、动态刷新配置 <a class="header-anchor" href="#_2-1、动态刷新配置" aria-label="Permalink to &quot;2.1、动态刷新配置&quot;">​</a></h3><h4 id="refreshscope" tabindex="-1">@RefreshScope <a class="header-anchor" href="#refreshscope" aria-label="Permalink to &quot;@RefreshScope&quot;">​</a></h4><p><code>@RefreshScope</code>是Spring Cloud 提供的注解，可以看到它就是通过<code>Spring</code> 的作用域来实现的。</p><h4 id="nacosvalue" tabindex="-1">@NacosValue <a class="header-anchor" href="#nacosvalue" aria-label="Permalink to &quot;@NacosValue&quot;">​</a></h4><p><code>@NacosValue </code>在<code>Spring Cloud</code>并不能直接使用，只是为了在纯<code>Spring </code>环境中方便集成配置中心，<code>Spring Cloud</code>环境下使用其本身推荐的方式。<strong>并不推荐使用</strong></p><h2 id="_3、nacos扩展" tabindex="-1">3、Nacos扩展 <a class="header-anchor" href="#_3、nacos扩展" aria-label="Permalink to &quot;3、Nacos扩展&quot;">​</a></h2><h3 id="_3-1、nacos架构" tabindex="-1">3.1、Nacos架构 <a class="header-anchor" href="#_3-1、nacos架构" aria-label="Permalink to &quot;3.1、Nacos架构&quot;">​</a></h3><p><img src="'+r+'" alt="image-20220909170526705"></p><blockquote><ul><li>Provider APP：服务提供者</li><li>Consumer APP：服务消费者</li><li>Name Server：通过VIP（Virtual IP）或DNS的方式实现Nacos高可用集群的服务路由</li><li>Nacos Server：Nacos服务提供者，里面包含的Open API是功能访问入口，Conig Service、Naming Service 是Nacos提供的配置服务、命名服务模块。Consitency Protocol是一致性协议，用来实现Nacos集群节点的数据同步，这里使用的是Raft算法（Etcd、Redis哨兵选举）</li><li>Nacos Console：控制台</li></ul></blockquote><h4 id="_3-1-1、注册中心" tabindex="-1">3.1.1、注册中心 <a class="header-anchor" href="#_3-1-1、注册中心" aria-label="Permalink to &quot;3.1.1、注册中心&quot;">​</a></h4><h5 id="_3-1-1-1、原理图" tabindex="-1">3.1.1.1、原理图 <a class="header-anchor" href="#_3-1-1-1、原理图" aria-label="Permalink to &quot;3.1.1.1、原理图&quot;">​</a></h5><ul><li>服务实例在启动时注册到服务注册表，并在关闭时注销</li><li>服务消费者查询服务注册表，获得可用实例</li><li>服务注册中心需要调用服务实例的健康检查API来验证它是否能够处理请求</li></ul><p><img src="'+c+'" alt="image-20220909170632059"></p><h5 id="_3-1-1-2、注册流程" tabindex="-1">3.1.1.2、注册流程 <a class="header-anchor" href="#_3-1-1-2、注册流程" aria-label="Permalink to &quot;3.1.1.2、注册流程&quot;">​</a></h5><p>在Spring-Cloud-Common包中有一个类<code>org.springframework.cloud. client.serviceregistry .ServiceRegistry</code> ,它是Spring Cloud提供的服务注册的标准。集成到Spring Cloud中实现服务注册的组件,都会实现该接口。该接口有一个实现类是<code>NacoServiceRegistry</code></p><p>SpringCloud集成Nacos的实现过程：</p><p>在spring-clou-commons包的META-INF/spring.factories中包含自动装配的配置信息如下：</p><p>其中AutoServiceRegistrationAutoConfiguration就是服务注册相关的配置类：</p><p><img src="'+s+'" alt="image-20220909170852667"></p><p>在AutoServiceRegistrationAutoConfiguration配置类中,注入了一个AutoServiceRegistration实例</p><p>AbstractAutoServiceRegistration抽象类实现了该接口,并且最重要的是NacosAutoServiceRegistration继承了AbstractAutoServiceRegistration。</p><p>Nacos是通过Spring的事件机制继承到SpringCloud中去的</p><p>AbstractAutoServiceRegistration实现了onApplicationEvent抽象方法,并且监听WebServerInitializedEvent事件(当Webserver初始化完成之后) , 调用this.bind ( event )方法。</p><p>最终会调用NacosServiceREgistry.register()方法进行服务注册。</p><h5 id="_3-1-1-3、心跳机制" tabindex="-1">3.1.1.3、心跳机制 <a class="header-anchor" href="#_3-1-1-3、心跳机制" aria-label="Permalink to &quot;3.1.1.3、心跳机制&quot;">​</a></h5><p>心跳机制就是客户端通过schedule定时向服务端发送一个数据包 ,然后启动-个线程不断检测服务端的回应,如果在设定时间内没有收到服务端的回应,则认为服务器出现了故障。Nacos服务端会根据客户端的心跳包不断更新服务的状态。</p><p>总结：</p><ul><li><p>Nacos客户端通过Open API的形式发送服务注册请求</p></li><li><p>Nacos服务端收到请求后，做以下三件事：</p></li><li><ol><li>构建一个Service对象保存到ConcurrentHashMap集合中</li><li>使用定时任务对当前服务下的所有实例建立心跳检测机制</li><li>基于数据一致性协议服务数据进行同步</li></ol></li></ul><h4 id="_3-1-2、配置中心" tabindex="-1">3.1.2、配置中心 <a class="header-anchor" href="#_3-1-2、配置中心" aria-label="Permalink to &quot;3.1.2、配置中心&quot;">​</a></h4><h5 id="_3-1-2-1、推拉模型" tabindex="-1">3.1.2.1、推拉模型 <a class="header-anchor" href="#_3-1-2-1、推拉模型" aria-label="Permalink to &quot;3.1.2.1、推拉模型&quot;">​</a></h5><h6 id="推模型" tabindex="-1">推模型 <a class="header-anchor" href="#推模型" aria-label="Permalink to &quot;推模型&quot;">​</a></h6><p>客户端与服务端建立<code>TCP</code>长连接，当服务端配置数据有变动，立刻通过建立的长连接将数据推送给客户端。</p><p>优势：长链接的优点是实时性，一旦数据变动，立即推送变更数据给客户端，而且对于客户端而言，这种方式更为简单，只建立连接接收数据，并不需要关心是否有数据变更这类逻辑的处理。</p><p>弊端：长连接可能会因为网络问题，导致不可用，也就是俗称的<code>假死</code>。连接状态正常，但实际上已无法通信，所以要有的心跳机制<code>KeepAlive</code>来保证连接的可用性，才可以保证配置数据的成功推送。</p><h6 id="拉模型" tabindex="-1">拉模型 <a class="header-anchor" href="#拉模型" aria-label="Permalink to &quot;拉模型&quot;">​</a></h6><p>客户端主动的向服务端发请求拉配置数据，常见的方式就是轮询，比如每3s向服务端请求一次配置数据。</p><p>轮询的优点是实现比较简单。但弊端也显而易见，轮询无法保证数据的实时性，什么时候请求？间隔多长时间请求一次？都是不得不考虑的问题，而且轮询方式对服务端还会产生不小的压力。</p><h5 id="_3-1-2-2、nacos长轮询" tabindex="-1">3.1.2.2、Nacos长轮询 <a class="header-anchor" href="#_3-1-2-2、nacos长轮询" aria-label="Permalink to &quot;3.1.2.2、Nacos长轮询&quot;">​</a></h5><p><code>nacos</code>采用的是客户端主动拉<code>pull</code>模型，应用长轮询（<code>Long Polling</code>）的方式来获取配置数据。</p><blockquote><p><strong>长轮询</strong></p><p>客户端发起请求后，服务端不会立即返回请求结果，而是将请求挂起等待一段时间，如果此段时间内服务端数据变更，立即响应客户端请求，若是一直无变化则等到指定的超时时间后响应请求，客户端重新发起长链接。</p><p><img src="'+t+'" alt="image-20220909172040657"></p></blockquote><h5 id="_3-1-2-3、架构设计" tabindex="-1">3.1.2.3、架构设计 <a class="header-anchor" href="#_3-1-2-3、架构设计" aria-label="Permalink to &quot;3.1.2.3、架构设计&quot;">​</a></h5><p>客户端、控制台通过发送Http请求将配置数据注册到服务端，服务端持久化数据到Mysql。</p><p>客户端拉取配置数据，并批量设置对<code>dataId</code>的监听发起长轮询请求，如服务端配置项变更立即响应请求，如无数据变更则将请求挂起一段时间，直到达到超时时间。为减少对服务端压力以及保证配置中心可用性，拉取到配置数据客户端会保存一份快照在本地文件中，优先读取。</p><p><img src="'+l+'" alt="image-20220909172232717"></p>',48),h=[d];function p(u,_,b,g,m,f){return e(),o("div",null,h)}const S=a(n,[["render",p]]);export{N as __pageData,S as default};
