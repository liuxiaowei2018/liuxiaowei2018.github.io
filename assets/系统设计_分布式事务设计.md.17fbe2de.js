import{_ as a,o as l,c as i,Q as e}from"./chunks/framework.8048b864.js";const m=JSON.parse('{"title":"分布式事务设计","description":"","frontmatter":{},"headers":[],"relativePath":"系统设计/分布式事务设计.md","filePath":"系统设计/分布式事务设计.md","lastUpdated":null}'),o={name:"系统设计/分布式事务设计.md"},r=e('<h1 id="分布式事务设计" tabindex="-1">分布式事务设计 <a class="header-anchor" href="#分布式事务设计" aria-label="Permalink to &quot;分布式事务设计&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#事务概述">事务概述</a><ul><li><a href="#本地事务">本地事务</a></li><li><a href="#cap定理">CAP定理</a></li><li><a href="#base理论">Base理论</a></li></ul></li><li><a href="#分布式事务方案">分布式事务方案</a><ul><li><a href="#_2阶段提交-2pc">2阶段提交（2PC）</a></li><li><a href="#_3阶段提交-3pc">3阶段提交（3PC）</a></li><li><a href="#tcc-事务补偿">TCC(事务补偿)</a></li><li><a href="#本地消息表">本地消息表</a></li><li><a href="#mq事务方案-可靠消息事务">MQ事务方案（可靠消息事务）</a></li><li><a href="#最大努力通知">最大努力通知</a></li><li><a href="#saga-事务">Saga 事务</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#分布式事务应用">分布式事务应用</a><ul><li><a href="#springboot-事务">SpringBoot 事务</a></li><li><a href="#seata">Seata</a></li></ul></li></ul></nav><h2 id="事务概述" tabindex="-1">事务概述 <a class="header-anchor" href="#事务概述" aria-label="Permalink to &quot;事务概述&quot;">​</a></h2><h3 id="本地事务" tabindex="-1">本地事务 <a class="header-anchor" href="#本地事务" aria-label="Permalink to &quot;本地事务&quot;">​</a></h3><h4 id="基本性质" tabindex="-1">基本性质 <a class="header-anchor" href="#基本性质" aria-label="Permalink to &quot;基本性质&quot;">​</a></h4><p>数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation)和持久性(Durabilily)，简称就是 ACID；</p><ul><li>原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败</li><li>一致性：数据在事务的前后，业务整体一致。 <ul><li>转账。A:1000；B:1000； 转 200 事务成功; A：800 B：1200</li></ul></li><li>隔离性：事务之间互相隔离。</li><li>持久性：一旦事务成功，数据一定会落盘在数据库。</li></ul><h4 id="隔离级别" tabindex="-1">隔离级别 <a class="header-anchor" href="#隔离级别" aria-label="Permalink to &quot;隔离级别&quot;">​</a></h4><ul><li><p>READ UNCOMMITTED（读未提交） 该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读</p></li><li><p>READ COMMITTED（读提交）</p><p>一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。</p></li><li><p>REPEATABLE READ（可重复读）</p><p>该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL的 InnoDB 引擎可以通过 next-key locks 机制（行锁算法）来避免幻读。</p></li><li><p>SERIALIZABLE（序列化）</p><p>在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。</p></li></ul><h4 id="传播行为" tabindex="-1">传播行为 <a class="header-anchor" href="#传播行为" aria-label="Permalink to &quot;传播行为&quot;">​</a></h4><p>1、PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。 2、PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。 3、PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。 4、PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。 5、PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 6、PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 7、PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作</p><h3 id="cap定理" tabindex="-1">CAP定理 <a class="header-anchor" href="#cap定理" aria-label="Permalink to &quot;CAP定理&quot;">​</a></h3><p>CAP定理，同时又被称作布鲁尔定理（Brewer&#39;s theorem），指的是在一个分布式系统中，<strong>不可能同时满足以下三点</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301805175.png" alt="image-20220406191413988"></p><h4 id="一致性" tabindex="-1">一致性 <a class="header-anchor" href="#一致性" aria-label="Permalink to &quot;一致性&quot;">​</a></h4><p>Consistency 指强一致性，在写操作完成后开始的任何读操作都必须返回该值，或者后续写操作的结果。</p><blockquote><p>也就是说，在一致性系统中，一旦客户端将值写入任何一台服务器并获得响应，那么之后client从其他任何服务器读取的都是刚写入的数据</p><p>一致性保证了不管向哪台服务器写入数据，其他的服务器能实时同步数据</p></blockquote><h4 id="可用性" tabindex="-1">可用性 <a class="header-anchor" href="#可用性" aria-label="Permalink to &quot;可用性&quot;">​</a></h4><p>Availability 可用性（高可用）是指：每次向未崩溃的节点发送请求，总能保证收到响应数据（允许不是最新数据）</p><h4 id="分区容错性" tabindex="-1">分区容错性 <a class="header-anchor" href="#分区容错性" aria-label="Permalink to &quot;分区容错性&quot;">​</a></h4><p>Partition tolerance 分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，也就是说，服务器<strong>A</strong>和<strong>B</strong>发送给对方的任何消息都是可以放弃的，也就是说A和B可能因为各种意外情况，导致无法成功进行同步，分布式系统要能容忍这种情况。除非整个网络环境都发生了故障。</p><blockquote><p>为什么只能在A和C之间做出取舍？</p></blockquote><p>分布式系统中，必须满足 CAP 中的 P，此时只能在 C/A 之间作出取舍。</p><p>如果选择了<strong>CA</strong>，舍弃了P，说白了就是一个单体架构。</p><h4 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h4><p><strong>CAP理论</strong>告诉我们只能在C、A之间选择，在分布式事务的最终解决方案中一般选择牺牲一致性来获取可用性和分区容错性。</p><blockquote><p>这里的 “牺牲一致性” 并不是完全放弃数据的一致性，而是放弃<strong>强一致性</strong>而换取<strong>弱一致性</strong>。</p></blockquote><p>一致性可以分为以下三种：</p><ul><li>强一致性</li><li>弱一致性</li><li>最终一致性</li></ul><h5 id="强一致性" tabindex="-1">强一致性 <a class="header-anchor" href="#强一致性" aria-label="Permalink to &quot;强一致性&quot;">​</a></h5><p>系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值。</p><p>也称为：原子一致性（Atomic Consistency）、线性一致性（Linearizable Consistency）</p><p>简言之，在任意时刻，所有节点中的数据是一样的。例如，对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。</p><p><strong>总结</strong>：</p><ul><li>一个集群需要对外部提供强一致性，所以只要集群内部某一台服务器的数据发生了改变，那么就需要等待集群内其他服务器的数据同步完成后，才能正常的对外提供服务。</li><li>保证了强一致性，务必会损耗<strong>可用性</strong>。</li></ul><h5 id="弱一致性" tabindex="-1">弱一致性 <a class="header-anchor" href="#弱一致性" aria-label="Permalink to &quot;弱一致性&quot;">​</a></h5><p>系统中的某个数据被更新后，后续对该数据的读取操作<strong>可能</strong>得到更新后的值，也可能是更改前的值。但即使过了<strong>不一致时间窗口</strong>这段时间后，后续对该数据的读取也不一定是最新值。可以理解为数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。</p><h5 id="最终一致性" tabindex="-1">最终一致性 <a class="header-anchor" href="#最终一致性" aria-label="Permalink to &quot;最终一致性&quot;">​</a></h5><p>是弱一致性的<strong>特殊</strong>形式，存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值。</p><p>不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。</p><p>简单说，就是在一段时间后，节点间的数据会最终达到一致状态。</p><h3 id="base理论" tabindex="-1">Base理论 <a class="header-anchor" href="#base理论" aria-label="Permalink to &quot;Base理论&quot;">​</a></h3><p>BASE理论是对<strong>CAP</strong>中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><h4 id="ba" tabindex="-1">BA <a class="header-anchor" href="#ba" aria-label="Permalink to &quot;BA&quot;">​</a></h4><p>(Basic Available)基本可用</p><p>整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。这里是属于基本可用。</p><p>基本可用和高可用的区别：</p><ul><li>“一定时间”可以适当延长 当举行大促（比如秒杀）时，响应时间可以适当延长</li><li>给部分用户返回一个降级页面 给部分用户直接返回一个<strong>降级页面</strong>，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。</li></ul><h4 id="s-soft-state" tabindex="-1">S(Soft State) <a class="header-anchor" href="#s-soft-state" aria-label="Permalink to &quot;S(Soft State)&quot;">​</a></h4><p>柔性状态，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程存在延时。</p><h4 id="e-eventual-consisstency" tabindex="-1">E(Eventual Consisstency) <a class="header-anchor" href="#e-eventual-consisstency" aria-label="Permalink to &quot;E(Eventual Consisstency)&quot;">​</a></h4><p>最终一致性</p><p>同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。</p><h2 id="分布式事务方案" tabindex="-1">分布式事务方案 <a class="header-anchor" href="#分布式事务方案" aria-label="Permalink to &quot;分布式事务方案&quot;">​</a></h2><p>在分布式架构下，每个节点只知晓自己操作的失败或者成功，无法得知其他节点的状态。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个<strong>协调者</strong>来统一掌控所有<strong>参与者</strong>的操作结果，并指示它们是否要把操作结果进行真正的<strong>提交</strong>或者<strong>回滚</strong>（rollback）。</p><h3 id="_2阶段提交-2pc" tabindex="-1">2阶段提交（2PC） <a class="header-anchor" href="#_2阶段提交-2pc" aria-label="Permalink to &quot;2阶段提交（2PC）&quot;">​</a></h3><p>二阶段提交协议（Two-phase Commit，即 2PC）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理。</p><p>两个阶段分别为：</p><ul><li>准备阶段</li><li>提交阶段</li></ul><p>参与的角色：</p><ul><li>事务协调者（事务管理器）：事务的发起者</li><li>事务参与者（资源管理器）：事务的执行者</li></ul><h5 id="准备阶段-投票阶段" tabindex="-1">准备阶段（投票阶段） <a class="header-anchor" href="#准备阶段-投票阶段" aria-label="Permalink to &quot;准备阶段（投票阶段）&quot;">​</a></h5><p>这是两阶段的第一段，这一阶段只是准备阶段，由事务的协调者发起询问参与者是否可以提交事务，但是这一阶段并未提交事务，流程图如下图：</p><ol><li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复</li><li>各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）</li><li>如参与者执行成功，给协调者反馈<strong>同意</strong>，否则反馈<strong>中止</strong></li></ol><h5 id="提交阶段" tabindex="-1">提交阶段 <a class="header-anchor" href="#提交阶段" aria-label="Permalink to &quot;提交阶段&quot;">​</a></h5><p>这一段阶段属于2PC的第二阶段（提交 执行阶段），协调者发起正式提交事务的请求，当所有参与者都回复同意时，则意味着完成事务，流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811397.png" alt="图片"></p><ol><li>协调者节点向所有参与者节点发出<strong>正式提交</strong>(<code>commit</code>)的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送<strong>ack完成</strong>消息。</li><li>协调者节点收到所有参与者节点反馈的<strong>ack完成</strong>消息后，完成事务。</li></ol><p>但是如果任意一个参与者节点在<strong>第一阶段</strong>返回的消息为<strong>终止</strong>，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时，那么这个事务将会被回滚，回滚的流程图如下：<img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811951.png" alt="图片"></p><ol><li>协调者节点向所有参与者节点发出<strong>回滚操作</strong>(<code>rollback</code>)的请求。</li><li>参与者节点利用阶段1写入的undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送<strong>ack回滚完成</strong>消息。</li><li>协调者节点受到所有参与者节点反馈的<strong>ack回滚完成</strong>消息后，取消事务。</li></ol><p><strong>不管最后结果如何，第二阶段都会结束当前事务。</strong></p><p>二阶段提交的<strong>事务正常提交</strong>的完整流程如下图：<img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301812984.png" alt="图片"></p><p>二阶段提交事务<strong>回滚</strong>的完整流程如下图：<img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811552.png" alt="图片"></p><blockquote><p>举个<strong>百米赛跑</strong>的例子来具体描述下2PC的流程：学校运动会，有三个同学，分别是A，B，C，2PC流程如下：</p><ul><li>裁判：A同学准备好了吗？准备进入第一赛道....</li><li>裁判：B同学准备好了吗？准备进入第一赛道....</li><li>裁判：C同学准备好了吗？准备进入第一赛道....</li><li>如果有任意一个同学没准备好，则裁判下达<strong>回滚</strong>指令</li><li>如果裁判收到了所有同学的OK回复，则再次下令跑......</li><li>裁判：1,2,3 跑............</li><li>A同学冲刺到终点，汇报给裁判</li><li>B，C同学冲刺失败，汇报给裁判</li></ul></blockquote><h5 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h5><h6 id="_2pc的缺点" tabindex="-1">2PC的缺点 <a class="header-anchor" href="#_2pc的缺点" aria-label="Permalink to &quot;2PC的缺点&quot;">​</a></h6><ul><li><strong>性能问题</strong>：执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li><li><strong>可靠性问题</strong>：参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。</li><li><strong>数据一致性问题</strong>：二阶段无法解决的问题：协调者在发出<code>commit</code>消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li><li><strong>实现复杂</strong>：牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</li></ul><h6 id="_2pc的优点" tabindex="-1">2PC的优点 <a class="header-anchor" href="#_2pc的优点" aria-label="Permalink to &quot;2PC的优点&quot;">​</a></h6><ul><li>尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）</li></ul><h3 id="_3阶段提交-3pc" tabindex="-1">3阶段提交（3PC） <a class="header-anchor" href="#_3阶段提交-3pc" aria-label="Permalink to &quot;3阶段提交（3PC）&quot;">​</a></h3><p>三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点。</p><ul><li>在协调者和参与者中都引入超时机制</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ul><p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段。处理流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811495.png" alt="图片"></p><h5 id="阶段一-cancommit阶段" tabindex="-1">阶段一：CanCommit阶段 <a class="header-anchor" href="#阶段一-cancommit阶段" aria-label="Permalink to &quot;阶段一：CanCommit阶段&quot;">​</a></h5><p>3PC的<code>CanCommit</code>阶段其实和2PC的准备阶段很像。协调者向参与者发送<code>commit</code>请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><ul><li>事务询问：协调者向所有参与者发出包含事务内容的 <code>canCommit</code> 请求，询问是否可以提交事务，并等待所有参与者答复。</li><li>响应反馈：参与者收到 <code>canCommit</code> 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</li></ul><p>CanCommit阶段流程如下图：<img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811182.png" alt="图片"></p><h5 id="阶段二-precommit阶段" tabindex="-1">阶段二：PreCommit阶段 <a class="header-anchor" href="#阶段二-precommit阶段" aria-label="Permalink to &quot;阶段二：PreCommit阶段&quot;">​</a></h5><p>协调者根据参与者的反应情况来决定是否可以进行事务的<code>PreCommit</code>操作。根据响应情况，有以下两种可能。</p><ul><li><p>假如所有参与者均反馈 <strong>yes</strong>，协调者预执行事务。</p></li><li><ol><li>发送预提交请求 ：协调者向参与者发送<code>PreCommit</code>请求，并进入准备阶段</li><li>事务预提交 ：参与者接收到<code>PreCommit</code>请求后，会执行事务操作，并将<code>undo</code>和<code>redo</code>信息记录到事务日志中（但不提交事务）</li><li>响应反馈 ：如果参与者成功的执行了事务操作，则返回<strong>ACK</strong>响应，同时开始等待最终指令。<img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811903.png" alt="图片"></li></ol></li><li><p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p></li><li><ol><li>发送中断请求 ：协调者向所有参与者发送<code>abort</code>请求。</li><li>中断事务 ：参与者收到来自协调者的<code>abort</code>请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。<img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811991.png" alt="图片"></li></ol></li></ul><h5 id="阶段三-docommit阶段" tabindex="-1">阶段三：doCommit阶段 <a class="header-anchor" href="#阶段三-docommit阶段" aria-label="Permalink to &quot;阶段三：doCommit阶段&quot;">​</a></h5><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p><blockquote><p>进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 do Commit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p></blockquote><ul><li><p><strong>执行提交</strong></p></li><li><ol><li>发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送<code>doCommit</code>请求。</li><li>事务提交 参与者接收到<code>doCommit</code>请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li><li>响应反馈 事务提交完之后，向协调者发送ack响应。</li><li>完成事务 协调者接收到所有参与者的ack响应之后，完成事务。<img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811261.png" alt="图片"></li></ol></li><li><p><strong>中断事务</strong>：任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务</p></li><li><ol><li>发送中断请求 如果协调者处于工作状态，向所有参与者发出 abort 请求</li><li>事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li><li>反馈结果 参与者完成事务回滚之后，向协调者反馈ACK消息</li><li>中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。<img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811350.png" alt="图片"></li></ol></li></ul><h5 id="优缺点-1" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点-1" aria-label="Permalink to &quot;优缺点&quot;">​</a></h5><h6 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h6><p>相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。</p><h6 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h6><p>数据不一致问题依然存在，当在参与者收到 <code>preCommit</code> 请求后等待 <code>doCommit</code> 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p><h3 id="tcc-事务补偿" tabindex="-1">TCC(事务补偿) <a class="header-anchor" href="#tcc-事务补偿" aria-label="Permalink to &quot;TCC(事务补偿)&quot;">​</a></h3><p>TCC（Try Confirm Cancel）方案是一种应用层面侵入业务的两阶段提交。是目前最火的一种柔性事务方案，其核心思想是：<strong>针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作</strong>。</p><p>TCC分为两个阶段，分别如下：</p><ul><li><p>第一阶段：Try（尝试），主要是对业务系统做检测及资源预留 <strong>(加锁，锁住资源)</strong></p></li><li><p>第二阶段：本阶段根据第一阶段的结果，决定是执行confirm还是cancel</p><ul><li>1.Confirm（确认）：执行真正的业务（执行业务，释放锁）</li><li>2.Cancle（取消）：是预留资源的取消（出问题，释放锁）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811728.png" alt="image-20220406192816289"></p></li></ul><p>以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。</p><p>假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。</p><h5 id="_1try-阶段" tabindex="-1">①Try 阶段 <a class="header-anchor" href="#_1try-阶段" aria-label="Permalink to &quot;①Try 阶段&quot;">​</a></h5><p>TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p><ul><li>完成所有业务检查( 一致性 ) 。</li><li>预留必须业务资源( 准隔离性 ) 。</li><li>Try 尝试执行业务。</li></ul><h5 id="_2confirm-cancel-阶段" tabindex="-1">②Confirm / Cancel 阶段 <a class="header-anchor" href="#_2confirm-cancel-阶段" aria-label="Permalink to &quot;②Confirm / Cancel 阶段&quot;">​</a></h5><p>根据 <strong>Try</strong> 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。</p><p>Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。</p><p>Confirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作，业务如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811838.png" alt="图片"></p><p>这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。</p><p>Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。</p><p>Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段，业务如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301811159.png" alt="图片"></p><p>Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。</p><h5 id="最终一致性保证" tabindex="-1">最终一致性保证 <a class="header-anchor" href="#最终一致性保证" aria-label="Permalink to &quot;最终一致性保证&quot;">​</a></h5><ul><li>TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。</li><li>Try阶段执行成功并开始执行 <code>Confirm</code>阶段时，默认 <code>Confirm</code>阶段是不会出错的。也就是说只要<code>Try</code>成功，<code>Confirm</code>一定成功（TCC设计之初的定义） 。</li><li>Confirm与Cancel如果失败，由TCC框架进行==重试==补偿</li><li>存在极低概率在CC环节彻底失败，则需要定时任务或人工介入</li></ul><h5 id="优缺点-2" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点-2" aria-label="Permalink to &quot;优缺点&quot;">​</a></h5><p>TCC 事务机制相对于传统事务机制（X/Open XA），TCC 事务机制相比XA 事务机制，有以下优点：</p><ul><li>性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</li><li>数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li><li>可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li></ul><p>缺点：</p><ul><li>TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</li></ul><h3 id="本地消息表" tabindex="-1">本地消息表 <a class="header-anchor" href="#本地消息表" aria-label="Permalink to &quot;本地消息表&quot;">​</a></h3><blockquote><p>核心思路是将分布式事务拆分成本地事务进行处理。</p></blockquote><p>角色：</p><ul><li>事务主动方</li><li>事务被动方</li></ul><p>通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p><p>这样可以避免以下两种情况导致的数据不一致性：</p><ul><li>业务处理成功、事务消息发送失败</li><li>业务处理失败、事务消息发送成功</li></ul><p>整体的流程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301810191.png" alt="image-20220406194322701">息表</p><p>上图中整体的处理步骤如下：</p><ul><li>①：事务主动方在同一个本地事务中处理业务和写消息表操作</li><li>②：事务主动方通过消息中间件，通知事务被动方处理事务通知事务待消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。</li><li>③：事务被动方通过消息中间件，通知事务主动方事务已处理的消息。</li><li>④：事务主动方接收中间件的消息，更新消息表的状态为已处理。</li></ul><p>一些必要的容错处理如下：</p><ul><li>当①处理出错，由于还在事务主动方的本地事务中，直接回滚即可</li><li>当②、③处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，事务被动方重新读取消息处理业务即可。</li><li>如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务</li><li>如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务主动方进行回滚事务。</li></ul><h5 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h5><ul><li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。</li><li>方案轻量，容易实现。</li></ul><h5 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h5><ul><li>与具体的业务场景绑定，耦合性强，不可公用。</li><li>消息数据与业务数据同库，占用业务系统资源。</li><li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</li></ul><h3 id="mq事务方案-可靠消息事务" tabindex="-1">MQ事务方案（可靠消息事务） <a class="header-anchor" href="#mq事务方案-可靠消息事务" aria-label="Permalink to &quot;MQ事务方案（可靠消息事务）&quot;">​</a></h3><p>基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。</p><p>MQ事务方案整体流程和本地消息表的流程很相似，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301810750.png" alt="图片"></p><p>从上图可以看出和本地消息表方案唯一不同就是将本地消息表存在了MQ内部，而不是业务数据库中。</p><p>那么MQ内部的处理尤为重要，下面主要基于 RocketMQ 4.3 之后的版本介绍 MQ 的分布式事务方案。</p><p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ提供了 2PC 的提交接口，方案如下：</p><p><strong>正常情况：事务主动方发消息</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301810070.png" alt="图片"></p><p>这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p><ul><li>步骤①：发送方向 MQ 服务端(MQ Server)发送 half 消息。</li><li>步骤②：MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功。</li><li>步骤③：发送方开始执行本地事务逻辑。</li><li>步骤④：发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</li><li>步骤⑤：MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</li></ul><p><strong>异常情况：事务主动方消息恢复</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301810222.png" alt="图片"></p><p>在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：</p><ul><li>步骤⑤：MQ Server 对该消息发起消息回查。</li><li>步骤⑥：发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li><li>步骤⑦：发送方根据检查得到的本地事务的最终状态再次提交二次确认。</li><li>步骤⑧：MQ Server基于 commit/rollback 对消息进行投递或者删除。</li></ul><h5 id="优点-2" tabindex="-1">优点 <a class="header-anchor" href="#优点-2" aria-label="Permalink to &quot;优点&quot;">​</a></h5><p>相比本地消息表方案，MQ 事务方案优点是：</p><ul><li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li><li>吞吐量大于使用本地消息表方案。</li></ul><h5 id="缺点-2" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;缺点&quot;">​</a></h5><ul><li>一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 。</li><li>业务处理服务需要实现消息状态回查接口。</li></ul><h3 id="最大努力通知" tabindex="-1">最大努力通知 <a class="header-anchor" href="#最大努力通知" aria-label="Permalink to &quot;最大努力通知&quot;">​</a></h3><p>最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取。</p><p>最大努力通知的整体流程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301810342.png" alt="图片"></p><p>在可靠消息事务中，事务主动方需要将消息发送出去，并且消息接收方成功接收，这种可靠性发送是由事务主动方保证的；</p><p>但是最大努力通知，事务主动方尽最大努力（重试，轮询....）将事务发送给事务接收方，但是仍然存在消息接收不到，此时需要事务被动方主动调用事务主动方的消息校对接口查询业务消息并消费，这种通知的可靠性是由事务被动方保证的。</p><p>最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。</p><h3 id="saga-事务" tabindex="-1">Saga 事务 <a class="header-anchor" href="#saga-事务" aria-label="Permalink to &quot;Saga 事务&quot;">​</a></h3><blockquote><p>Saga 事务核心思想是将长事务拆分为<strong>多个</strong>本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p></blockquote><p>Saga 事务基本协议如下：</p><ul><li>每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) <strong>Ti</strong> 组成。</li><li>每个 <strong>Ti</strong> 都有对应的幂等补偿动作 <strong>Ci</strong>，补偿动作用于撤销 <strong>Ti</strong> 造成的结果。</li></ul><p>TCC事务补偿机制有一个预留(Try)动作，相当于先报存一个草稿，然后才提交；Saga事务没有预留动作，直接提交。</p><p>对于事务异常，Saga提供了两种恢复策略，分别如下：</p><p><strong>向后恢复(backward recovery)</strong></p><p>在执行事务失败时，补偿所有已完成的事务，是“一退到底”的方式。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301810398.png" alt="图片"></p><p>从上图可知事务执行到了支付事务T3，但是失败了，因此事务回滚需要从C3,C2,C1依次进行回滚补偿。</p><p>对应的执行顺序为：T1,T2,T3,C3,C2,C1</p><p>这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。</p><p><strong>向前恢复(forward recovery)</strong></p><p>也称之为：勇往直前，对于执行不通过的事务，会尝试<strong>重试事务</strong>，这里有一个假设就是每个子事务最终都会成功。</p><p>流程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301810406.png" alt="图片"></p><p>适用于必须要成功的场景，事务失败了重试，不需要补偿。</p><p>Saga事务有两种不同的实现方式，分别如下：</p><ul><li>命令协调（Order Orchestrator）</li><li>事件编排（Event Choreographyo）</li></ul><h5 id="命令协调" tabindex="-1">命令协调 <a class="header-anchor" href="#命令协调" aria-label="Permalink to &quot;命令协调&quot;">​</a></h5><p>中央协调器（Orchestrator，简称 OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。整体流程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301810525.png" alt="图片"></p><p>上图步骤如下：</p><ul><li>事务发起方的主业务逻辑请求 OSO 服务开启订单事务</li><li>OSO 向库存服务请求扣减库存，库存服务回复处理结果。</li><li>OSO 向订单服务请求创建订单，订单服务回复创建结果。</li><li>OSO 向支付服务请求支付，支付服务回复处理结果。</li><li>主业务逻辑接收并处理 OSO 事务处理结果回复。</li></ul><p>中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。</p><p>基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p><h5 id="事件编排" tabindex="-1">事件编排 <a class="header-anchor" href="#事件编排" aria-label="Permalink to &quot;事件编排&quot;">​</a></h5><p>没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。</p><p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p><p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301810161.png" alt="图片"></p><p>上图步骤如下：</p><ul><li>事务发起方的主业务逻辑发布开始订单事件。</li><li>库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件。</li><li>订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件。</li><li>支付服务监听订单已创建事件，进行支付，并发布订单已支付事件。</li><li>主业务逻辑监听订单已支付事件并处理。</li></ul><p>事件/编排是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。</p><h5 id="优缺点-3" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点-3" aria-label="Permalink to &quot;优缺点&quot;">​</a></h5><h6 id="优点-3" tabindex="-1">优点 <a class="header-anchor" href="#优点-3" aria-label="Permalink to &quot;优点&quot;">​</a></h6><p>命令协调设计的优点如下：</p><ul><li>服务之间关系简单，避免服务之间的循环依赖关系，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器。</li><li>程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。</li><li>易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试。</li></ul><p>事件/编排设计优点如下：</p><ul><li>避免中央协调器单点故障风险。</li><li>当涉及的步骤较少服务开发简单，容易实现。</li></ul><h6 id="缺点-3" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-3" aria-label="Permalink to &quot;缺点&quot;">​</a></h6><p>命令协调设计缺点如下：</p><ul><li>中央协调器容易处理逻辑容易过于复杂，导致难以维护。</li><li>存在协调器单点故障风险。</li></ul><p>事件/编排设计缺点如下：</p><ul><li>服务之间存在循环依赖的风险。</li><li>当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li></ul><blockquote><p>由于 Saga 模型中没有 Prepare 阶段，因此事务间不能保证隔离性。</p></blockquote><p>当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>总结一下各个方案的常见的使用场景：</p><ul><li><strong>2PC/3PC</strong>：依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li><li><strong>TCC</strong>：适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li><li><strong>本地消息表/MQ 事务</strong>：都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</li><li><strong>Saga 事务</strong>：由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li></ul><h2 id="分布式事务应用" tabindex="-1">分布式事务应用 <a class="header-anchor" href="#分布式事务应用" aria-label="Permalink to &quot;分布式事务应用&quot;">​</a></h2><h3 id="springboot-事务" tabindex="-1">SpringBoot 事务 <a class="header-anchor" href="#springboot-事务" aria-label="Permalink to &quot;SpringBoot 事务&quot;">​</a></h3><h5 id="事务自动配置" tabindex="-1">事务自动配置 <a class="header-anchor" href="#事务自动配置" aria-label="Permalink to &quot;事务自动配置&quot;">​</a></h5><blockquote><p>TransactionAutoConfiguration</p></blockquote><h5 id="事务易错点" tabindex="-1">事务易错点 <a class="header-anchor" href="#事务易错点" aria-label="Permalink to &quot;事务易错点&quot;">​</a></h5><blockquote><p>在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。原因是<strong>没有用到代理对象</strong>的缘故。</p><p>解决： 0）、导入 spring-boot-starter-aop 1）、@EnableTransactionManagement(proxyTargetClass = true) 2）、@EnableAspectJAutoProxy(exposeProxy=true) 3）、AopContext.currentProxy() 调用方法</p></blockquote><h3 id="seata" tabindex="-1">Seata <a class="header-anchor" href="#seata" aria-label="Permalink to &quot;Seata&quot;">​</a></h3><blockquote><p>官方文档：<a href="https://seata.io/zh-cn/index.html" target="_blank" rel="noreferrer">https://seata.io/zh-cn/index.html</a></p><p>个人文档：<a href="https://gitee.com/git_liuxiaowei/document/blob/master/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring%20Cloud%20Alibaba/Seata.md" target="_blank" rel="noreferrer">https://gitee.com/git_liuxiaowei/document/blob/master/微服务/Spring Cloud Alibaba/Seata.md</a></p></blockquote>',228),t=[r];function n(p,s,h,c,d,u){return l(),i("div",null,t)}const b=a(o,[["render",n]]);export{m as __pageData,b as default};
