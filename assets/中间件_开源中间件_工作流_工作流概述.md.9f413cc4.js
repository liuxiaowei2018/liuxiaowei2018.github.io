import{_ as a,o as e,c as i,Q as l}from"./chunks/framework.8048b864.js";const u=JSON.parse('{"title":"工作流概述","description":"","frontmatter":{},"headers":[],"relativePath":"中间件/开源中间件/工作流/工作流概述.md","filePath":"中间件/开源中间件/工作流/工作流概述.md","lastUpdated":null}'),p={name:"中间件/开源中间件/工作流/工作流概述.md"},t=l('<h1 id="工作流概述" tabindex="-1">工作流概述 <a class="header-anchor" href="#工作流概述" aria-label="Permalink to &quot;工作流概述&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#_1、工作流简介">1、工作流简介</a></li><li><a href="#_2、工作流程图">2、工作流程图</a><ul><li><a href="#事件">事件</a></li><li><a href="#连线">连线</a></li><li><a href="#任务">任务</a></li><li><a href="#活动">活动</a></li><li><a href="#网关">网关</a></li></ul></li><li><a href="#_3、工作流选型">3、工作流选型</a></li><li><a href="#_4、参考文献">4、参考文献</a></li></ul></nav><h2 id="_1、工作流简介" tabindex="-1">1、工作流简介 <a class="header-anchor" href="#_1、工作流简介" aria-label="Permalink to &quot;1、工作流简介&quot;">​</a></h2><p>假设我有一个请假需求，流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301709382.png" alt="image-20230421174122345"></p><p>请假可以提交给我的上司，上司可以选择批准或者拒绝，无论批准还是拒绝，都会给我一个通知。</p><p>这个流程比较简单，我们很容易想到解决方案，不用工作流也能解决，有一个专门的请假表，当 A 要请假的时候，就往请假表中添加一条记录，这条记录的内容包含了请假的天数、原因、请假的审批人 B 以及一个名为 status 的字段，这个 status 字段表示这个请假申请目前的状态（待审批、已批准还是已拒绝），然后 B 登录系统之后，在请假表中查询到了 A 的请假信息，然后选择批准，此时将 status 字段的值改一下就行了。</p><p>这个流程很简单，相信小伙伴们都能想到。</p><p>然而，这是一个非常简单的流程，对于这样的流程，一般来说也确实没有必要使用工作流，但是现实中，我们涉及到的工作流往往都是非常复杂的，我举个例子，就说报销审批吧，这个可能很多小伙伴都经历过。 <img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301709989.png" alt="image-20230421174149181"></p><p>小伙伴们看到，这个流程相对来说还是比较复杂的，此时你再用一个 status 字段去描述，就很难说的请到底是怎么回事了。每一步审批，都有可能批准也有可能拒绝，拒绝并不意味着流程结束，员工修改报销资料之后，还可以继续提交。此时如果还用 status 去描述，那么 status 将有 N 多个值去表示不同的情况，这个维护起来非常不便。</p><p>这就复杂了吗？非也非也，我们再来看一个生产笔记本电脑的例子，假设公司研发了一款新型笔记本电脑，整个研发到生产的流程可能是这样： <img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301709748.png" alt="image-20230421174205462"></p><p>相比上面两个，这个就更复杂一些了，不仅有串行任务还有并行任务，如何去设计这样一个系统？单纯的通过状态字段去描述显然已经不够用了，此时我们就得考虑一种通用的、更易维护的方案来实现这样的系统了，这种通用的、易维护的方案，也就是工作流。</p><h2 id="_2、工作流程图" tabindex="-1">2、工作流程图 <a class="header-anchor" href="#_2、工作流程图" aria-label="Permalink to &quot;2、工作流程图&quot;">​</a></h2><p>以生产笔记本的流程图为例，做一个简单介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301709014.png" alt="image-20230421174407810"></p><p>一个流程图中主要包含四方面的内容：</p><ul><li>事件</li><li>连线</li><li>任务</li><li>网关</li></ul><h3 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h3><p>首先在一个流程图中应该有开始事件和结束事件，也就是上图大家看到的两个圆圈。另外还有一些中间事件、边界事件等。举个中间定时事件的例子，比如用户下单之后，可以有一个中间定时事件，延迟 5 分钟发货。</p><h3 id="连线" tabindex="-1">连线 <a class="header-anchor" href="#连线" aria-label="Permalink to &quot;连线&quot;">​</a></h3><p>连线就是将事件、任务、网关等连在一起的线条，一般情况下就是普通连线，有的时候连线会有一些条件，例如松哥之前文章和大家分享的请假，如果经理同意请假申请，就走哪一个线条，如果经理不同意请假申请，就走哪一个线条。对应上图的笔记本生产，如果经理审批通过，就载入图纸准备生产，如果经理审批不通过，就重新设计。</p><h3 id="任务" tabindex="-1">任务 <a class="header-anchor" href="#任务" aria-label="Permalink to &quot;任务&quot;">​</a></h3><ul><li><p>接收任务</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301709966.png" alt="image-20230421174521081"></p><p>在上面的流程图中，等待准备工作完成这一项就是一个接收任务。这个任务里并不需要额外做什么事情，流程到这一步就自动停下来了，需要人工去点一下，推动流程继续向下执行。</p></li><li><p>发送任务</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301709813.png" alt="image-20230421174543221"></p><p>这个一般用来把消息发送给外部参与者。</p></li><li><p>服务任务</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301709454.png" alt="image-20230421174603769"></p><p>这个一般由系统自动完成，其实说白了就是我们的一个自定义类，可以在一个自定义类里边完成想要做的事情。</p></li><li><p>脚本任务</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301709341.png" alt="image-20230421174623283"></p><p>一个自动化活动。当流程执行到脚本任务时，自动执行相应的脚本。</p></li><li><p>业务规则任务</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301710813.png" alt="image-20230421174640550"></p><p>BPMN2.0 新引入用来对接业务规则引擎，业务规则任务用于同步执行一个或多个规则。</p></li><li><p>用户任务</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301710517.png" alt="image-20230421174658356"><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301710909.png" alt="image-20230421174705366"></p><p>用于为那些需要由人工参与者完成的工作建模。</p></li></ul><p>虽然细分类别很多，但是仔细看，其实这几种又可以归为两大类：</p><ul><li><p>用户任务：表示人工要介入做的事情。比如同意与否，或者输入一些参数，要让人工完成任务，就需要一个表单系统，让人工输入数据，或者显示数据给人看，这也是为什么用户任务和表单系统结合在一起的原因，用户任务需要用户向引擎提交一个完成任务的动作，否则流程会暂停在这里等待。</p></li><li><p>服务任务：表示机器自动做的事情。调用服务的任务，这个服务可以是一个 Spring JavaBean，也可以是一个远程 REST 服务，流程会自动执行服务任务。</p></li></ul><h3 id="活动" tabindex="-1">活动 <a class="header-anchor" href="#活动" aria-label="Permalink to &quot;活动&quot;">​</a></h3><p>活动可以算是一种特殊的任务。活动可以调用另外一个流程使之作为当前流程的子流程去运行。活动也可以分为用户活动、脚本活动等等。从显示上来说，活动比任务边框深一些。仅此而已。</p><h3 id="网关" tabindex="-1">网关 <a class="header-anchor" href="#网关" aria-label="Permalink to &quot;网关&quot;">​</a></h3><ul><li><p>互斥网关</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301710174.png" alt="image-20230421174816928"></p><p>这种网关也叫排他性网关，我们之前请假流程中的那个网关，就是互斥网关。这种网关有且仅有一个有效出口。</p></li><li><p>相容网关</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301710238.png" alt="image-20230421174831631"></p><p>这种网关会有多个出口，只要条件满足，都会执行。</p></li><li><p>事件网关</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301710205.png" alt="image-20230421174847119"></p><p>事件网关是通过中间事件驱动，它在等待的事件发生后才会触发决策。基于事件的网关允许基于事件作出决策。</p></li><li><p>并行网关</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301710229.png" alt="image-20230421174906682"></p><p>并行网关一般是成对出现的，上面生产笔记本的那个流程中，生产屏幕、键盘等并行操作，就是通过并行网关来实现的。</p></li></ul><h2 id="_3、工作流选型" tabindex="-1">3、工作流选型 <a class="header-anchor" href="#_3、工作流选型" aria-label="Permalink to &quot;3、工作流选型&quot;">​</a></h2><p>市面上主流的流程引擎就一共有三个：</p><ul><li>Activiti</li><li>Flowable</li><li>Camunda</li></ul><p>这三个各有特点：</p><p>Activiti 目前是侧重云，他目前的设计会向 Spring Cloud、Docker 这些去靠拢。</p><p>Flowable 核心思想还是在做一个功能丰富的流程引擎工具，除了最最基础的工作流，他还提供了很多其他的扩展点，我们可以基于 Flowable 实现出许多我们想要的功能。</p><p>Camunda 相对于前两个而言比较轻量级，Camunda 有一个比较有特色的功能就是他提供了一个小巧的编辑器，基于 bpmn.io 来实现的（松哥之前已经发文讲过了）。如果你的项目需求是做一个轻巧的、灵活的、定制性强的编辑器，工作流是嵌入式的，那么可以选择 Camunda。</p><h2 id="_4、参考文献" tabindex="-1">4、参考文献 <a class="header-anchor" href="#_4、参考文献" aria-label="Permalink to &quot;4、参考文献&quot;">​</a></h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247497519&amp;idx=1&amp;sn=802473a5a457c35817128fa706a0bb0c&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">Spring Boot 整合流程引擎 Flowable，so easy！</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247500797&amp;idx=1&amp;sn=76dd77c34686fb43c542abff1d5537f5&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">SpringBoot+Vue+Flowable，模拟一个请假审批流程！</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247500954&amp;idx=1&amp;sn=4afae4d992e8bff95e70ebc662e91ffe&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">49张图带领小伙伴们体验一把 Flowable-UI</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247501151&amp;idx=1&amp;sn=8a0ecaa8fd3b1cb2be22177da1c33a9a&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">Spring Security + Vue + Flowable 怎么玩？</a></li></ul>',38),r=[t];function n(s,o,h,c,d,m){return e(),i("div",null,r)}const _=a(p,[["render",n]]);export{u as __pageData,_ as default};
