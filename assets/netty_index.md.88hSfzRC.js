import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.PLIGnzYk.js";const g=JSON.parse('{"title":"Netty学习笔记","description":"","frontmatter":{},"headers":[],"relativePath":"netty/index.md","filePath":"netty/index.md","lastUpdated":1727780746000}'),t={name:"netty/index.md"},e=n(`<h1 id="netty学习笔记" tabindex="-1">Netty学习笔记 <a class="header-anchor" href="#netty学习笔记" aria-label="Permalink to &quot;Netty学习笔记&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#reactor模型">Reactor模型</a></li><li><a href="#netty架构">Netty架构</a></li><li><a href="#重点模块">重点模块</a></li><li><a href="#核心组件">核心组件</a></li><li><a href="#bootstrap-详解">Bootstrap 详解</a></li><li><a href="#eventloop-详解">EventLoop 详解</a></li></ul></nav><blockquote><p>官方文档：<a href="https://netty.io/" target="_blank" rel="noreferrer">https://netty.io/</a></p></blockquote><h3 id="reactor模型" tabindex="-1">Reactor模型 <a class="header-anchor" href="#reactor模型" aria-label="Permalink to &quot;Reactor模型&quot;">​</a></h3><p>将关注的 I/O 事件注册到多路复用器上，一旦有 I/O 事件触发，将事件分发到事件处理器中，执行就绪 I/O 事件对应的处理函数中。模型中有三个重要的组件：</p><ul><li>多路复用器：由操作系统提供接口，Linux 提供的 I/O 复用接口有select、poll、epoll 。</li><li>事件分离器：将多路复用器返回的就绪事件分发到事件处理器中。</li><li>事件处理器：处理就绪事件处理函数。</li></ul><p>Reactor 有 3 种模型实现：</p><ol><li>单 Reactor 单线程模型</li><li>单 Reactor 多线程模型</li><li>多 Reactor 多线程模型</li></ol><h4 id="单-reactor-单线程模型" tabindex="-1">单 Reactor 单线程模型 <a class="header-anchor" href="#单-reactor-单线程模型" aria-label="Permalink to &quot;单 Reactor 单线程模型&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301555058.png" alt="image-20220705102600425"></p><p>这是最基础的单 Reactor 单线程模型。</p><p>Reactor 线程，负责多路分离套接字。</p><ul><li>有新连接到来触发 <code>OP_ACCEPT</code> 事件之后， 交由 Acceptor 进行处理。</li><li>有 IO 读写事件之后，交给 Handler 处理。</li></ul><p>Acceptor 主要任务是构造 Handler 。</p><ul><li>在获取到 Client 相关的 SocketChannel 之后，绑定到相应的 Handler 上。</li><li>对应的 SocketChannel 有读写事件之后，基于 Reactor 分发，Handler 就可以处理了。</li></ul><p><strong>注意，所有的 IO 事件都绑定到 Selector 上，由 Reactor 统一分发</strong>。</p><hr><p>该模型适用于处理器链中业务处理组件能快速完成的场景。不过，这种单线程模型不能充分利用多核资源，<strong>所以实际使用的不多</strong>。</p><h4 id="单-reactor-多线程模型" tabindex="-1">单 Reactor 多线程模型 <a class="header-anchor" href="#单-reactor-多线程模型" aria-label="Permalink to &quot;单 Reactor 多线程模型&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301555832.png" alt="image-20220705102820676"></p><p>相对于第一种单线程的模式来说，在处理业务逻辑，也就是获取到 IO 的读写事件之后，交由线程池来处理，这样可以减小主 Reactor 的性能开销，从而更专注的做事件分发工作了，从而提升整个应用的吞吐。</p><h4 id="多-reactor-多线程模型" tabindex="-1">多 Reactor 多线程模型 <a class="header-anchor" href="#多-reactor-多线程模型" aria-label="Permalink to &quot;多 Reactor 多线程模型&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301556440.png" alt="image-20220705104900263"></p><p>第三种模型比起第二种模型，是将 Reactor 分成两部分：</p><ol><li>mainReactor 负责监听 ServerSocketChannel ，用来处理客户端新连接的建立，并将建立的客户端的 SocketChannel 指定注册给 subReactor 。</li><li>subReactor 维护自己的 Selector ，基于 mainReactor 建立的客户端的 SocketChannel 多路分离 IO 读写事件，读写网络数据。对于业务处理的功能，另外扔给 worker 线程池来完成。</li></ol><h3 id="netty架构" tabindex="-1">Netty架构 <a class="header-anchor" href="#netty架构" aria-label="Permalink to &quot;Netty架构&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301556513.png" alt="image-20220704194116443"></p><ul><li>Core：核心部分，是底层的网络通用抽象和部分实现。 <ul><li>Extensible Event Model ：可拓展的事件模型。Netty 是基于事件模型的网络应用框架。</li><li>Universal Communication API ：通用的通信 API 层。Netty 定义了一套抽象的通用通信层的 API 。</li><li>Zero-Copy-Capable Rich Byte Buffer ：支持零拷贝特性的 Byte Buffer 实现。</li></ul></li><li>Transport Services：传输( 通信 )服务，具体的网络传输的定义与实现。 <ul><li>Socket &amp; Datagram ：TCP 和 UDP 的传输实现。</li><li>HTTP Tunnel ：HTTP 通道的传输实现。</li><li>In-VM Piple ：JVM 内部的传输实现。</li></ul></li><li><strong>Protocol Support</strong> ：协议支持。Netty 对于一些通用协议的编解码实现。例如：HTTP、Redis、DNS 等等。</li></ul><h3 id="重点模块" tabindex="-1">重点模块 <a class="header-anchor" href="#重点模块" aria-label="Permalink to &quot;重点模块&quot;">​</a></h3><ul><li>本图省略<strong>非主要依赖</strong>。例如，<code>handler-proxy</code> 对 <code>codec</code> 有依赖，但是并未画出。</li><li>本图省略<strong>非主要的项目</strong>。例如，<code>resolver</code>、<code>testsuite</code>、<code>example</code> 等等。</li></ul><h4 id="common" tabindex="-1">common <a class="header-anchor" href="#common" aria-label="Permalink to &quot;common&quot;">​</a></h4><p><code>common</code> 项目，该项目是一个通用的工具类项目，几乎被所有的其它项目依赖使用，它提供了一些数据类型处理工具类，并发编程以及多线程的扩展，计数器等等通用的工具类。</p><h4 id="buffer" tabindex="-1">buffer <a class="header-anchor" href="#buffer" aria-label="Permalink to &quot;buffer&quot;">​</a></h4><p><code>buffer</code> 项目，实现了 Netty 架构图中的 Zero-Copy-Capable Rich Byte Buffer，该项目下是 Netty 自行实现的一个 Byte Buffer 字节缓冲区。该包的实现相对于 JDK 自带的 ByteBuffer 有很多<strong>优点</strong>：无论是 API 的功能，使用体验，性能都要更加优秀。它提供了**一系列( 多种 )**的抽象定义以及实现，以满足不同场景下的需要。</p><h4 id="transport" tabindex="-1">transport <a class="header-anchor" href="#transport" aria-label="Permalink to &quot;transport&quot;">​</a></h4><p><code>transport</code> 项目，实现了 Netty 架构图中 Transport Services、Universal Communication API 和 Extensible Event Model 等多部分内容，该项目是网络传输通道的抽象和实现。它定义通信的统一通信 API ，统一了 JDK 的 OIO、NIO ( 不包括 AIO )等多种编程接口。</p><p>另外，它提供了多个子项目，实现不同的传输类型。例如：<code>transport-native-epoll</code>、<code>transport-native-kqueue</code>、<code>transport-rxtx</code>、<code>transport-udt</code> 和 <code>transport-sctp</code> 等等。</p><h4 id="codec" tabindex="-1">codec <a class="header-anchor" href="#codec" aria-label="Permalink to &quot;codec&quot;">​</a></h4><p><code>codec</code> 项目，该项目是协议编解码的抽象与<strong>部分</strong>实现：JSON、Google Protocol、Base64、XML 等等。</p><p>另外，它提供了多个子项目，实现不同协议的编解码。例如：<code>codec-dns</code>、<code>codec-haproxy</code>、<code>codec-http</code>、<code>codec-http2</code>、<code>codec-mqtt</code>、<code>codec-redis</code>、<code>codec-memcached</code>、<code>codec-smtp</code>、<code>codec-socks</code>、<code>codec-stomp</code>、<code>codec-xml</code> 等等。</p><h4 id="handler" tabindex="-1">handler <a class="header-anchor" href="#handler" aria-label="Permalink to &quot;handler&quot;">​</a></h4><p><code>handler</code> 项目，该项目是提供<strong>内置的</strong>连接通道处理器( ChannelHandler )实现类。例如：SSL 处理器、日志处理器等等。</p><h4 id="example" tabindex="-1">example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;example&quot;">​</a></h4><p><code>example</code> 项目，该项目是提供各种 Netty 使用示例。</p><h4 id="其它模块" tabindex="-1">其它模块 <a class="header-anchor" href="#其它模块" aria-label="Permalink to &quot;其它模块&quot;">​</a></h4><ul><li><p><code>all</code> ：All In One 的 <code>pom</code> 声明。</p></li><li><p><code>bom</code> ：Netty Bill Of Materials 的缩写 。</p></li><li><p><code>microbench</code> ：微基准测试。</p></li><li><p><code>resolver</code> ：终端( Endpoint ) 的地址解析器。</p></li><li><p><code>resolver-dns</code></p></li><li><p><code>tarball</code> ：All In One 打包工具。</p></li><li><p><code>testsuite</code> ：测试集。</p></li><li><p><code>testsuite-autobahhn</code></p></li><li><p><code>testsuite-http2</code></p></li><li><p><code>testsuite-osgi</code></p></li></ul><h3 id="核心组件" tabindex="-1">核心组件 <a class="header-anchor" href="#核心组件" aria-label="Permalink to &quot;核心组件&quot;">​</a></h3><p>Netty 有如下几个核心组件：</p><ul><li>Bootstrap &amp; ServerBootstrap</li><li>Channel</li><li>ChannelFuture</li><li>EventLoop &amp; EventLoopGroup</li><li>ChannelHandler</li><li>ChannelPipeline</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301556754.png" alt="image-20220705100437055"></p><h4 id="bootstrap-serverbootstrap" tabindex="-1">Bootstrap &amp; ServerBootstrap <a class="header-anchor" href="#bootstrap-serverbootstrap" aria-label="Permalink to &quot;Bootstrap &amp; ServerBootstrap&quot;">​</a></h4><p>这 2 个类都继承了AbstractBootstrap，因此它们有很多相同的方法和职责。它们都是<strong>启动器</strong>，能够帮助 Netty 使用者更加方便地组装和配置 Netty ，也可以更方便地启动 Netty 应用程序。相比使用者自己从头去将 Netty 的各部分组装起来要方便得多，降低了使用者的学习和使用成本。它们是我们使用 Netty 的入口和最重要的 API ，可以通过它来连接到一个主机和端口上，也可以通过它来绑定到一个本地的端口上。</p><p>它们和其它组件之间的关系是它们将 Netty 的其它组件进行组装和配置，所以它们会组合和直接或间接依赖其它的类。</p><p>Bootstrap 用于启动一个 Netty TCP 客户端，或者 UDP 的一端。</p><ul><li>通常使用 <code>#connet(...)</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 客户端。</li><li>也可以通过 <code>#bind(...)</code> 方法绑定本地的一个端口，作为 UDP 的一端。</li><li>仅仅需要使用<strong>一个</strong> EventLoopGroup 。</li></ul><p>ServerBootstrap 往往是用于启动一个 Netty 服务端。</p><ul><li>通常使用 <code>#bind(...)</code> 方法绑定本地的端口上，然后等待客户端的连接。</li><li>使用<strong>两个</strong> EventLoopGroup 对象( 当然这个对象可以引用同一个对象 )：第一个用于处理它本地 Socket <strong>连接</strong>的 IO 事件处理，而第二个责负责处理远程客户端的 IO 事件处理。</li></ul><h4 id="channel" tabindex="-1">Channel <a class="header-anchor" href="#channel" aria-label="Permalink to &quot;Channel&quot;">​</a></h4><p>Channel 是 Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 之外，还包括了 Netty 框架相关的一些功能，如获取该 Channel 的 EventLoop 。</p><h4 id="eventloop-eventloopgroup" tabindex="-1">EventLoop &amp;&amp; EventLoopGroup <a class="header-anchor" href="#eventloop-eventloopgroup" aria-label="Permalink to &quot;EventLoop &amp;&amp; EventLoopGroup&quot;">​</a></h4><p>Netty 基于<strong>事件驱动模型</strong>，使用不同的事件来通知我们状态的改变或者操作状态的改变。它定义了在整个连接的生命周期里当有事件发生的时候处理的核心抽象。</p><p>Channel 为Netty 网络操作抽象类，EventLoop 负责处理注册到其上的 Channel 处理 I/O 操作，两者配合参与 I/O 操作。</p><p>EventLoopGroup 是一个 EventLoop 的分组，它可以获取到一个或者多个 EventLoop 对象，因此它提供了迭代出 EventLoop 对象的方法。</p><ul><li>一个 EventLoopGroup 包含一个或多个 EventLoop ，即 EventLoopGroup : EventLoop = <code>1 : n</code> 。</li><li>一个 EventLoop 在它的生命周期内，只能与一个 Thread 绑定，即 EventLoop : Thread = <code>1 : 1</code> 。</li><li>所有有 EventLoop 处理的 I/O 事件都将在它<strong>专有</strong>的 Thread 上被处理，从而保证线程安全，即 Thread : EventLoop = <code>1 : 1</code>。</li><li>一个 Channel 在它的生命周期内只能注册到一个 EventLoop 上，即 Channel : EventLoop = <code>n : 1</code> 。</li><li>一个 EventLoop 可被分配至一个或多个 Channel ，即 EventLoop : Channel = <code>1 : n</code> 。</li></ul><p>当一个连接到达时，Netty 就会创建一个 Channel，然后从 EventLoopGroup 中分配一个 EventLoop 来给这个 Channel 绑定上，在该 Channel 的整个生命周期中都是有这个绑定的 EventLoop 来服务的。</p><h4 id="channelfuture" tabindex="-1">ChannelFuture <a class="header-anchor" href="#channelfuture" aria-label="Permalink to &quot;ChannelFuture&quot;">​</a></h4><p>Netty 为异步非阻塞，即所有的 I/O 操作都为异步的，因此，我们不能立刻得知消息是否已经被处理了。Netty 提供了 ChannelFuture 接口，通过该接口的 <code>#addListener(...)</code> 方法，注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。</p><h4 id="channelhandler" tabindex="-1">ChannelHandler <a class="header-anchor" href="#channelhandler" aria-label="Permalink to &quot;ChannelHandler&quot;">​</a></h4><p>ChannelHandler ，连接通道处理器，我们使用 Netty 中<strong>最常用</strong>的组件。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p><p>ChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站( Inbound )的数据和事件，而 ChannelOutboundHandler 则相反，用于接收、处理出站( Outbound )的数据和事件。</p><ul><li>ChannelInboundHandler 的实现类还包括一系列的 <strong>Decoder</strong> 类，对输入字节流进行解码。</li><li>ChannelOutboundHandler 的实现类还包括一系列的 <strong>Encoder</strong> 类，对输入字节流进行编码。</li></ul><p>ChannelDuplexHandler 可以<strong>同时</strong>用于接收、处理入站和出站的数据和时间。</p><p>ChannelHandler 还有其它的一系列的抽象实现 Adapter ，以及一些用于编解码具体协议的 ChannelHandler 实现类。</p><h4 id="channelpipeline" tabindex="-1">ChannelPipeline <a class="header-anchor" href="#channelpipeline" aria-label="Permalink to &quot;ChannelPipeline&quot;">​</a></h4><p>ChannelPipeline 为 ChannelHandler 的<strong>链</strong>，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。一个数据或者事件可能会被多个 Handler 处理，在这个过程中，数据或者事件经流 ChannelPipeline ，由 ChannelHandler 处理。在这个处理过程中，一个 ChannelHandler 接收数据后处理完成后交给下一个 ChannelHandler，或者什么都不做直接交给下一个 ChannelHandler。</p><ul><li>当一个数据流进入 ChannelPipeline 时，它会从 ChannelPipeline 头部开始，传给第一个 ChannelInboundHandler 。当第一个处理完后再传给下一个，一直传递到管道的尾部。</li><li>与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的“最后”一个ChannelOutboundHandler ，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</li></ul><p>当 ChannelHandler 被添加到 ChannelPipeline 时，它将会被分配一个 <strong>ChannelHandlerContext</strong> ，它代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。其中 ChannelHandler 添加到 ChannelPipeline 中，通过 ChannelInitializer 来实现，过程如下：</p><ol><li>一个 ChannelInitializer 的实现对象，被设置到了 BootStrap 或 ServerBootStrap 中。</li><li>当 <code>ChannelInitializer#initChannel()</code> 方法被调用时，ChannelInitializer 将在 ChannelPipeline 中创建<strong>一组</strong>自定义的 ChannelHandler 对象。</li><li>ChannelInitializer 将它自己从 ChannelPipeline 中移除。</li></ol><h3 id="bootstrap-详解" tabindex="-1">Bootstrap 详解 <a class="header-anchor" href="#bootstrap-详解" aria-label="Permalink to &quot;Bootstrap 详解&quot;">​</a></h3><h4 id="服务端-serverbootstrap-示例" tabindex="-1">服务端-ServerBootstrap 示例 <a class="header-anchor" href="#服务端-serverbootstrap-示例" aria-label="Permalink to &quot;服务端-ServerBootstrap 示例&quot;">​</a></h4><h4 id="客户端-bootstrap-示例" tabindex="-1">客户端-Bootstrap 示例 <a class="header-anchor" href="#客户端-bootstrap-示例" aria-label="Permalink to &quot;客户端-Bootstrap 示例&quot;">​</a></h4><h3 id="eventloop-详解" tabindex="-1">EventLoop 详解 <a class="header-anchor" href="#eventloop-详解" aria-label="Permalink to &quot;EventLoop 详解&quot;">​</a></h3><h4 id="服务端-eventloop" tabindex="-1">服务端-EventLoop <a class="header-anchor" href="#服务端-eventloop" aria-label="Permalink to &quot;服务端-EventLoop&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建两个 EventLoopGroup 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EventLoopGroup bossGroup </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NioEventLoopGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建 boss 线程组 用于服务端接受客户端的连接</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EventLoopGroup workerGroup </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NioEventLoopGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建 worker 线程组 用于进行 SocketChannel 的数据读写</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建 ServerBootstrap 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ServerBootstrap b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ServerBootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置使用的 EventLoopGroup</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">group</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bossGroup, workerGroup);</span></span></code></pre></div><ul><li>对于 Netty NIO 服务端来说，创建两个 EventLoopGroup 。 <ul><li><code>bossGroup</code> 对应 Reactor 模式的 mainReactor ，用于服务端接受客户端的连接。比较特殊的是，传入了方法参数 <code>nThreads = 1</code> ，表示只使用一个 EventLoop ，即只使用一个 Reactor 。这个也符合我们上面提到的，“<em>通常，mainReactor 只需要一个，因为它一个线程就可以处理</em>”。</li><li><code>workerGroup</code> 对应 Reactor 模式的 subReactor ，用于进行 SocketChannel 的数据读写。对于 EventLoopGroup ，如果未传递方法参数 <code>nThreads</code> ，表示使用 CPU 个数 Reactor 。这个也符合我们上面提到的，“<em>通常，subReactor 的个数和 CPU 个数相等，每个 subReactor 独占一个线程来处理</em>”。</li></ul></li><li>因为使用两个 EventLoopGroup ，所以符合【多 Reactor 多线程模型】的多 Reactor 的要求。实际在使用时，<code>workerGroup</code> 在读完数据时，具体的业务逻辑处理，我们会提交到<strong>专门的业务逻辑线程池</strong>，例如在 Dubbo 或 Motan 这两个 RPC 框架中。这样一来，就完全符合【多 Reactor 多线程模型】。</li><li>那么可能有胖友可能和我有一样的疑问，<code>bossGroup</code> 如果配置多个线程，是否可以使用<strong>多个 mainReactor</strong> 呢？我们来分析一波，一个 Netty NIO 服务端<strong>同一时间</strong>，只能 bind 一个端口，那么只能使用一个 Selector 处理客户端连接事件。又因为，Selector 操作是非线程安全的，所以无法在多个 EventLoop ( 多个线程 )中，同时操作。所以这样就导致，即使 <code>bossGroup</code> 配置多个线程，实际能够使用的也就是一个线程。</li><li>那么如果一定要多个 mainReactor 呢？创建多个 Netty NIO 服务端，并绑定多个端口。</li></ul><h4 id="客户端-eventloop" tabindex="-1">客户端-EventLoop <a class="header-anchor" href="#客户端-eventloop" aria-label="Permalink to &quot;客户端-EventLoop&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个 EventLoopGroup 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EventLoopGroup group </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NioEventLoopGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建 Bootstrap 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Bootstrap b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bootstrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置使用的 EventLoopGroup</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">group</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(group);</span></span></code></pre></div><ul><li>对于 Netty NIO 客户端来说，仅创建一个 EventLoopGroup 。</li><li>一个 EventLoop 可以对应一个 Reactor 。因为 EventLoopGroup 是 EventLoop 的分组，所以对等理解，EventLoopGroup 是<strong>一种</strong> Reactor 的分组。</li><li>一个 Bootstrap 的启动，只能发起对一个远程的地址。所以只会使用一个 NIO Selector ，也就是说仅使用<strong>一个</strong> Reactor 。即使，我们在声明使用一个 EventLoopGroup ，该 EventLoopGroup 也只会分配一个 EventLoop 对 IO 事件进行处理。</li><li>因为 Reactor 模型主要使用服务端的开发中，如果套用在 Netty NIO 客户端中，到底使用了哪一种模式呢？ <ul><li>如果只有一个业务线程使用 Netty NIO 客户端，那么可以认为是【单 Reactor <strong>单</strong>线程模型】。</li><li>如果有<strong>多个</strong>业务线程使用 Netty NIO 客户端，那么可以认为是【单 Reactor <strong>多</strong>线程模型】。</li></ul></li><li>那么 Netty NIO 客户端是否能够使用【多 Reactor 多线程模型】呢？创建多个 Netty NIO 客户端，连接同一个服务端。那么多个 Netty 客户端就可以认为符合多 Reactor 多线程模型了。 <ul><li>一般情况下，我们不会这么干。</li><li>当然，实际也有这样的示例。例如 Dubbo 或 Motan 这两个 RPC 框架，支持通过配置，同一个 Consumer 对同一个 Provider 实例同时建立多个客户端连接。</li></ul></li></ul><h4 id="eventloopgroup" tabindex="-1">EventLoopGroup <a class="header-anchor" href="#eventloopgroup" aria-label="Permalink to &quot;EventLoopGroup&quot;">​</a></h4><p>EventLoopGroup 是一个 EventLoop 的分组，它可以获取到一个或者多个 EventLoop 对象，因此它提供了迭代出 EventLoop 对象的方法。</p><h5 id="eventexecutorgroup" tabindex="-1">EventExecutorGroup <a class="header-anchor" href="#eventexecutorgroup" aria-label="Permalink to &quot;EventExecutorGroup&quot;">​</a></h5><p><code>io.netty.util.concurrent.EventExecutorGroup</code> ，实现 Iterable、ScheduledExecutorService 接口，EventExecutor ( 事件执行器 )的分组接口。代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ========== 自定义接口 ==========</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isShuttingDown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 优雅关闭</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdownGracefully</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdownGracefully</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> quietPeriod, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeout, TimeUnit unit);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> terminationFuture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 选择一个 EventExecutor 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EventExecutor </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ========== 实现自 Iterable 接口 ==========</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Iterator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EventExecutor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> iterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ========== 实现自 ExecutorService 接口 ==========</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable task);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable task, T result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Callable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Deprecated</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Deprecated</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Runnable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdownNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ========== 实现自 ScheduledExecutorService 接口 ==========</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ScheduledFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable command, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delay, TimeUnit unit);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ScheduledFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Callable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> callable, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delay, TimeUnit unit);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ScheduledFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleAtFixedRate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable command, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> initialDelay, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> period, TimeUnit unit);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ScheduledFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleWithFixedDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable command, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> initialDelay, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delay, TimeUnit unit);</span></span></code></pre></div><ul><li>接口方法返回类型为 Future 不是 Java 原生的 <code>java.util.concurrent.Future</code> ，而是 Netty 自己实现的 Future 接口。</li><li>EventExecutorGroup 自身不执行任务，而是将任务 <code>#submit(...)</code> 或 <code>#schedule(...)</code> 给自己管理的 EventExecutor 的分组。至于提交给哪一个 EventExecutor ，一般是通过 <code>#next()</code> 方法，选择一个 EventExecutor 。</li></ul><h5 id="abstracteventexecutorgroup" tabindex="-1">AbstractEventExecutorGroup <a class="header-anchor" href="#abstracteventexecutorgroup" aria-label="Permalink to &quot;AbstractEventExecutorGroup&quot;">​</a></h5><p><code>io.netty.util.concurrent.AbstractEventExecutorGroup</code> ，实现 EventExecutorGroup 接口，EventExecutor ( 事件执行器 )的分组抽象类。</p><h6 id="submit" tabindex="-1">submit <a class="header-anchor" href="#submit" aria-label="Permalink to &quot;submit&quot;">​</a></h6><p><code>#submit(...)</code> 方法，提交<strong>一个</strong>普通任务到 EventExecutor 中。代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable task) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(task);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable task, T result) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(task, result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Callable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(task);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>提交的 EventExecutor ，通过 <code>#next()</code> 方法选择。</li></ul><h6 id="schedule" tabindex="-1">schedule <a class="header-anchor" href="#schedule" aria-label="Permalink to &quot;schedule&quot;">​</a></h6><p><code>#schedule(...)</code> 方法，提交<strong>一个</strong>定时任务到 EventExecutor 中。代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ScheduledFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable command, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delay, TimeUnit unit) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(command, delay, unit);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ScheduledFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Callable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> callable, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delay, TimeUnit unit) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callable, delay, unit);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ScheduledFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleAtFixedRate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable command, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> initialDelay, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> period, TimeUnit unit) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scheduleAtFixedRate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(command, initialDelay, period, unit);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ScheduledFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleWithFixedDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable command, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> initialDelay, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delay, TimeUnit unit) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scheduleWithFixedDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(command, initialDelay, delay, unit);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>提交的 EventExecutor ，通过 <code>#next()</code> 方法选择。</li></ul><h6 id="execute" tabindex="-1">execute <a class="header-anchor" href="#execute" aria-label="Permalink to &quot;execute&quot;">​</a></h6><p><code>#execute(...)</code> 方法，在 EventExecutor 中执行<strong>一个</strong>普通任务。代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable command) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(command);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>执行的 EventExecutor ，通过 <code>#next()</code> 方法选择。</li><li>看起来 <code>#execute(...)</code> 和 <code>#submit(...)</code> 方法有几分相似，具体的差异，由 EventExecutor 的实现决定。</li></ul><h6 id="invokeall" tabindex="-1">invokeAll <a class="header-anchor" href="#invokeall" aria-label="Permalink to &quot;invokeAll&quot;">​</a></h6><p><code>#invokeAll(...)</code> 方法，在 EventExecutor 中执行<strong>多个</strong>普通任务。代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">java.util.concurrent.Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> invokeAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Collection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> extends Callable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tasks) throws InterruptedException {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tasks);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">java.util.concurrent.Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> invokeAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Collection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> extends Callable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tasks, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeout, TimeUnit unit) throws InterruptedException {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tasks, timeout, unit);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>执行的 EventExecutor ，通过 <code>#next()</code> 方法选择。并且，多个任务使用同一个 EventExecutor</li></ul><h6 id="invokeany" tabindex="-1">invokeAny <a class="header-anchor" href="#invokeany" aria-label="Permalink to &quot;invokeAny&quot;">​</a></h6><p><code>#invokeAll(...)</code> 方法，在 EventExecutor 中执行<strong>多个</strong>普通任务，有<strong>一个</strong>执行完成即可。代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeAny</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Collection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> extends Callable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tasks) throws InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeAny</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tasks);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeAny</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Collection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> extends Callable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tasks, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeAny</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tasks, timeout, unit);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>执行的 EventExecutor ，通过 <code>#next()</code> 方法选择。并且，多个任务使用同一个 EventExecutor</li></ul><h6 id="shutdown" tabindex="-1">shutdown <a class="header-anchor" href="#shutdown" aria-label="Permalink to &quot;shutdown&quot;">​</a></h6><p><code>#shutdown(...)</code> 方法，关闭 EventExecutorGroup 。代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Future</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdownGracefully</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdownGracefully</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(DEFAULT_SHUTDOWN_QUIET_PERIOD </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 2 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, DEFAULT_SHUTDOWN_TIMEOUT </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 15 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TimeUnit.SECONDS);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Deprecated</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Runnable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdownNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    shutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Collections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emptyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Deprecated</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><ul><li>具体的 <code>#shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit)</code> 和 <code>#shutdown()</code> 方法，由子类实现。</li></ul><h5 id="multithreadeventexecutorgroup" tabindex="-1">MultithreadEventExecutorGroup <a class="header-anchor" href="#multithreadeventexecutorgroup" aria-label="Permalink to &quot;MultithreadEventExecutorGroup&quot;">​</a></h5><p><code>io.netty.util.concurrent.MultithreadEventExecutorGroup</code> ，继承 AbstractEventExecutorGroup 抽象类，<strong>基于多线程</strong>的 EventExecutor ( 事件执行器 )的分组抽象类</p>`,122),l=[e];function h(p,k,r,o,d,E){return a(),i("div",null,l)}const u=s(t,[["render",h]]);export{g as __pageData,u as default};
