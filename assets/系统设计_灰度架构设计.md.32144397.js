import{_ as a,o as e,c as t,Q as o}from"./chunks/framework.8048b864.js";const m=JSON.parse('{"title":"灰度架构设计","description":"","frontmatter":{},"headers":[],"relativePath":"系统设计/灰度架构设计.md","filePath":"系统设计/灰度架构设计.md","lastUpdated":null}'),r={name:"系统设计/灰度架构设计.md"},i=o('<h1 id="灰度架构设计" tabindex="-1">灰度架构设计 <a class="header-anchor" href="#灰度架构设计" aria-label="Permalink to &quot;灰度架构设计&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#概念篇">概念篇</a></li><li><a href="#应用篇">应用篇</a></li></ul></nav><h3 id="概念篇" tabindex="-1">概念篇 <a class="header-anchor" href="#概念篇" aria-label="Permalink to &quot;概念篇&quot;">​</a></h3><h4 id="蓝绿部署" tabindex="-1">蓝绿部署 <a class="header-anchor" href="#蓝绿部署" aria-label="Permalink to &quot;蓝绿部署&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301815274.png" alt="image-20220427174324280"></p><p>蓝绿部署，是指同时运行两个版本的应用，如上图所示，蓝绿部署的时候，并不停止掉老版本，而是直接部署一套新版本，等新版本运行起来后，再将流量切换到新版本上。但是蓝绿部署要求在升级过程中，同时运行两套程序，对硬件的要求就是日常所需的二倍，比如日常运行时，需要10台服务器支撑业务，那么使用蓝绿部署，你就需要购置二十台服务器。</p><h4 id="滚动发布" tabindex="-1">滚动发布 <a class="header-anchor" href="#滚动发布" aria-label="Permalink to &quot;滚动发布&quot;">​</a></h4><blockquote><p>滚动发布能够解决掉蓝绿部署时对硬件要求增倍的问题</p></blockquote><p>滚动升级，就是在升级过程中，并不一下子启动所有新版本，是先启动一台新版本，再停止一台老版本，然后再启动一台新版本，再停止一台老版本，直到升级完成，这样的话，如果日常需要10台服务器，那么升级过程中也就只需要11台就行了。</p><p>但是滚动升级有一个问题，在开始滚动升级后，流量会直接流向已经启动起来的新版本，但是这个时候，新版本是不一定可用的，比如需要进一步的测试才能确认。那么在滚动升级期间，整个系统就处于非常不稳定的状态，如果发现了问题，也比较难以确定是新版本还是老版本造成的问题。为了解决这个问题，我们需要为滚动升级实现<strong>流量控制能力</strong>。</p><h4 id="灰度发布" tabindex="-1">灰度发布 <a class="header-anchor" href="#灰度发布" aria-label="Permalink to &quot;灰度发布&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301815416.png" alt="image-20220427174502863"></p><p>在灰度发布开始后，先启动一个新版本应用，但是并不直接将流量切过来，而是测试人员对新版本进行线上测试，启动的这个新版本应用，就是我们的金丝雀。如果没有问题，那么可以将少量的用户流量导入到新版本上，然后再对新版本做运行状态观察，收集各种运行时数据，如果此时对新旧版本做各种数据对比，就是所谓的A/B测试。</p><p>当确认新版本运行良好后，再逐步将更多的流量导入到新版本上，在此期间，还可以不断地调整新旧两个版本的运行的服务器副本数量，以使得新版本能够承受越来越大的流量压力。直到将100%的流量都切换到新版本上，最后关闭剩下的老版本服务，完成灰度发布。</p><p>如果在灰度发布过程中（灰度期）发现了新版本有问题，就应该立即将流量切回老版本上，这样，就会将负面影响控制在最小范围内。</p><h3 id="应用篇" tabindex="-1">应用篇 <a class="header-anchor" href="#应用篇" aria-label="Permalink to &quot;应用篇&quot;">​</a></h3><h4 id="基于springcloud服务灰度发布" tabindex="-1">基于SpringCloud服务灰度发布 <a class="header-anchor" href="#基于springcloud服务灰度发布" aria-label="Permalink to &quot;基于SpringCloud服务灰度发布&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301815097.png" alt="image-20220427175224040"></p><h5 id="注册中心-nacos" tabindex="-1">注册中心: nacos <a class="header-anchor" href="#注册中心-nacos" aria-label="Permalink to &quot;注册中心: nacos&quot;">​</a></h5><blockquote><p>服务实例注册</p></blockquote><h5 id="网关-scg" tabindex="-1">网关: scg <a class="header-anchor" href="#网关-scg" aria-label="Permalink to &quot;网关: scg&quot;">​</a></h5><blockquote><p>处理请求灰度打标：根据请求信息，如ip,用户id等信息，如果该请求符合灰度策略的用户，那么给该请求添加一个标识为灰度用户的请求头信息；</p></blockquote><h5 id="服务实例管理后台" tabindex="-1">服务实例管理后台 <a class="header-anchor" href="#服务实例管理后台" aria-label="Permalink to &quot;服务实例管理后台&quot;">​</a></h5><blockquote><p>给服务实例打标签，服务灰度策略配置； 给服务打标是怎么样实现? 据于eureka服务实及eureka客户端实现，灰度的服务标签信息主要保存于服务实例的metadata里；通过eureka的/eureka/apps/appId/instanceId/metadata?接口设置；然后eureka客户端通过定时拉取服务实例信息，可得到服务实例里的metadata信息；</p></blockquote><h5 id="负载均衡器-ribbon" tabindex="-1">负载均衡器(ribbon) <a class="header-anchor" href="#负载均衡器-ribbon" aria-label="Permalink to &quot;负载均衡器(ribbon)&quot;">​</a></h5><blockquote><p>据网关处理请求头标签结果，改写路由规则； ribbon据请求头标签信息，如何寻找对应服务？由上面可知，eureka 客户端在拉取服务信息列表时，可得服务实例里的metadata里的标签，根据该标签信息，ribbon可判断那个服务实例是正常实例，那些实例是灰度例实；由此再根据请求头灰度标签信息决定路由到那个服务实例</p></blockquote><h4 id="k8s自动滚动部署工具" tabindex="-1">K8S自动滚动部署工具 <a class="header-anchor" href="#k8s自动滚动部署工具" aria-label="Permalink to &quot;K8S自动滚动部署工具&quot;">​</a></h4>',27),l=[i];function n(h,s,c,d,p,u){return e(),t("div",null,l)}const q=a(r,[["render",n]]);export{m as __pageData,q as default};
