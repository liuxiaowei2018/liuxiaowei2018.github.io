import{_ as s,c as a,o as n,N as o}from"./chunks/framework.0799945b.js";const l="/assets/image-20220328171810444.98fb4079.png",p="/assets/640-164845948474816.c07c8f97.png",e="/assets/640-164845948474917.162dbd1b.png",t="/assets/640-164845948474918.02d9928e.png",c="/assets/image-20230619171154690.a58b0869.png",r="/assets/image-20220727115946296.b9d316b6.png",i="/assets/image-20220727120007646.ca98a1ab.png",y="/assets/image-20220328171221673.9e3ecf38.png",D="/assets/image-20220328171325990.4816e419.png",C="/assets/640.107b8a1d.png",F="/assets/640-16484588679151.80379175.png",A="/assets/640-16484588679162.ea12684e.png",d="/assets/image-20220328171520177.f2429102.png",h="/assets/640-16484589643996.23885e92.png",g="/assets/640-16484590201988.385c4c58.png",u="/assets/640-16484590201999.1aa954ee.png",m="/assets/640-164845902019910.74d727fb.png",b="/assets/640-164845902019911.ad2610d3.png",O=JSON.parse('{"title":"生产问题排查&复盘","description":"","frontmatter":{},"headers":[],"relativePath":"problem/20220328q1.md"}'),k={name:"problem/20220328q1.md"},q=o('<h1 id="生产问题排查-复盘" tabindex="-1">生产问题排查&amp;复盘 <a class="header-anchor" href="#生产问题排查-复盘" aria-label="Permalink to &quot;生产问题排查&amp;复盘&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#如何排查生产问题">如何排查生产问题？</a><ul><li><a href="#使用排查工具">使用排查工具</a></li><li><a href="#定位并解决问题">定位并解决问题</a></li></ul></li></ul></nav><h2 id="如何排查生产问题" tabindex="-1">如何排查生产问题？ <a class="header-anchor" href="#如何排查生产问题" aria-label="Permalink to &quot;如何排查生产问题？&quot;">​</a></h2><h3 id="使用排查工具" tabindex="-1">使用排查工具 <a class="header-anchor" href="#使用排查工具" aria-label="Permalink to &quot;使用排查工具&quot;">​</a></h3><h4 id="jdk-工具" tabindex="-1">JDK 工具 <a class="header-anchor" href="#jdk-工具" aria-label="Permalink to &quot;JDK 工具&quot;">​</a></h4><blockquote><p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/" target="_blank" rel="noreferrer">https://docs.oracle.com/javase/8/docs/technotes/tools/</a></p></blockquote><p><img src="'+l+`" alt="image-20220328171810444"></p><p><code>案例</code></p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//启动10个线程</span></span>
<span class="line"><span style="color:#A6ACCD;">IntStream</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">rangeClosed</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">mapToObj</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">i </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Thread</span><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(true)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">//每一个线程都是一个死循环，休眠10秒，打印10M数据</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> payload </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> IntStream</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">rangeClosed</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10000000</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">mapToObj</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">__ </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">collect</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Collectors</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">joining</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> UUID</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">randomUUID</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">toString</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SECONDS</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">InterruptedException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">printStackTrace</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">length</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">})).</span><span style="color:#82AAFF;">forEach</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Thread</span><span style="color:#89DDFF;font-style:italic;">::</span><span style="color:#A6ACCD;">start</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">TimeUnit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">HOURS</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sleep</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span></code></pre></div><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//打印 VM 参数和程序参数</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">VM options</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ManagementFactory</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getRuntimeMXBean</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">getInputArguments</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">stream</span><span style="color:#89DDFF;">().</span><span style="color:#82AAFF;">collect</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Collectors</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">joining</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lineSeparator</span><span style="color:#89DDFF;">())));</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Program arguments</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Arrays</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stream</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">collect</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Collectors</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">joining</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">System</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lineSeparator</span><span style="color:#89DDFF;">())));</span></span></code></pre></div><p>修改 pom.xml，配置 spring-boot-maven-plugin 插件打包的 Java 程序的 main 方法类：</p><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">plugin</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">org.springframework.boot</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">spring-boot-maven-plugin</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">configuration</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">mainClass</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">org.geekbang.time.commonmistakes.troubleshootingtools.jdktool.CommonMistakesApplication</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">mainClass</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">configuration</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">plugin</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>使用 java -jar 启动进程，设置 JVM 参数，让堆最小最大都是 1GB：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">java -Xms1g -Xmx1g -jar common-mistakes-0.0.1-SNAPSHOT.jar</span></span></code></pre></div><h5 id="jps" tabindex="-1">jps <a class="header-anchor" href="#jps" aria-label="Permalink to &quot;jps&quot;">​</a></h5><blockquote><p>使用 jps 得到 Java 进程列表</p></blockquote><h5 id="jinfo" tabindex="-1">jinfo <a class="header-anchor" href="#jinfo" aria-label="Permalink to &quot;jinfo&quot;">​</a></h5><blockquote><p>使用 jinfo 打印 JVM 的各种参数</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">jinfo pid</span></span></code></pre></div></blockquote><h5 id="jvisualvm" tabindex="-1">jvisualvm <a class="header-anchor" href="#jvisualvm" aria-label="Permalink to &quot;jvisualvm&quot;">​</a></h5><blockquote><p>启动jvisualvm</p><p><img src="`+p+'" alt="图片"></p><p>继续观察监视面板可以看到，JVM 的 GC 活动基本是 10 秒发生一次，堆内存在 250MB 到 900MB 之间波动，活动线程数是 22。我们可以在监视面板看到 JVM 的基本情况，也可以直接在这里进行手动 GC 和堆 Dump 操作：</p><p><img src="'+e+'" alt="图片"></p><p>jconsole如果希望看到各个内存区的 GC 曲线图，可以使用 jconsole 观察。jconsole 也是一个综合性图形界面监控工具，比 jvisualvm 更方便的一点是，可以用曲线的形式监控各种数据，包括 MBean 中的属性值：</p><p><img src="'+t+'" alt="图片"></p></blockquote><h5 id="jstat" tabindex="-1">jstat <a class="header-anchor" href="#jstat" aria-label="Permalink to &quot;jstat&quot;">​</a></h5><blockquote><p>jstat 工具允许以固定的监控频次输出 JVM 的各种监控指标</p><p>比如使用 -gcutil 输出 GC 和内存占用汇总信息，每隔 5 秒输出一次，输出 100 次</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">jstat -gcutil 6 5000 100</span></span></code></pre></div></blockquote><p><img src="'+c+`" alt="image-20230619171154690"></p><blockquote><p>参数：</p><ul><li>S0 Survivor0 区占用百分比</li><li>S1 Survivor1 区占用百分比</li><li>E Eden 区占用百分比</li><li>O 老年代占用百分比</li><li>M 元数据区占用百分比</li><li>CCS 压缩使用百分比</li><li>YGC 年轻代回收次数</li><li>YGCT 年轻代回收耗时（单位秒）</li><li>FGC 老年代回收次数</li><li>FGCT 老年代回收耗时（单位秒）</li><li>GCT 垃圾回收消耗总时间（单位秒）</li></ul></blockquote><h5 id="jstack" tabindex="-1">jstack <a class="header-anchor" href="#jstack" aria-label="Permalink to &quot;jstack&quot;">​</a></h5><blockquote><p>通过命令行工具 jstack，实现抓取线程栈的操作</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">jstack pid</span></span></code></pre></div></blockquote><h5 id="jcmd" tabindex="-1">jcmd <a class="header-anchor" href="#jcmd" aria-label="Permalink to &quot;jcmd&quot;">​</a></h5><blockquote><p>通过 NMT，我们可以观察细粒度内存使用情况，设置 -XX:NativeMemoryTracking=summary/detail 可以开启 NMT 功能，开启后可以使用 jcmd 工具查看 NMT 数据</p></blockquote><h4 id="arthas" tabindex="-1">Arthas <a class="header-anchor" href="#arthas" aria-label="Permalink to &quot;Arthas&quot;">​</a></h4><blockquote><p>官方文档：<a href="https://arthas.aliyun.com/doc/commands.html" target="_blank" rel="noreferrer">https://arthas.aliyun.com/doc/commands.html</a></p><p><strong>arthas idea plugin</strong>：<a href="https://www.yuque.com/docs/share/fa77c7b4-c016-4de6-9fa3-58ef25a97948" target="_blank" rel="noreferrer">https://www.yuque.com/docs/share/fa77c7b4-c016-4de6-9fa3-58ef25a97948</a></p></blockquote><h5 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h5><blockquote><p>1.提供性能看板，包括线程、cpu、内存等信息，并且会定时的刷新。</p><p>2.根据各种条件查看线程快照。找出cpu占用率最高的n个线程</p><p>3.输出jvm的各种信息，如gc算法、jdk版本、ClassPath等</p><p>4.遇到问题无法在线上 debug，热部署加日志直接替换</p><p>5.查看某个类的静态属性，也可以通过ognl语法执行一些语句</p><p>6.查看已加载的类的详细信息，这个类从哪个jar包加载的，查看类的方法的信息</p><p>7.dump 类的字节码到指定目录</p><p>8.直接反编译指定的类</p><p>9.快速定位应用的热点，生成火焰图</p><p>10.可以监控到JVM的实时运行状态</p></blockquote><h5 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h5><blockquote><p><code>方式1</code></p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">curl</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-L</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">https://arthas.aliyun.com/install.sh</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">sh</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#启动</span></span>
<span class="line"><span style="color:#82AAFF;">.</span><span style="color:#FFCB6B;">/as.sh</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">运行</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">需要jdk(tools</span><span style="color:#89DDFF;">)</span><span style="color:#C3E88D;">环境</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p><code>方式2</code></p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">wget</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">https://alibaba.github.io/arthas/arthas-boot.jar</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#启动</span></span>
<span class="line"><span style="color:#FFCB6B;">java</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-jar</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">arthas-boot.jar</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">pid</span><span style="color:#89DDFF;">]</span></span></code></pre></div></blockquote><h5 id="指令" tabindex="-1">指令 <a class="header-anchor" href="#指令" aria-label="Permalink to &quot;指令&quot;">​</a></h5><h6 id="dashboard" tabindex="-1">dashboard <a class="header-anchor" href="#dashboard" aria-label="Permalink to &quot;dashboard&quot;">​</a></h6><blockquote><p>dashboard 命令用于整体展示进程所有线程、内存、GC 等情况</p></blockquote><h6 id="thread" tabindex="-1">thread <a class="header-anchor" href="#thread" aria-label="Permalink to &quot;thread&quot;">​</a></h6><blockquote><p><strong>thread -n</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">thread -n 8	 ---&gt;查看最繁忙的8个线程在执行的线程栈</span></span></code></pre></div></blockquote><h6 id="jad" tabindex="-1">jad <a class="header-anchor" href="#jad" aria-label="Permalink to &quot;jad&quot;">​</a></h6><blockquote><p>反编译</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">jad com.open.order.HighCPUApplication	---&gt;反编译HighCPUApplication.class</span></span></code></pre></div></blockquote><h6 id="watch" tabindex="-1">watch <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;watch&quot;">​</a></h6><blockquote><p>观察方法入参</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">watch com.open.order.HighCPUApplication doTask &#39;{params}&#39; &#39;#cost&gt;100&#39; -x 2</span></span>
<span class="line"><span style="color:#A6ACCD;">监控耗时超过 100 毫秒的 doTask 方法的入参，并且输出入参，展开 2 层入参参数</span></span></code></pre></div></blockquote><h5 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h5><h6 id="arthas-idea" tabindex="-1">arthas idea <a class="header-anchor" href="#arthas-idea" aria-label="Permalink to &quot;arthas idea&quot;">​</a></h6><blockquote><p>1.方法名上面单击右键，选择watch生成观测脚本</p><p>​ watch com.lxw.designpatterns.easystrategy.CostController getResult &#39;{params,returnObj,throwExp}&#39; -v -n 5 -x 3 &#39;1==1&#39;</p><p>2.登录应用服务器安装Arthas并运行</p><p>3.执行观测方法命令</p><p>​ watch com.lxw.designpatterns.easystrategy.CostController getResult &#39;{params,returnObj,throwExp}&#39; -v -n 5 -x 3 &#39;1==1&#39;</p><p>4.查看观测结果</p><p>5.诊断结束要执行 shutdown 来还原类或方法字节码，然后退出 Arthas。</p><p><code>命令解释</code></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&#39;{params,returnObj,throwExp}&#39; 表示观测对象:入参、出参和异常</span></span>
<span class="line"><span style="color:#A6ACCD;">-n 5 表示观测到5次后停止</span></span>
<span class="line"><span style="color:#A6ACCD;">-x 3 表示打印观测对象的时候只打印3层嵌套结构</span></span>
<span class="line"><span style="color:#A6ACCD;">&#39;params[0].getPlayToolDO().getId()==588&#39; 为条件表达式，满足该条件的才会被观测到</span></span></code></pre></div></blockquote><h6 id="arthashotswap" tabindex="-1">ArthasHotSwap <a class="header-anchor" href="#arthashotswap" aria-label="Permalink to &quot;ArthasHotSwap&quot;">​</a></h6><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">修改代码 -&gt; maven编译 -&gt; 单击右键选择swap this class -&gt; 热部署命令已经复制到粘贴板 -&gt; 登录远程服务器粘贴并执行热部署命令 -&gt; 热部署成功</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">限制：</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">.热部署时候，不能修改方法名、属性字段，只能修改方法体里面的代码</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">.redefine 命令和 jad/watch/trace/monitor/tt 等命令会冲突。执行完 redefine 之后，如果再执行上面提到的命令，则会把 redefine 的字节码重置。也就是说，热部署执行完成之后，再执行 jad/watch/trace/monitor/tt 等命令，会使热部署失效，所以在适当的时候还是需要重新部署下。我们也可以采用其他方法规避，比如使用watch的时候，观测其他类的方法，而不是热部署的那个类。</span></span></code></pre></div><h6 id="方法执行的时间隧道" tabindex="-1">方法执行的时间隧道 <a class="header-anchor" href="#方法执行的时间隧道" aria-label="Permalink to &quot;方法执行的时间隧道&quot;">​</a></h6><p><code>获取tt命令</code></p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Arthas的tt命令可以获取方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。安装好arthas idea插件之后，在需要记录执行的方法上面单击右键，选择TimeTunnel Tt，出现下面的选择框，第一个红框是获取记录方法执行的命令。第二个红框是记录方法执行之后需要对记录进行的操作，包括查看记录列表、查看记录执行情况、重现调用等。</span></span></code></pre></div><p><code>记录方法执行</code></p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">登录远程服务器，运行以下两条运行arthas，然后执行从idea插件复制的tt -t命令来记录方法执行，如下图所示。如果想停止记录可以输入q，查看记录使用tt -l。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">curl -L https:</span><span style="color:#676E95;font-style:italic;">//arthas.aliyun.com/install.sh | sh</span></span>
<span class="line"><span style="color:#A6ACCD;">./as.sh</span></span></code></pre></div><p><code>搜索方法执行记录</code></p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tt -l可以查看所有的方法执行记录，但是我们要和我们相关的执行记录，那么可以使用tt -s命令进行搜索。tt -s 命令后面需要携带过滤条件。</span></span>
<span class="line"><span style="color:#A6ACCD;">条件表达式是使用OGNL编写，下面介绍几个通常的过滤表达式。首先介绍下几个对象</span></span>
<span class="line"><span style="color:#A6ACCD;">	params表示入参，params</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">表示第一个参数，params</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">表示第二个参数，returnObj表示返回对象。</span></span>
<span class="line"><span style="color:#A6ACCD;">        根据入参过滤：tt -s &#39;params</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">.getRecordId() == </span><span style="color:#F78C6C;">110213603</span><span style="color:#A6ACCD;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        根据返回结果过滤：tt -s &#39;returnObj.isSuccess() == </span><span style="color:#89DDFF;">false</span><span style="color:#A6ACCD;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        根据入参和返回结果过滤：tt -s &#39;returnObj.isSuccess() == </span><span style="color:#89DDFF;">true</span><span style="color:#A6ACCD;"> &amp;&amp; params</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">.getRecordId() == </span><span style="color:#F78C6C;">110213603</span><span style="color:#A6ACCD;">&#39;</span></span></code></pre></div><p><code>查看方法执行情况</code></p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tt -w 相当于tt下面的watch命令，可以用来查看方法执行情况。使用idea插件获取tt -w命令</span></span></code></pre></div><p><code>重新触发</code></p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">如果需要重新触发某条记录也是可行的，因为tt命令记录当时调用的情况，所以可以本地发起一次调用，tt -p -i </span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;"> 命令的意思重新触发idex=</span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;">的那条记录。不仅仅可以重新触发，还可以间隔时间内多次触发，tt -p --replay-times </span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;"> --replay-interval </span><span style="color:#F78C6C;">2000</span><span style="color:#A6ACCD;"> -i </span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;"> 表示重新触发</span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">次，每次间隔</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">s。重新触发的时候我们可能还想再watch下方法执行情况，怎么办呢，另外再打开一个页面登录远程服务器，运行arthas，执行 watch 命令。</span></span></code></pre></div><h4 id="mat" tabindex="-1">MAT <a class="header-anchor" href="#mat" aria-label="Permalink to &quot;MAT&quot;">​</a></h4><blockquote><p>官方文档：<a href="https://www.eclipse.org/mat/" target="_blank" rel="noreferrer">https://www.eclipse.org/mat/</a></p><p>排查 OOM 问题、分析程序堆内存使用情况，分析堆转储（包含了堆现场全貌和线程栈信息）。</p></blockquote><h5 id="排查流程" tabindex="-1">排查流程 <a class="header-anchor" href="#排查流程" aria-label="Permalink to &quot;排查流程&quot;">​</a></h5><blockquote><ol><li>通过支配树功能或直方图功能查看消耗内存最大的类型，来分析内存泄露的大概原因；</li><li>查看那些消耗内存最大的类型、详细的对象明细列表，以及它们的引用链，来定位内存泄露的具体点；</li><li>配合查看对象属性的功能，可以脱离源码看到对象的各种属性的值和依赖关系，帮助我们理清程序逻辑和参数；</li><li>辅助使用查看线程栈来看 OOM 问题是否和过多线程有关，甚至可以在线程栈看到 OOM 最后一刻出现异常的线程。</li></ol></blockquote><p><img src="`+r+'" alt="image-20220727115946296"></p><p><img src="'+i+'" alt="image-20220727120007646"></p><h5 id="案例" tabindex="-1">案例 <a class="header-anchor" href="#案例" aria-label="Permalink to &quot;案例&quot;">​</a></h5><blockquote><p>OOM转储文件 <strong>java_pid29569.hprof</strong></p><p>使用 MAT 的直方图、支配树、线程栈、OQL 等功能来分析此次 OOM 的原因</p><p><strong>概览信息界面</strong></p><p><img src="'+y+'" alt="image-20220328171221673"></p><p><strong>直方图</strong></p><p>直方图按照类型进行分组，列出了每个类有多少个实例，以及占用的内存</p><p><img src="'+D+'" alt="image-20220328171325990"></p><p>在 char[]上点击右键，选择 List objects-&gt;with incoming references，就可以列出所有的 char[]实例，以及每个 char[]的整个引用关系链：</p><p><img src="'+C+'" alt="图片"></p><p>随机展开一个 char[]，如下图所示：</p><p><img src="'+F+'" alt="图片"></p><p>接下来，我们按照红色框中的引用链来查看，尝试找到这些大 char[]的来源：</p><ul><li>在①处看到，这些 char[]几乎都是 10000 个字符、占用 20000 字节左右（char 是 UTF-16，每一个字符占用 2 字节）；</li><li>在②处看到，char[]被 String 的 value 字段引用，说明 char[]来自字符串；</li><li>在③处看到，String 被 ArrayList 的 elementData 字段引用，说明这些字符串加入了一个 ArrayList 中；</li><li>在④处看到，ArrayList 又被 FooService 的 data 字段引用，这个 ArrayList 整个 RetainedHeap 列的值是 431MB。</li></ul><p>Retained Heap（深堆）代表对象本身和对象关联的对象占用的内存，Shallow Heap（浅堆）代表对象本身占用的内存。</p><p>比如，我们的 FooService 中的 data 这个 ArrayList 对象本身只有 16 字节，但是其所有关联的对象占用了 431MB 内存。</p><p>这些就可以说明，肯定有哪里在不断向这个 List 中添加 String 数据，导致了 OOM。</p><p>左侧的蓝色框可以查看每一个实例的内部属性，图中显示 FooService 有一个 data 属性，类型是 ArrayList。</p><p>如果我们希望看到字符串完整内容的话，可以右键选择 Copy-&gt;Value，把值复制到剪贴板或保存到文件中：</p><p><img src="'+A+'" alt="图片"></p><p><strong>支配树界面</strong></p><p>按照对象保留的 Retained Heap 倒序直接列出占用内存最大的对象</p><p>第一位就是 FooService，整个路径是 <strong>FooSerice-&gt;ArrayList-&gt;Object[]-&gt;String-&gt;char[]</strong> （蓝色框部分），一共有 <strong>21523</strong> 个字符串（绿色方框部分）：</p><p><img src="'+d+'" alt="image-20220328171520177"></p><p><strong>线程视图</strong></p><p>FooService：</p><p><img src="'+h+'" alt="图片"></p><p>先执行的方法先入栈，所以线程栈最上面是线程当前执行的方法，逐一往下看能看到整个调用路径。因为我们希望了解 FooService.oom() 方法，看看是谁在调用它，它的内部又调用了谁，所以选择以 FooService.oom() 方法（蓝色框）为起点来分析这个调用栈。</p><p>往下看整个绿色框部分，<strong>oom()</strong> 方法被 OOMApplication 的 <strong>run</strong> 方法调用，而这个 run 方法又被 SpringAppliction.callRunner 方法调用。看到参数中的 CommandLineRunner 你应该能想到，OOMApplication 其实是实现了 CommandLineRunner 接口，所以是 SpringBoot 应用程序启动后执行的。</p><p>以 FooService 为起点往上看，从紫色框中的 Collectors 和 IntPipeline，你大概也可以猜出，这些字符串是由 Stream 操作产生的。再往上看，可以发现在 StringBuilder 的 append 操作的时候，出现了 OutOfMemoryError 异常（黑色框部分），说明这这个线程抛出了 OOM 异常。</p><p>我们看到，整个程序是 Spring Boot 应用程序，那么 FooService 是不是 Spring 的 Bean 呢，又是不是单例呢？如果能分析出这点的话，就更能确认是因为反复调用同一个 FooService 的 oom 方法，然后导致其内部的 ArrayList 不断增加数据的。</p><p><strong>OQL 界面</strong></p><p>在这个界面，我们可以使用类似 SQL 的语法，在 dump 中搜索数据（你可以直接在 MAT 帮助菜单搜索 OQL Syntax，来查看 OQL 的详细语法）。</p><p>比如，输入如下语句搜索 FooService 的实例：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">SELECT * FROM org.geekbang.time.commonmistakes.troubleshootingtools.oom.FooService</span></span></code></pre></div><p>可以看到只有一个实例，然后我们通过 List objects 功能搜索引用 FooService 的对象:</p><p><img src="'+g+'" alt="图片"></p><p>得到以下结果：</p><p><img src="'+u+'" alt="图片"></p><p>可以看到，一共两处引用：</p><ul><li>第一处是，OOMApplication 使用了 FooService，这个我们已经知道了</li><li>第二处是一个 ConcurrentHashMap。可以看到，这个 HashMap 是 DefaultListableBeanFactory 的 singletonObjects 字段，可以证实 FooService 是 Spring 容器管理的单例的 Bean。</li></ul><p>你甚至可以在这个 HashMap 上点击右键，选择 Java Collections-&gt;Hash Entries 功能，来查看其内容：</p><p><img src="'+m+'" alt="图片"></p><p>这样就列出了所有的 Bean，可以在 Value 上的 Regex 进一步过滤。输入 FooService 后可以看到，类型为 FooService 的 Bean 只有一个，其名字是 fooService：</p><p><img src="'+b+'" alt="图片"></p></blockquote><h3 id="定位并解决问题" tabindex="-1">定位并解决问题 <a class="header-anchor" href="#定位并解决问题" aria-label="Permalink to &quot;定位并解决问题&quot;">​</a></h3><blockquote><p>吞吐量（TPS）、QPS、并发数、响应时间（RT）的定义</p></blockquote><p><strong>QPS</strong> <code>Queries Per Second</code> 是每秒查询率 ,是<strong>一台服务器</strong>每秒能够相应的查询次数，是对一个特定的查询服务器<strong>在规定时间内</strong>所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。</p><p><strong>TPS</strong> <code>Transactions Per Second</code> 也就是事务数/秒。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数</p><p>并发数（并发度）：指系统同时能处理的请求数量，同样反应了系统的负载能力。这个数值可以分析机器1s内的访问日志数量来得到</p><p><strong>吞吐量</strong>是指系统在单位时间内处理请求的数量，TPS、QPS都是吞吐量的常用量化指标。</p><p><strong>重要参数</strong></p><p>QPS(TPS),并发数，响应时间</p><ul><li>QPS(TPS)：每秒钟request/事务 数量</li><li>并发数：系统同时处理的request/事务数</li><li>响应时间：一般取平均响应时间</li></ul><p><strong>关系</strong></p><p>QPS(TPS)=并发数/平均响应时间</p><p>一个系统吞吐量通常有QPS(TPS),并发数两个因素决定，每套系统这个两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换，内存等等其他消耗导致系统性能下降。</p><p><strong>PV</strong>（Page View）：页面访问量，即页面浏览量或点击量，用户每次刷新即被计算一次。可以统计服务一天的访问日志得到。</p><p><strong>UV</strong>（Unique Visitor）：独立访客，统计1天内访问某站点的用户数。可以统计服务一天的访问日志并根据用户的唯一标识去重得到。响应时间（RT）：响应时间是指系统对请求作出响应的时间，一般取平均响应时间。可以通过Nginx、Apache之类的Web Server得到。</p><p><strong>DAU</strong>(Daily Active User)，日活跃用户数量。常用于反映网站、互联网应用或网络游戏的运营情况。DAU通常统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户），与UV概念相似</p><p><strong>MAU</strong>(Month Active User)：月活跃用户数量，指网站、app等去重后的月活跃用户数量</p><blockquote><p>线上cpu100%排查</p></blockquote><ol><li>top命令找到最耗cpu的进程</li><li>top -Hp 进程id 找到最耗cpu的线程</li><li>jstack pid 查看线程堆栈</li><li>定位代码</li></ol><blockquote><p>线上内存泄漏排查</p></blockquote><p>1.<code>TOP FREE DF</code> 命令</p><p>2.<code>jstat -gc pid [interval]</code> 命令 查看 java 进程的 GC 状态,排查FGC值</p><p>jstat [-options] pid interval</p><ul><li><p>-class 查看类加载信息</p></li><li><p>-compile 编译统计信息</p></li><li><p>-gc 垃圾回收信息</p></li><li><p>-gcXXX 各区域 GC 的详细信息 如 -gcold</p></li></ul><p>3.使用 <code>jstack pid &gt; jstack.log</code> 保存线程栈现场，使用 <code>jmap -dump:format=b,file=heap.log pid</code> 保存堆现场</p><p>4.分析栈 <code>grep &#39;java.lang.Thread.State&#39; jstack.log | wc -l</code> 查看线程数</p><p>5.下载堆 dump 文件 <code>gzip</code> 设置推荐使用 6~7下载压缩文件,将文件后缀改为 <code>.hprof</code>,使用 MAT 分析 jvm heap,选择 <code>memory leak suspect</code></p>',93),v=[q];function j(f,S,_,P,w,x){return n(),a("div",null,v)}const M=s(k,[["render",j]]);export{O as __pageData,M as default};
