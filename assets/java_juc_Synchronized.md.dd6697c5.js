import{_ as o,o as a,c as s,k as e,a as n,Q as l}from"./chunks/framework.8048b864.js";const L=JSON.parse('{"title":"Synchronized","description":"","frontmatter":{},"headers":[],"relativePath":"java/juc/Synchronized.md","filePath":"java/juc/Synchronized.md","lastUpdated":1719210606000}'),c={name:"java/juc/Synchronized.md"},p=e("h1",{id:"synchronized",tabindex:"-1"},[n("Synchronized "),e("a",{class:"header-anchor",href:"#synchronized","aria-label":'Permalink to "Synchronized"'},"​")],-1),t=e("h2",{id:"用法",tabindex:"-1"},[n("用法 "),e("a",{class:"header-anchor",href:"#用法","aria-label":'Permalink to "用法"'},"​")],-1),r=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,[e("strong",null,"使用位置")]),e("th",null,[e("strong",null,"被锁对象")]),e("th",null,[e("strong",null,"示例代码")])])]),e("tbody",null,[e("tr",{"……":""},[e("td",null,"实例方法"),e("td",null,[e("code",null,"实例对象")]),e("td",null,"public synchronized void method()")]),e("tr",{"……":""},[e("td",null,"静态方法"),e("td",null,[e("code",null,"class类")]),e("td",null,"public static synchronized void method()")]),e("tr",null,[e("td",null,"实例对象"),e("td",null,[e("code",null,"实例对象")]),e("td",null,"public void method() { Object obj = new Object(); synchronized (obj) { …… } }")]),e("tr",null,[e("td",null,"类对象"),e("td",null,[e("code",null,"class类")]),e("td",null,"public void method() { synchronized (Demo.class) { …… } }")]),e("tr",null,[e("td",null,"this关键字"),e("td",null,[e("code",null,"实例对象")]),e("td",null,"public void method() { synchronized (this) { …… } }")])])],-1),i=l(`<p>可以看到被锁对象只要有两种，实例对象和class类。</p><ul><li>由于静态方法可以通过类名直接访问，所以它跟直接加锁在class类上是一样的。</li><li>当在实例方法、实例对象、this关键字上面加锁的时候，锁定范围都是当前实例对象。</li><li>实例对象上面的锁和class类上面的锁，两者不互斥。</li></ul><h2 id="锁原理" tabindex="-1">锁原理 <a class="header-anchor" href="#锁原理" aria-label="Permalink to &quot;锁原理&quot;">​</a></h2><h3 id="字节码编译" tabindex="-1">字节码编译 <a class="header-anchor" href="#字节码编译" aria-label="Permalink to &quot;字节码编译&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291844323.jpg" alt="202405291844323"></p><p>其中最关键的就是<code>monitorenter</code>指令了，可以看到之后也有<code>monitorexit</code>与之进行匹配（注意这里有2个），<code>monitorenter</code>和<code>monitorexit</code>分别对应加锁和释放锁，在执行<code>monitorenter</code>之前需要尝试获取锁，每个对象都有一个<code>monitor</code>监视器与之对应，而这里正是去获取对象监视器的所有权，一旦<code>monitor</code>所有权被某个线程持有，那么其他线程将无法获得（管程模型的一种实现）。</p><p>在代码执行完成之后，我们可以看到，一共有两个<code>monitorexit</code>在等着我们，那么为什么这里会有两个呢，按理说<code>monitorenter</code>和<code>monitorexit</code>不应该一一对应吗，这里为什么要释放锁两次呢？</p><p>首先我们来看第一个，这里在释放锁之后，会马上进入到一个goto指令，跳转到15行，而我们的15行对应的指令就是方法的返回指令，其实正常情况下只会执行第一个<code>monitorexit</code>释放锁，在释放锁之后就接着同步代码块后面的内容继续向下执行了。而第二个，其实是用来处理异常的，可以看到，它的位置是在12行，如果程序运行发生异常，那么就会执行第二个<code>monitorexit</code>，并且会继续向下通过<code>athrow</code>指令抛出异常，而不是直接跳转到15行正常运行下去。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291844495.jpg" alt="e6c9d24ely1gzve59lrkqj21wq0ca76u"></p><p>实际上<code>synchronized</code>使用的锁就是存储在Java对象头中的，我们知道，对象是存放在堆内存中的，而每个对象内部，都有一部分空间用于存储对象头信息，而对象头信息中，则包含了Mark Word用于存放<code>hashCode</code>和对象的锁信息，在不同状态下，它存储的数据结构有一些不同。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291845564.jpg" alt="e6c9d24ely1gzvtjfgg91j21e00howh1"></p><h3 id="synchronized加锁原理" tabindex="-1">Synchronized加锁原理 <a class="header-anchor" href="#synchronized加锁原理" aria-label="Permalink to &quot;Synchronized加锁原理&quot;">​</a></h3><p>通过反编译可以发现</p><ul><li><p>当修饰方法时，编译器会生成 ACC_SYNCHRONIZED 关键字用来标识锁</p></li><li><p>当修饰代码块时，会依赖monitorenter和monitorexit指令，在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计数器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p><blockquote><p>补充说明：</p><p>1.在内存中，对象一般由三部分组成，分别是对象头、对象实际数据和对齐填充。</p><p>2.对象头Mark Word会记录对象关于锁的信息。</p><p>3.每个对象都会有一个与之对应的monitor对象，monitor对象中存储着当前持有锁的线程以及等待锁的线程队列。</p><p>4.monitor对象就会把当前进入线程的Id进行存储，设置Mark Word的monitor对象地址，并把阻塞的线程存储到monitor的等待线程队列中。</p><p>5.加锁是依赖底层操作系统的 <code>mutex</code> 相关指令实现，所以会有用户态和内核态之间的切换</p><p>6.JDK1.6 以后引入偏向锁和轻量级锁在JVM层面实现加锁的逻辑，不依赖底层操作系统，没有切换的消耗</p></blockquote></li></ul><h2 id="锁升级" tabindex="-1">锁升级 <a class="header-anchor" href="#锁升级" aria-label="Permalink to &quot;锁升级&quot;">​</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4169a189714e8a9cf916079d7d2a75~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20221007222109782.png"></p><h3 id="重量级锁" tabindex="-1">重量级锁 <a class="header-anchor" href="#重量级锁" aria-label="Permalink to &quot;重量级锁&quot;">​</a></h3><p>在JDK6之前，<code>synchronized</code>一直被称为重量级锁，<code>monitor</code>依赖于底层操作系统的Lock实现，Java的线程是映射到操作系统的原生线程上，切换成本较高。而在JDK6之后，锁的实现得到了改进。</p><p>每个对象都有一个monitor与之关联，在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ObjectMonitor() {</span></span>
<span class="line"><span style="color:#e1e4e8;">    _header       = NULL;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _count        = 0; //记录个数</span></span>
<span class="line"><span style="color:#e1e4e8;">    _waiters      = 0,</span></span>
<span class="line"><span style="color:#e1e4e8;">    _recursions   = 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _object       = NULL;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _owner        = NULL;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span></span>
<span class="line"><span style="color:#e1e4e8;">    _WaitSetLock  = 0 ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _Responsible  = NULL ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _succ         = NULL ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _cxq          = NULL ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    FreeNext      = NULL ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span></span>
<span class="line"><span style="color:#e1e4e8;">    _SpinFreq     = 0 ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _SpinClock    = 0 ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    OwnerIsThread = 0 ;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ObjectMonitor() {</span></span>
<span class="line"><span style="color:#24292e;">    _header       = NULL;</span></span>
<span class="line"><span style="color:#24292e;">    _count        = 0; //记录个数</span></span>
<span class="line"><span style="color:#24292e;">    _waiters      = 0,</span></span>
<span class="line"><span style="color:#24292e;">    _recursions   = 0;</span></span>
<span class="line"><span style="color:#24292e;">    _object       = NULL;</span></span>
<span class="line"><span style="color:#24292e;">    _owner        = NULL;</span></span>
<span class="line"><span style="color:#24292e;">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span></span>
<span class="line"><span style="color:#24292e;">    _WaitSetLock  = 0 ;</span></span>
<span class="line"><span style="color:#24292e;">    _Responsible  = NULL ;</span></span>
<span class="line"><span style="color:#24292e;">    _succ         = NULL ;</span></span>
<span class="line"><span style="color:#24292e;">    _cxq          = NULL ;</span></span>
<span class="line"><span style="color:#24292e;">    FreeNext      = NULL ;</span></span>
<span class="line"><span style="color:#24292e;">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span></span>
<span class="line"><span style="color:#24292e;">    _SpinFreq     = 0 ;</span></span>
<span class="line"><span style="color:#24292e;">    _SpinClock    = 0 ;</span></span>
<span class="line"><span style="color:#24292e;">    OwnerIsThread = 0 ;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>每个等待锁的线程都会被封装成ObjectWaiter对象，进入到如下机制：</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291845709.png" alt="image-20220405200909856"></p><p>ObjectWaiter首先会进入 Entry Set等着，当线程获取到对象的<code>monitor</code>后进入 The Owner 区域并把<code>monitor</code>中的<code>owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>count</code>加1，若线程调用<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>owner</code>变量恢复为<code>null</code>，<code>count</code>自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取对象的<code>monitor</code>。</p><p>虽然这样的设计思路非常合理，但是在大多数应用上，每一个线程占用同步代码块的时间并不是很长，我们完全没有必要将竞争中的线程挂起然后又唤醒，并且现代CPU基本都是多核心运行的，我们可以采用一种新的思路来实现锁。</p><p>在JDK1.4.2时，引入了自旋锁（JDK6之后默认开启），它不会将处于等待状态的线程挂起，而是通过无限循环的方式，不断检测是否能够获取锁，由于单个线程占用锁的时间非常短，所以说循环次数不会太多，可能很快就能够拿到锁并运行，这就是自旋锁。当然，仅仅是在等待时间非常短的情况下，自旋锁的表现会很好，但是如果等待时间太长，由于循环是需要处理器继续运算的，所以这样只会浪费处理器资源，因此自旋锁的等待时间是有限制的，默认情况下为10次，如果失败，那么会进而采用重量级锁机制。</p><p>在JDK6之后，自旋锁得到了一次优化，自旋的次数限制不再是固定的，而是自适应变化的，比如在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么这次自旋也是有可能成功的，所以会允许自旋更多次。当然，如果某个锁经常都自旋失败，那么有可能会不再采用自旋策略，而是直接使用重量级锁。</p><h3 id="轻量级锁" tabindex="-1">轻量级锁 <a class="header-anchor" href="#轻量级锁" aria-label="Permalink to &quot;轻量级锁&quot;">​</a></h3><p>从JDK 1.6开始，为了减少获得锁和释放锁带来的性能消耗，就引入了轻量级锁。</p><p>轻量级锁的目标是，在无竞争情况下，减少重量级锁产生的性能消耗（并不是为了代替重量级锁，实际上就是赌一手同一时间只有一个线程在占用资源），包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。它不像是重量级锁那样，需要向操作系统申请互斥量。它的运作机制如下：</p><p>在即将开始执行同步代码块中的内容时，会首先检查对象的Mark Word，查看锁对象是否被其他线程占用，如果没有任何线程占用，那么会在当前线程中所处的栈帧中建立一个名为锁记录（Lock Record）的空间，用于复制并存储对象目前的Mark Word信息（官方称为Displaced Mark Word）。</p><p>接着，虚拟机将使用CAS操作将对象的Mark Word更新为轻量级锁状态（数据结构变为指向Lock Record的指针，指向的是当前的栈帧）</p><blockquote><p>在CPU中，CAS操作使用的是<code>cmpxchg</code>指令，能够从最底层硬件层面得到效率的提升。</p></blockquote><p>如果CAS操作失败了的话，那么说明可能这时有线程已经进入这个同步代码块了，这时虚拟机会再次检查对象的Mark Word，是否指向当前线程的栈帧，如果是，说明不是其他线程，而是当前线程已经有了这个对象的锁，直接放心大胆进同步代码块即可。如果不是，那确实是被其他线程占用了。</p><p>这时，轻量级锁一开始的想法就是错的（这时有对象在竞争资源，已经赌输了），所以说只能将锁膨胀为重量级锁，按照重量级锁的操作执行（注意锁的膨胀是不可逆的）</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291846596.png" alt="image-20220405201001305"></p><p>所以，轻量级锁 -&gt; 失败 -&gt; 自适应自旋锁 -&gt; 失败 -&gt; 重量级锁</p><p>解锁过程同样采用CAS算法，如果对象的MarkWord仍然指向线程的锁记录，那么就用CAS操作把对象的MarkWord和复制到栈帧中的Displaced Mark Word进行交换。如果替换失败，说明其他线程尝试过获取该锁，在释放锁的同时，需要唤醒被挂起的线程。</p><h3 id="偏向锁" tabindex="-1">偏向锁 <a class="header-anchor" href="#偏向锁" aria-label="Permalink to &quot;偏向锁&quot;">​</a></h3><p>偏向锁相比轻量级锁更纯粹，干脆就把整个同步都消除掉，不需要再进行CAS操作了。它的出现主要是得益于人们发现某些情况下某个锁频繁地被同一个线程获取，这种情况下，我们可以对轻量级锁进一步优化。</p><p>偏向锁实际上就是专门为单个线程而生的，当某个线程第一次获得锁时，如果接下来都没有其他线程获取此锁，那么持有锁的线程将不再需要进行同步操作。</p><p>可以从之前的MarkWord结构中看到，偏向锁也会通过CAS操作记录线程的ID，如果一直都是同一个线程获取此锁，那么完全没有必要在进行额外的CAS操作。当然，如果有其他线程来抢了，那么偏向锁会根据当前状态，决定是否要恢复到未锁定或是膨胀为轻量级锁。</p><p>如果我们需要使用偏向锁，可以添加<code>-XX:+UseBiased</code>参数来开启。</p><p>所以，最终的锁等级为：未锁定 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁</p><p>值得注意的是，如果对象通过调用<code>hashCode()</code>方法计算过对象的一致性哈希值，那么它是不支持偏向锁的，会直接进入到轻量级锁状态，因为Hash是需要被保存的，而偏向锁的Mark Word数据结构，无法保存Hash值；如果对象已经是偏向锁状态，再去调用<code>hashCode()</code>方法，那么会直接将锁升级为重量级锁，并将哈希值存放在<code>monitor</code>（有预留位置保存）中。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291846097.png" alt="image-20220405201028135"></p><blockquote><p>简单概括<code>锁升级</code>：</p><p><code>偏向锁</code>指的就是JVM会认为只有某个线程才会执行同步代码，所以在Mark Word会直接记录线程ID，只要线程来执行代码了，会比对线程ID是否相等，相等则当前线程能直接获取得到锁，执行同步代码；如果不相等，则用CAS来尝试修改当前的线程ID，如果CAS修改成功，那还是能获取得到锁，执行同步代码。</p><p>如果CAS失败了，说明有竞争环境，此时会对偏向锁撤销，升级为<code>轻量级锁</code>。</p><p>在轻量级锁状态下，当前线程会在栈帧下创建Lock Record，LockRecord 会把Mark Word的信息拷贝进去，且有个Owner指针指向加锁的对象,线程执行到同步代码时，则用CAS试图将Mark Word的指向到线程栈帧的Lock Record，假设CAS修改成功，则获取得到轻量级锁;假设修改失败，则自旋（重试），自旋一定次数后，则升级为<code>重量级锁</code>。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405291846646.png" alt="image-20230207161524135"></p>`,47),d=[p,t,r,i];function h(u,m,y,_,g,b){return a(),s("div",null,d)}const S=o(c,[["render",h]]);export{L as __pageData,S as default};
