import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.8048b864.js";const p="/assets/image-20220405200130691.25217ec9.png",o="/assets/image-20220406101540742.db15bc3a.png",e="/assets/e6c9d24ely1gzwtkeydk7j2194068jsd.aa214fd0.jpg",t="/assets/e6c9d24ely1gzvdbajqhfj229a0u0te0.5a16c65c.jpg",c="/assets/e6c9d24ely1gzve59lrkqj21wq0ca76u.f1abc344.jpg",r="/assets/e6c9d24ely1gzvtjfgg91j21e00howh1.edff8a3d.jpg",E="/assets/image-20230207161027593.f5573ade.png",y="/assets/image-20220405200909856.c7a8afd2.png",i="/assets/image-20220405200921538.3d39fe90.png",F="/assets/image-20220405201001305.66947687.png",u="/assets/image-20220405201028135.a46099ef.png",A="/assets/image-20230207161524135.c0f78f1b.png",d="/assets/e6c9d24ely1h016lyg63ij21ew0dsgnt.e5b8f8d2.jpg",D="/assets/e6c9d24ely1h016s4p0rfj21as0hg76w.669a1c67.jpg",C="/assets/e6c9d24ely1h018ts8x80j21to0eidix.dc3ca18b.jpg",h="/assets/image-20220406102137754.c1d49d07.png",g="/assets/image-20220406102232375.970b3c55.png",B="/assets/image-20220406102601299.016bc980.png",m="/assets/image-20220406102943972.91957123.png",b="/assets/image-20220406103844984.215420e8.png",k="/assets/e6c9d24egy1h02eg5qcfaj21pa0ekju1.f9cbe7d9.jpg",v="/assets/image-20220406100926787.f2b8031e.png",S="/assets/image-20220406181701396.c38b4853.png",f="/assets/image-20220405201620171.3b07f9ef.png",w="/assets/e6c9d24ely1h004uzeni8j224k0ca0w9.f320b575.jpg",x="/assets/e6c9d24ely1h007thq2x1j22ce0k879c.fb309f83.jpg",q="/assets/image-20220406112223538.6b32a17b.png",V=JSON.parse('{"title":"Java多线程","description":"","frontmatter":{},"headers":[],"relativePath":"java/juc.md","filePath":"java/juc.md","lastUpdated":1697176108000}'),T={name:"java/juc.md"},I=l('<h1 id="java多线程" tabindex="-1">Java多线程 <a class="header-anchor" href="#java多线程" aria-label="Permalink to &quot;Java多线程&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#原理篇">原理篇</a><ul><li><a href="#jmm内存模型">JMM内存模型</a></li></ul></li><li><a href="#源码篇">源码篇</a><ul><li><a href="#cas">CAS</a></li><li><a href="#volatile">Volatile</a></li><li><a href="#synchronized">Synchronized</a></li><li><a href="#reentrantlock">ReentrantLock</a></li><li><a href="#readwritelock">ReadWriteLock</a></li><li><a href="#condition">Condition</a></li><li><a href="#并发容器">并发容器</a></li><li><a href="#阻塞队列">阻塞队列</a></li><li><a href="#原子类">原子类</a></li><li><a href="#并发工具类">并发工具类</a></li><li><a href="#队列同步器aqs">队列同步器AQS</a></li><li><a href="#线程池">线程池</a></li></ul></li><li><a href="#应用篇">应用篇</a><ul><li><a href="#如何创建线程">如何创建线程</a></li><li><a href="#手写一把锁">手写一把锁</a></li><li><a href="#生产者消费者模型">生产者消费者模型</a></li><li><a href="#completablefuture应用">CompletableFuture应用</a></li></ul></li></ul></nav><h2 id="原理篇" tabindex="-1">原理篇 <a class="header-anchor" href="#原理篇" aria-label="Permalink to &quot;原理篇&quot;">​</a></h2><h3 id="jmm内存模型" tabindex="-1">JMM内存模型 <a class="header-anchor" href="#jmm内存模型" aria-label="Permalink to &quot;JMM内存模型&quot;">​</a></h3><h4 id="java内存模型" tabindex="-1">Java内存模型 <a class="header-anchor" href="#java内存模型" aria-label="Permalink to &quot;Java内存模型&quot;">​</a></h4><p><img src="'+p+`" alt="image-20220405200130691"></p><p>JMM（Java Memory Model）内存模型规定如下：</p><ul><li>所有的变量全部存储在主内存（注意这里包括下面提到的变量，指的都是会出现竞争的变量，包括成员变量、静态变量等，而局部变量这种属于线程私有，不包括在内）</li><li>每条线程有着自己的工作内存（可以类比CPU的高速缓存）线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li><li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li></ul><p>也就是说，每一条线程如果要操作主内存中的数据，那么得先拷贝到自己的工作内存中，并对工作内存中数据的副本进行操作，操作完成之后，也需要从工作副本中将结果拷贝回主内存中，具体的操作就是<code>Save</code>（保存）和<code>Load</code>（加载）操作。</p><p>具体实现：</p><ul><li>主内存：对应堆中存放对象的实例的部分。</li><li>工作内存：对应线程的虚拟机栈的部分区域，虚拟机可能会对这部分内存进行优化，将其放在CPU的寄存器或是高速缓存中。比如在访问数组时，由于数组是一段连续的内存空间，所以可以将一部分连续空间放入到CPU高速缓存中，那么之后如果我们顺序读取这个数组，那么大概率会直接缓存命中。</li></ul><h4 id="重排序原理" tabindex="-1">重排序原理 <a class="header-anchor" href="#重排序原理" aria-label="Permalink to &quot;重排序原理&quot;">​</a></h4><p>在编译或执行时，为了优化程序的执行效率，编译器或处理器常常会对指令进行重排序，有以下情况：</p><ol><li>编译器重排序：Java编译器通过对Java代码语义的理解，根据优化规则对代码指令进行重排序。</li><li>机器指令级别的重排序：现代处理器很高级，能够自主判断和变更机器指令的执行顺序。</li></ol><p>指令重排序能够在不改变结果（单线程）的情况下，优化程序的运行效率</p><h4 id="happens-before原则" tabindex="-1">happens-before原则 <a class="header-anchor" href="#happens-before原则" aria-label="Permalink to &quot;happens-before原则&quot;">​</a></h4><p>JMM提出了<code>happens-before</code>（先行发生）原则，定义一些禁止编译优化的场景，来向各位程序员做一些保证，只要我们是按照原则进行编程，那么就能够保持并发编程的正确性。具体如下：</p><ul><li>**程序次序规则：**同一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。 <ul><li>同一个线程内，代码的执行结果是有序的。其实就是，可能会发生指令重排，但是保证代码的执行结果一定是和按照顺序执行得到的一致，程序前面对某一个变量的修改一定对后续操作可见的，不可能会出现前面才把a修改为1，接着读a居然是修改前的结果，这也是程序运行最基本的要求。</li></ul></li><li>**监视器锁规则：**对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。 <ul><li>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。比如前一个线程将变量<code>x</code>的值修改为了<code>12</code>并解锁，之后另一个线程拿到了这把锁，对之前线程的操作是可见的，可以得到<code>x</code>是前一个线程修改后的结果<code>12</code>（所以synchronized是有happens-before规则的）</li></ul></li><li>**volatile变量规则：**对一个volatile变量的写操作happens-before后续对这个变量的读操作。 <ul><li>就是如果一个线程先去写一个<code>volatile</code>变量，紧接着另一个线程去读这个变量，那么这个写操作的结果一定对读的这个变量的线程可见。</li></ul></li><li>**线程启动规则：**主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。 <ul><li>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li></ul></li><li>**线程加入规则：**如果线程A执行操作<code>join()</code>线程B并成功返回，那么线程B中的任意操作happens-before线程A<code>join()</code>操作成功返回。</li><li>**传递性规则：**如果A happens-before B，B happens-before C，那么A happens-before C。</li></ul><p>从happens-before原则的角度，来解释一下下面的程序结果：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(b </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">) System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(a); </span></span>
<span class="line"><span style="color:#E1E4E8;">        }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Main</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(b </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">) System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(a); </span></span>
<span class="line"><span style="color:#24292E;">        }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>我们定义以上出现的操作：</p><ul><li>**A：**将变量<code>a</code>的值修改为<code>10</code></li><li>**B：**将变量<code>b</code>的值修改为<code>a + 1</code></li><li>**C：**主线程启动了一个新的线程，并在新的线程中获取<code>b</code>，进行判断，如果大于<code>10</code>那么就打印<code>a</code></li></ul><p>我们来分析，由于是同一个线程，并且<strong>B</strong>是一个赋值操作且读取了<strong>A</strong>，那么按照<strong>程序次序规则</strong>，A happens-before B，接着在B之后，马上执行了C，按照<strong>线程启动规则</strong>，在新的线程启动之前，当前线程之前的所有操作对新的线程是可见的，所以 B happens-before C，最后根据<strong>传递性规则</strong>，由于A happens-before B，B happens-before C，所以A happens-before C，因此在新的线程中会输出<code>a</code>修改后的结果<code>10</code>。</p><h2 id="源码篇" tabindex="-1">源码篇 <a class="header-anchor" href="#源码篇" aria-label="Permalink to &quot;源码篇&quot;">​</a></h2><h3 id="cas" tabindex="-1">CAS <a class="header-anchor" href="#cas" aria-label="Permalink to &quot;CAS&quot;">​</a></h3><blockquote><p>CAS的全称为compare and swap,对应到CPU指令为<code>cmpxchg</code></p></blockquote><p>CAS 有三个操作数：当前值A、内存值V、要修改的新值B</p><p>假设 当前值A 跟 内存值V 相等，那就将 内存值V 改成B</p><p>假设 当前值A 跟 内存值V 不相等，要么就重试，要么就放弃更新</p><h4 id="aba问题及解决方案" tabindex="-1">ABA问题及解决方案 <a class="header-anchor" href="#aba问题及解决方案" aria-label="Permalink to &quot;ABA问题及解决方案&quot;">​</a></h4><p><img src="`+o+`" alt="image-20220406101540742"></p><p>线程1和线程2同时开始对<code>a</code>的值进行CAS修改，但是线程1的速度比较快，将a的值修改为2之后紧接着又修改回1，这时线程2才开始进行判断，发现a的值是1，所以CAS操作成功。</p><p>很明显，这里的1已经不是一开始的那个1了，而是被重新赋值的1，这也是CAS操作存在的问题（无锁虽好，但是问题多多），它只会机械地比较当前值是不是预期值，但是并不会关心当前值是否被修改过，这种问题称之为<code>ABA</code>问题。</p><p><strong>采用 AtomicStampedReference 解决ABA问题</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    String a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Hello&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    String b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;World&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    AtomicStampedReference&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; reference </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> AtomicStampedReference&lt;&gt;(a, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">//在构造时需要指定初始值和对应的版本号</span></span>
<span class="line"><span style="color:#E1E4E8;">    reference.</span><span style="color:#B392F0;">attemptStamp</span><span style="color:#E1E4E8;">(a, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//可以中途对版本号进行修改，注意要填写当前的引用对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(reference.</span><span style="color:#B392F0;">compareAndSet</span><span style="color:#E1E4E8;">(a, b, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">));   </span><span style="color:#6A737D;">//CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    String a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    String b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;World&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    AtomicStampedReference&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; reference </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> AtomicStampedReference&lt;&gt;(a, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">//在构造时需要指定初始值和对应的版本号</span></span>
<span class="line"><span style="color:#24292E;">    reference.</span><span style="color:#6F42C1;">attemptStamp</span><span style="color:#24292E;">(a, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//可以中途对版本号进行修改，注意要填写当前的引用对象</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(reference.</span><span style="color:#6F42C1;">compareAndSet</span><span style="color:#24292E;">(a, b, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">));   </span><span style="color:#6A737D;">//CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>1</p><h3 id="volatile" tabindex="-1">Volatile <a class="header-anchor" href="#volatile" aria-label="Permalink to &quot;Volatile&quot;">​</a></h3><h4 id="源码分析" tabindex="-1">源码分析 <a class="header-anchor" href="#源码分析" aria-label="Permalink to &quot;源码分析&quot;">​</a></h4><p>Java 中的一个关键字，当一个变量是共享变量，同时被 <code>volatile</code> 修饰当值被更改的时候，其他线程再读取该变量的时候可以保证能获取到修改后的值，通过 JMM 屏蔽掉各种硬件和操作系统的内存访问差异 以及 CPU 多级缓存等导致的数据不一致问题。</p><ul><li><p>保证变量的可见性</p><p>当写一个<code>volatile</code>变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，并且这个写操作会导致其他线程中的<code>volatile</code>变量缓存无效，这样，另一个线程修改了这个变时，当前线程会立即得知，并将工作内存中的变量更新为最新的版本。</p></li><li><p>禁止指令重排</p><p>用volatile修饰共享变量，在编译时，会在指令序列中插入<code>内存屏障</code>来禁止特定类型的处理器重排序</p></li></ul><blockquote><p>内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p><ol><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性（volatile的内存可见性，其实就是依靠这个实现的）</li></ol><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序。</p><p><img src="`+e+`" alt="image-20220303172519404"></p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1;LoadLoad;Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1;StoreStore;Store2</td><td>在Store2及其后的写操作执行前，保证Store1的写操作已刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1;LoadStore;Store2</td><td>在Store2及其后的写操作执行前，保证Load1的读操作已读取结束</td></tr><tr><td>StoreLoad</td><td>Store1;StoreLoad;Load2</td><td>保证load1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td></tr></tbody></table></blockquote><h4 id="开发应用" tabindex="-1">开发应用 <a class="header-anchor" href="#开发应用" aria-label="Permalink to &quot;开发应用&quot;">​</a></h4><h5 id="双重检查-单例模式" tabindex="-1">双重检查（单例模式） <a class="header-anchor" href="#双重检查-单例模式" aria-label="Permalink to &quot;双重检查（单例模式）&quot;">​</a></h5><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Singleton</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> Singleton instance </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Singleton</span><span style="color:#E1E4E8;">(){}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> Singleton </span><span style="color:#B392F0;">getInstance</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (instance </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">synchronized</span><span style="color:#E1E4E8;"> (Singleton.class) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (instance </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    instance </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Singleton</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> instance;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Singleton</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> Singleton instance </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Singleton</span><span style="color:#24292E;">(){}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> Singleton </span><span style="color:#6F42C1;">getInstance</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (instance </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> (Singleton.class) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (instance </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    instance </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Singleton</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> instance;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="synchronized" tabindex="-1">Synchronized <a class="header-anchor" href="#synchronized" aria-label="Permalink to &quot;Synchronized&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">synchronized</span><span style="color:#E1E4E8;"> (Main.class) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">//这里使用的是Main类的Class对象作为锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> (Main.class) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//这里使用的是Main类的Class对象作为锁</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="锁原理" tabindex="-1">锁原理 <a class="header-anchor" href="#锁原理" aria-label="Permalink to &quot;锁原理&quot;">​</a></h4><h5 id="字节码编译" tabindex="-1">字节码编译<img src="`+t+'" alt="image-20220302111724784"> <a class="header-anchor" href="#字节码编译" aria-label="Permalink to &quot;字节码编译![image-20220302111724784](resources/e6c9d24ely1gzvdbajqhfj229a0u0te0.jpg)&quot;">​</a></h5><p>其中最关键的就是<code>monitorenter</code>指令了，可以看到之后也有<code>monitorexit</code>与之进行匹配（注意这里有2个），<code>monitorenter</code>和<code>monitorexit</code>分别对应加锁和释放锁，在执行<code>monitorenter</code>之前需要尝试获取锁，每个对象都有一个<code>monitor</code>监视器与之对应，而这里正是去获取对象监视器的所有权，一旦<code>monitor</code>所有权被某个线程持有，那么其他线程将无法获得（管程模型的一种实现）。</p><p>在代码执行完成之后，我们可以看到，一共有两个<code>monitorexit</code>在等着我们，那么为什么这里会有两个呢，按理说<code>monitorenter</code>和<code>monitorexit</code>不应该一一对应吗，这里为什么要释放锁两次呢？</p><p>首先我们来看第一个，这里在释放锁之后，会马上进入到一个goto指令，跳转到15行，而我们的15行对应的指令就是方法的返回指令，其实正常情况下只会执行第一个<code>monitorexit</code>释放锁，在释放锁之后就接着同步代码块后面的内容继续向下执行了。而第二个，其实是用来处理异常的，可以看到，它的位置是在12行，如果程序运行发生异常，那么就会执行第二个<code>monitorexit</code>，并且会继续向下通过<code>athrow</code>指令抛出异常，而不是直接跳转到15行正常运行下去。</p><p><img src="'+c+'" alt="image-20220302114613847"></p><p>实际上<code>synchronized</code>使用的锁就是存储在Java对象头中的，我们知道，对象是存放在堆内存中的，而每个对象内部，都有一部分空间用于存储对象头信息，而对象头信息中，则包含了Mark Word用于存放<code>hashCode</code>和对象的锁信息，在不同状态下，它存储的数据结构有一些不同。</p><p><img src="'+r+'" alt="image-20220302203846868"></p><h5 id="加锁原理" tabindex="-1">加锁原理 <a class="header-anchor" href="#加锁原理" aria-label="Permalink to &quot;加锁原理&quot;">​</a></h5><p>通过反编译可以发现</p><ul><li><p>当修饰方法时，编译器会生成 ACC_SYNCHRONIZED 关键字用来标识锁</p></li><li><p>当修饰代码块时，会依赖monitorenter和monitorexit指令，在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计数器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p><blockquote><p>补充说明：</p><p>1.在内存中，对象一般由三部分组成，分别是对象头、对象实际数据和对齐填充。</p><p>2.对象头Mark Word会记录对象关于锁的信息。</p><p>3.每个对象都会有一个与之对应的monitor对象，monitor对象中存储着当前持有锁的线程以及等待锁的线程队列。</p><p>4.monitor对象就会把当前进入线程的Id进行存储，设置Mark Word的monitor对象地址，并把阻塞的线程存储到monitor的等待线程队列中。</p><p>5.加锁是依赖底层操作系统的 <code>mutex</code> 相关指令实现，所以会有用户态和内核态之间的切换</p><p>6.JDK1.6 以后引入偏向锁和轻量级锁在JVM层面实现加锁的逻辑，不依赖底层操作系统，没有切换的消耗</p><p><img src="'+E+`" alt="image-20230207161027593"></p></blockquote></li></ul><h4 id="锁升级" tabindex="-1">锁升级 <a class="header-anchor" href="#锁升级" aria-label="Permalink to &quot;锁升级&quot;">​</a></h4><h5 id="重量级锁" tabindex="-1">重量级锁 <a class="header-anchor" href="#重量级锁" aria-label="Permalink to &quot;重量级锁&quot;">​</a></h5><p>在JDK6之前，<code>synchronized</code>一直被称为重量级锁，<code>monitor</code>依赖于底层操作系统的Lock实现，Java的线程是映射到操作系统的原生线程上，切换成本较高。而在JDK6之后，锁的实现得到了改进。</p><p>每个对象都有一个monitor与之关联，在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ObjectMonitor() {</span></span>
<span class="line"><span style="color:#e1e4e8;">    _header       = NULL;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _count        = 0; //记录个数</span></span>
<span class="line"><span style="color:#e1e4e8;">    _waiters      = 0,</span></span>
<span class="line"><span style="color:#e1e4e8;">    _recursions   = 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _object       = NULL;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _owner        = NULL;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span></span>
<span class="line"><span style="color:#e1e4e8;">    _WaitSetLock  = 0 ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _Responsible  = NULL ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _succ         = NULL ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _cxq          = NULL ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    FreeNext      = NULL ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span></span>
<span class="line"><span style="color:#e1e4e8;">    _SpinFreq     = 0 ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    _SpinClock    = 0 ;</span></span>
<span class="line"><span style="color:#e1e4e8;">    OwnerIsThread = 0 ;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ObjectMonitor() {</span></span>
<span class="line"><span style="color:#24292e;">    _header       = NULL;</span></span>
<span class="line"><span style="color:#24292e;">    _count        = 0; //记录个数</span></span>
<span class="line"><span style="color:#24292e;">    _waiters      = 0,</span></span>
<span class="line"><span style="color:#24292e;">    _recursions   = 0;</span></span>
<span class="line"><span style="color:#24292e;">    _object       = NULL;</span></span>
<span class="line"><span style="color:#24292e;">    _owner        = NULL;</span></span>
<span class="line"><span style="color:#24292e;">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span></span>
<span class="line"><span style="color:#24292e;">    _WaitSetLock  = 0 ;</span></span>
<span class="line"><span style="color:#24292e;">    _Responsible  = NULL ;</span></span>
<span class="line"><span style="color:#24292e;">    _succ         = NULL ;</span></span>
<span class="line"><span style="color:#24292e;">    _cxq          = NULL ;</span></span>
<span class="line"><span style="color:#24292e;">    FreeNext      = NULL ;</span></span>
<span class="line"><span style="color:#24292e;">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span></span>
<span class="line"><span style="color:#24292e;">    _SpinFreq     = 0 ;</span></span>
<span class="line"><span style="color:#24292e;">    _SpinClock    = 0 ;</span></span>
<span class="line"><span style="color:#24292e;">    OwnerIsThread = 0 ;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>每个等待锁的线程都会被封装成ObjectWaiter对象，进入到如下机制：</p><p><img src="`+y+'" alt="image-20220405200909856"></p><p>ObjectWaiter首先会进入 Entry Set等着，当线程获取到对象的<code>monitor</code>后进入 The Owner 区域并把<code>monitor</code>中的<code>owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>count</code>加1，若线程调用<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>owner</code>变量恢复为<code>null</code>，<code>count</code>自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取对象的<code>monitor</code>。</p><p>虽然这样的设计思路非常合理，但是在大多数应用上，每一个线程占用同步代码块的时间并不是很长，我们完全没有必要将竞争中的线程挂起然后又唤醒，并且现代CPU基本都是多核心运行的，我们可以采用一种新的思路来实现锁。</p><p>在JDK1.4.2时，引入了自旋锁（JDK6之后默认开启），它不会将处于等待状态的线程挂起，而是通过无限循环的方式，不断检测是否能够获取锁，由于单个线程占用锁的时间非常短，所以说循环次数不会太多，可能很快就能够拿到锁并运行，这就是自旋锁。当然，仅仅是在等待时间非常短的情况下，自旋锁的表现会很好，但是如果等待时间太长，由于循环是需要处理器继续运算的，所以这样只会浪费处理器资源，因此自旋锁的等待时间是有限制的，默认情况下为10次，如果失败，那么会进而采用重量级锁机制。</p><p><img src="'+i+'" alt="image-20220405200921538"></p><p>在JDK6之后，自旋锁得到了一次优化，自旋的次数限制不再是固定的，而是自适应变化的，比如在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么这次自旋也是有可能成功的，所以会允许自旋更多次。当然，如果某个锁经常都自旋失败，那么有可能会不再采用自旋策略，而是直接使用重量级锁。</p><h5 id="轻量级锁" tabindex="-1">轻量级锁 <a class="header-anchor" href="#轻量级锁" aria-label="Permalink to &quot;轻量级锁&quot;">​</a></h5><p>从JDK 1.6开始，为了减少获得锁和释放锁带来的性能消耗，就引入了轻量级锁。</p><p>轻量级锁的目标是，在无竞争情况下，减少重量级锁产生的性能消耗（并不是为了代替重量级锁，实际上就是赌一手同一时间只有一个线程在占用资源），包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。它不像是重量级锁那样，需要向操作系统申请互斥量。它的运作机制如下：</p><p>在即将开始执行同步代码块中的内容时，会首先检查对象的Mark Word，查看锁对象是否被其他线程占用，如果没有任何线程占用，那么会在当前线程中所处的栈帧中建立一个名为锁记录（Lock Record）的空间，用于复制并存储对象目前的Mark Word信息（官方称为Displaced Mark Word）。</p><p>接着，虚拟机将使用CAS操作将对象的Mark Word更新为轻量级锁状态（数据结构变为指向Lock Record的指针，指向的是当前的栈帧）</p><blockquote><p>在CPU中，CAS操作使用的是<code>cmpxchg</code>指令，能够从最底层硬件层面得到效率的提升。</p></blockquote><p>如果CAS操作失败了的话，那么说明可能这时有线程已经进入这个同步代码块了，这时虚拟机会再次检查对象的Mark Word，是否指向当前线程的栈帧，如果是，说明不是其他线程，而是当前线程已经有了这个对象的锁，直接放心大胆进同步代码块即可。如果不是，那确实是被其他线程占用了。</p><p>这时，轻量级锁一开始的想法就是错的（这时有对象在竞争资源，已经赌输了），所以说只能将锁膨胀为重量级锁，按照重量级锁的操作执行（注意锁的膨胀是不可逆的）</p><p><img src="'+F+'" alt="image-20220405201001305"></p><p>所以，轻量级锁 -&gt; 失败 -&gt; 自适应自旋锁 -&gt; 失败 -&gt; 重量级锁</p><p>解锁过程同样采用CAS算法，如果对象的MarkWord仍然指向线程的锁记录，那么就用CAS操作把对象的MarkWord和复制到栈帧中的Displaced Mark Word进行交换。如果替换失败，说明其他线程尝试过获取该锁，在释放锁的同时，需要唤醒被挂起的线程。</p><h5 id="偏向锁" tabindex="-1">偏向锁 <a class="header-anchor" href="#偏向锁" aria-label="Permalink to &quot;偏向锁&quot;">​</a></h5><p>偏向锁相比轻量级锁更纯粹，干脆就把整个同步都消除掉，不需要再进行CAS操作了。它的出现主要是得益于人们发现某些情况下某个锁频繁地被同一个线程获取，这种情况下，我们可以对轻量级锁进一步优化。</p><p>偏向锁实际上就是专门为单个线程而生的，当某个线程第一次获得锁时，如果接下来都没有其他线程获取此锁，那么持有锁的线程将不再需要进行同步操作。</p><p>可以从之前的MarkWord结构中看到，偏向锁也会通过CAS操作记录线程的ID，如果一直都是同一个线程获取此锁，那么完全没有必要在进行额外的CAS操作。当然，如果有其他线程来抢了，那么偏向锁会根据当前状态，决定是否要恢复到未锁定或是膨胀为轻量级锁。</p><p>如果我们需要使用偏向锁，可以添加<code>-XX:+UseBiased</code>参数来开启。</p><p>所以，最终的锁等级为：未锁定 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁</p><p>值得注意的是，如果对象通过调用<code>hashCode()</code>方法计算过对象的一致性哈希值，那么它是不支持偏向锁的，会直接进入到轻量级锁状态，因为Hash是需要被保存的，而偏向锁的Mark Word数据结构，无法保存Hash值；如果对象已经是偏向锁状态，再去调用<code>hashCode()</code>方法，那么会直接将锁升级为重量级锁，并将哈希值存放在<code>monitor</code>（有预留位置保存）中。</p><p><img src="'+u+'" alt="image-20220405201028135"></p><blockquote><p>简单概括<code>锁升级</code>：</p><p><code>偏向锁</code>指的就是JVM会认为只有某个线程才会执行同步代码，所以在Mark Word会直接记录线程ID，只要线程来执行代码了，会比对线程ID是否相等，相等则当前线程能直接获取得到锁，执行同步代码；如果不相等，则用CAS来尝试修改当前的线程ID，如果CAS修改成功，那还是能获取得到锁，执行同步代码。</p><p>如果CAS失败了，说明有竞争环境，此时会对偏向锁撤销，升级为<code>轻量级锁</code>。</p><p>在轻量级锁状态下，当前线程会在栈帧下创建Lock Record，LockRecord 会把Mark Word的信息拷贝进去，且有个Owner指针指向加锁的对象,线程执行到同步代码时，则用CAS试图将Mark Word的指向到线程栈帧的Lock Record，假设CAS修改成功，则获取得到轻量级锁;假设修改失败，则自旋（重试），自旋一定次数后，则升级为<code>重量级锁</code>。</p><p><img src="'+A+`" alt="image-20230207161524135"></p></blockquote><h3 id="reentrantlock" tabindex="-1">ReentrantLock <a class="header-anchor" href="#reentrantlock" aria-label="Permalink to &quot;ReentrantLock&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Lock</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//获取锁，拿不到锁会阻塞，等待其他线程释放锁，获取到锁后返回</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//同上，但是等待过程中会响应中断</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lockInterruptibly</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//尝试获取锁，但是不会阻塞，如果能获取到会返回true，不能返回false</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//尝试获取锁，但是可以限定超时时间，如果超出时间还没拿到锁返回false，否则返回true，可以响应中断</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryLock</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">time</span><span style="color:#E1E4E8;">, TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//释放锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">    Condition </span><span style="color:#B392F0;">newCondition</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Lock</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//获取锁，拿不到锁会阻塞，等待其他线程释放锁，获取到锁后返回</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//同上，但是等待过程中会响应中断</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lockInterruptibly</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//尝试获取锁，但是不会阻塞，如果能获取到会返回true，不能返回false</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//尝试获取锁，但是可以限定超时时间，如果超出时间还没拿到锁返回false，否则返回true，可以响应中断</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryLock</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">time</span><span style="color:#24292E;">, TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//释放锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">    Condition </span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="readwritelock" tabindex="-1">ReadWriteLock <a class="header-anchor" href="#readwritelock" aria-label="Permalink to &quot;ReadWriteLock&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReadWriteLock</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取读锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    Lock </span><span style="color:#B392F0;">readLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">// 获取写锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    Lock </span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReadWriteLock</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取读锁</span></span>
<span class="line"><span style="color:#24292E;">    Lock </span><span style="color:#6F42C1;">readLock</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">// 获取写锁</span></span>
<span class="line"><span style="color:#24292E;">    Lock </span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>读写锁在同一时间，是可以让多个线程获取到锁的，它其实就是针对于读写场景而出现的。读写锁维护了一个读锁和一个写锁，这两个锁的机制是不同的。</p><ul><li>读锁：在没有任何线程占用写锁的情况下，同一时间可以有多个线程加读锁。</li><li>写锁：在没有任何线程占用读锁的情况下，同一时间只能有一个线程加写锁。</li></ul><p>此接口有一个实现类ReentrantReadWriteLock（实现的是ReadWriteLock接口，不是Lock接口，它本身并不是锁），注意我们操作ReentrantReadWriteLock时，不能直接上锁，而是需要获取读锁或是写锁，再进行锁操作：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ReentrantReadWriteLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReentrantReadWriteLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">readLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(lock.</span><span style="color:#B392F0;">readLock</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">lock).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ReentrantReadWriteLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantReadWriteLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">readLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(lock.</span><span style="color:#6F42C1;">readLock</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">lock).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里我们对读锁加锁，可以看到可以多个线程同时对读锁加锁。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ReentrantReadWriteLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReentrantReadWriteLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">readLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">lock).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ReentrantReadWriteLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantReadWriteLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">readLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">lock).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>有读锁状态下无法加写锁，反之亦然：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ReentrantReadWriteLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReentrantReadWriteLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(lock.</span><span style="color:#B392F0;">readLock</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">lock).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ReentrantReadWriteLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantReadWriteLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(lock.</span><span style="color:#6F42C1;">readLock</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">lock).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>ReentrantReadWriteLock不仅具有读写锁的功能，还保留了可重入锁和公平/非公平机制，同一个线程可以重复为写锁加锁，并且必须全部解锁才真正释放锁：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ReentrantReadWriteLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReentrantReadWriteLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;成功获取到写锁！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;释放第一层锁！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;释放第二层锁！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ReentrantReadWriteLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantReadWriteLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;成功获取到写锁！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;释放第一层锁！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;释放第二层锁！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="写锁降级" tabindex="-1">写锁降级 <a class="header-anchor" href="#写锁降级" aria-label="Permalink to &quot;写锁降级&quot;">​</a></h4><p>写锁降级为读锁</p><p>当一个线程持有写锁的情况下，虽然其他线程不能加读锁，但是线程自己是可以加读锁的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ReentrantReadWriteLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReentrantReadWriteLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">readLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;成功加读锁！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ReentrantReadWriteLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantReadWriteLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">readLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;成功加读锁！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在同时加了写锁和读锁的情况下，释放写锁，是否其他的线程就可以一起加读锁了呢？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ReentrantReadWriteLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReentrantReadWriteLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">readLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;开始加读锁！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">readLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;读锁添加成功！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//如果释放写锁，会怎么样？</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ReentrantReadWriteLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantReadWriteLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">readLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;开始加读锁！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">readLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;读锁添加成功！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//如果释放写锁，会怎么样？</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>可以看到，一旦写锁被释放，那么主线程就只剩下读锁了，因为读锁可以被多个线程共享，所以这时第二个线程也添加了读锁。而这种操作，就被称之为&quot;锁降级&quot;（注意不是先释放写锁再加读锁，而是持有写锁的情况下申请读锁再释放写锁）</p><h4 id="读锁升级" tabindex="-1">读锁升级 <a class="header-anchor" href="#读锁升级" aria-label="Permalink to &quot;读锁升级&quot;">​</a></h4><p>在仅持有读锁的情况下去申请写锁，属于&quot;锁升级&quot;，<strong>ReentrantReadWriteLock是不支持的</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ReentrantReadWriteLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReentrantReadWriteLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">readLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 线程直接卡在加写锁这里</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">writeLock</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;锁升级成功！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ReentrantReadWriteLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantReadWriteLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">readLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 线程直接卡在加写锁这里</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">writeLock</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;锁升级成功！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="condition" tabindex="-1">Condition <a class="header-anchor" href="#condition" aria-label="Permalink to &quot;Condition&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Condition</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//与调用锁对象的wait方法一样，会进入到等待状态，但是这里需要调用Condition的signal或signalAll方法进行唤醒</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//感觉就是和普通对象的wait和notify是对应的 同时，等待状态下是可以响应中断的</span></span>
<span class="line"><span style="color:#E1E4E8;"> 	</span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//同上，但不响应中断（看名字都能猜到）</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">awaitUninterruptibly</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//等待指定时间，如果在指定时间（纳秒）内被唤醒，会返回剩余时间，如果超时，会返回0或负数，可以响应中断</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">awaitNanos</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">nanosTimeout</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//等待指定时间（可以指定时间单位），如果等待时间内被唤醒，返回true，否则返回false，可以响应中断</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">time</span><span style="color:#E1E4E8;">, TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//可以指定一个明确的时间点，如果在时间点之前被唤醒，返回true，否则返回false，可以响应中断</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">awaitUntil</span><span style="color:#E1E4E8;">(Date </span><span style="color:#FFAB70;">deadline</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//唤醒一个处于等待状态的线程，注意还得获得锁才能接着运行</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">signal</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//同上，但是是唤醒所有等待线程</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">signalAll</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Condition</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//与调用锁对象的wait方法一样，会进入到等待状态，但是这里需要调用Condition的signal或signalAll方法进行唤醒</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//感觉就是和普通对象的wait和notify是对应的 同时，等待状态下是可以响应中断的</span></span>
<span class="line"><span style="color:#24292E;"> 	</span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//同上，但不响应中断（看名字都能猜到）</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">awaitUninterruptibly</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//等待指定时间，如果在指定时间（纳秒）内被唤醒，会返回剩余时间，如果超时，会返回0或负数，可以响应中断</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">awaitNanos</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">nanosTimeout</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//等待指定时间（可以指定时间单位），如果等待时间内被唤醒，返回true，否则返回false，可以响应中断</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">time</span><span style="color:#24292E;">, TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//可以指定一个明确的时间点，如果在时间点之前被唤醒，返回true，否则返回false，可以响应中断</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">awaitUntil</span><span style="color:#24292E;">(Date </span><span style="color:#E36209;">deadline</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//唤醒一个处于等待状态的线程，注意还得获得锁才能接着运行</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//同上，但是是唤醒所有等待线程</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">signalAll</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在AQS中，Condition有一个实现类ConditionObject，而这里也是使用了链表实现了条件队列：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ConditionObject</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Condition</span><span style="color:#E1E4E8;">, java.io.</span><span style="color:#B392F0;">Serializable</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> serialVersionUID </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1173984872572414699L</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">    /** 条件队列的头结点 */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> Node firstWaiter;</span></span>
<span class="line"><span style="color:#6A737D;">    /** 条件队列的尾结点 */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> Node lastWaiter;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ConditionObject</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Condition</span><span style="color:#24292E;">, java.io.</span><span style="color:#6F42C1;">Serializable</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> serialVersionUID </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1173984872572414699L</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">    /** 条件队列的头结点 */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> Node firstWaiter;</span></span>
<span class="line"><span style="color:#6A737D;">    /** 条件队列的尾结点 */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> Node lastWaiter;</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里是直接使用了AQS中的Node类，但是使用的是Node类中的nextWaiter字段连接节点，并且Node的status为CONDITION：</p><p><img src="`+d+`" alt="image-20220307115850295"></p><p>我们知道，当一个线程调用<code>await()</code>方法时，会进入等待状态，直到其他线程调用<code>signal()</code>方法将其唤醒，而这里的条件队列，正是用于存储这些处于等待状态的线程。</p><p>我们先来看看最关键的<code>await()</code>方法是如何实现的，为了防止一会绕晕，在开始之前，我们先明确此方法的目标：</p><ul><li>只有已经持有锁的线程才可以使用此方法</li><li>当调用此方法后，会直接释放锁，无论加了多少次锁</li><li>只有其他线程调用<code>signal()</code>或是被中断时才会唤醒等待中的线程</li><li>被唤醒后，需要等待其他线程释放锁，拿到锁之后才可以继续执行，并且会恢复到之前的状态（await之前加了几层锁唤醒后依然是几层锁）</li></ul><p>源码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Thread.</span><span style="color:#B392F0;">interrupted</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InterruptedException</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//如果在调用await之前就被添加了中断标记，那么会直接抛出中断异常</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">addConditionWaiter</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//为当前线程创建一个新的节点，并将其加入到条件队列中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> savedState </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fullyRelease</span><span style="color:#E1E4E8;">(node);    </span><span style="color:#6A737D;">//完全释放当前线程持有的锁，并且保存一下state值，因为唤醒之后还得恢复</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> interruptMode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;     </span><span style="color:#6A737D;">//用于保存中断状态</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">isOnSyncQueue</span><span style="color:#E1E4E8;">(node)) {   </span><span style="color:#6A737D;">//循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到AQS的等待队列中（之后我们会讲）</span></span>
<span class="line"><span style="color:#E1E4E8;">        LockSupport.</span><span style="color:#B392F0;">park</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//如果依然处于等待状态，那么继续挂起</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((interruptMode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">checkInterruptWhileWaiting</span><span style="color:#E1E4E8;">(node)) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)   </span><span style="color:#6A737D;">//看看等待的时候是不是被中断了</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">acquireQueued</span><span style="color:#E1E4E8;">(node, savedState) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> interruptMode </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> THROW_IE)  </span><span style="color:#6A737D;">//直接开始acquireQueued尝试拿锁（之前已经讲过了）从这里开始基本就和一个线程去抢锁是一样的了</span></span>
<span class="line"><span style="color:#E1E4E8;">        interruptMode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> REINTERRUPT;</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//已经拿到锁了，基本可以开始继续运行了，这里再进行一下后期清理工作</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.nextWaiter </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">unlinkCancelledWaiters</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">//将等待队列中，不是Node.CONDITION状态的节点移除</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (interruptMode </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)   </span><span style="color:#6A737D;">//依然是响应中断</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">reportInterruptAfterWait</span><span style="color:#E1E4E8;">(interruptMode);</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//OK，接着该干嘛干嘛</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Thread.</span><span style="color:#6F42C1;">interrupted</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InterruptedException</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//如果在调用await之前就被添加了中断标记，那么会直接抛出中断异常</span></span>
<span class="line"><span style="color:#24292E;">    Node node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addConditionWaiter</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//为当前线程创建一个新的节点，并将其加入到条件队列中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> savedState </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fullyRelease</span><span style="color:#24292E;">(node);    </span><span style="color:#6A737D;">//完全释放当前线程持有的锁，并且保存一下state值，因为唤醒之后还得恢复</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> interruptMode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;     </span><span style="color:#6A737D;">//用于保存中断状态</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">isOnSyncQueue</span><span style="color:#24292E;">(node)) {   </span><span style="color:#6A737D;">//循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到AQS的等待队列中（之后我们会讲）</span></span>
<span class="line"><span style="color:#24292E;">        LockSupport.</span><span style="color:#6F42C1;">park</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//如果依然处于等待状态，那么继续挂起</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((interruptMode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">checkInterruptWhileWaiting</span><span style="color:#24292E;">(node)) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)   </span><span style="color:#6A737D;">//看看等待的时候是不是被中断了</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">acquireQueued</span><span style="color:#24292E;">(node, savedState) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> interruptMode </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> THROW_IE)  </span><span style="color:#6A737D;">//直接开始acquireQueued尝试拿锁（之前已经讲过了）从这里开始基本就和一个线程去抢锁是一样的了</span></span>
<span class="line"><span style="color:#24292E;">        interruptMode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> REINTERRUPT;</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//已经拿到锁了，基本可以开始继续运行了，这里再进行一下后期清理工作</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.nextWaiter </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">unlinkCancelledWaiters</span><span style="color:#24292E;">();  </span><span style="color:#6A737D;">//将等待队列中，不是Node.CONDITION状态的节点移除</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (interruptMode </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)   </span><span style="color:#6A737D;">//依然是响应中断</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">reportInterruptAfterWait</span><span style="color:#24292E;">(interruptMode);</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//OK，接着该干嘛干嘛</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>实际上<code>await()</code>方法比较中规中矩，大部分操作也在我们的意料之中，那么我们接着来看<code>signal()</code>方法是如何实现的，同样的，为了防止各位绕晕，先明确signal的目标：</p><ul><li>只有持有锁的线程才能唤醒锁所属的Condition等待的线程</li><li>优先唤醒条件队列中的第一个，如果唤醒过程中出现问题，接着找往下找，直到找到一个可以唤醒的</li><li>唤醒操作本质上是将条件队列中的结点直接丢进AQS等待队列中，让其参与到锁的竞争中</li><li>拿到锁之后，线程才能恢复运行</li></ul><p><img src="`+D+`" alt="image-20220307120449303"></p><p>源码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">signal</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">isHeldExclusively</span><span style="color:#E1E4E8;">())    </span><span style="color:#6A737D;">//先看看当前线程是不是持有锁的状态</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IllegalMonitorStateException</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//不是？那你不配唤醒别人</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node first </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> firstWaiter;    </span><span style="color:#6A737D;">//获取条件队列的第一个结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (first </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)    </span><span style="color:#6A737D;">//如果队列不为空，获取到了，那么就可以开始唤醒操作</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">doSignal</span><span style="color:#E1E4E8;">(first);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">isHeldExclusively</span><span style="color:#24292E;">())    </span><span style="color:#6A737D;">//先看看当前线程是不是持有锁的状态</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalMonitorStateException</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//不是？那你不配唤醒别人</span></span>
<span class="line"><span style="color:#24292E;">    Node first </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> firstWaiter;    </span><span style="color:#6A737D;">//获取条件队列的第一个结点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (first </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)    </span><span style="color:#6A737D;">//如果队列不为空，获取到了，那么就可以开始唤醒操作</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">doSignal</span><span style="color:#24292E;">(first);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSignal</span><span style="color:#E1E4E8;">(Node first) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ( (firstWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> first.nextWaiter) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)   </span><span style="color:#6A737D;">//如果当前节点在本轮循环没有后继节点了，条件队列就为空了</span></span>
<span class="line"><span style="color:#E1E4E8;">            lastWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//所以这里相当于是直接清空</span></span>
<span class="line"><span style="color:#E1E4E8;">        first.nextWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//将给定节点的下一个结点设置为null，因为当前结点马上就会离开条件队列了</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">transferForSignal</span><span style="color:#E1E4E8;">(first) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//接着往下看</span></span>
<span class="line"><span style="color:#E1E4E8;">             (first </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> firstWaiter) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSignal</span><span style="color:#24292E;">(Node first) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ( (firstWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> first.nextWaiter) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)   </span><span style="color:#6A737D;">//如果当前节点在本轮循环没有后继节点了，条件队列就为空了</span></span>
<span class="line"><span style="color:#24292E;">            lastWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//所以这里相当于是直接清空</span></span>
<span class="line"><span style="color:#24292E;">        first.nextWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//将给定节点的下一个结点设置为null，因为当前结点马上就会离开条件队列了</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">transferForSignal</span><span style="color:#24292E;">(first) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">   </span><span style="color:#6A737D;">//接着往下看</span></span>
<span class="line"><span style="color:#24292E;">             (first </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> firstWaiter) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">transferForSignal</span><span style="color:#E1E4E8;">(Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;">     * 如果这里CAS失败，那有可能此节点被设定为了取消状态</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(node, Node.CONDITION, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//CAS成功之后，结点的等待状态就变成了默认值0，接着通过enq方法直接将节点丢进AQS的等待队列中，相当于唤醒并且可以等待获取锁了</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//这里enq方法返回的是加入之后等待队列队尾的前驱节点，就是原来的tail</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">enq</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ws </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p.waitStatus;   </span><span style="color:#6A737D;">//保存前驱结点的等待状态</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//如果上一个节点的状态为取消, 或者尝试设置上一个节点的状态为SIGNAL失败（可能是在ws&gt;0判断完之后马上变成了取消状态，导致CAS失败）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(p, ws, Node.SIGNAL))</span></span>
<span class="line"><span style="color:#E1E4E8;">        LockSupport.</span><span style="color:#B392F0;">unpark</span><span style="color:#E1E4E8;">(node.thread);  </span><span style="color:#6A737D;">//直接唤醒线程</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">transferForSignal</span><span style="color:#24292E;">(Node node) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;">     * 如果这里CAS失败，那有可能此节点被设定为了取消状态</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(node, Node.CONDITION, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">))</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//CAS成功之后，结点的等待状态就变成了默认值0，接着通过enq方法直接将节点丢进AQS的等待队列中，相当于唤醒并且可以等待获取锁了</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//这里enq方法返回的是加入之后等待队列队尾的前驱节点，就是原来的tail</span></span>
<span class="line"><span style="color:#24292E;">    Node p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">enq</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ws </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.waitStatus;   </span><span style="color:#6A737D;">//保存前驱结点的等待状态</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//如果上一个节点的状态为取消, 或者尝试设置上一个节点的状态为SIGNAL失败（可能是在ws&gt;0判断完之后马上变成了取消状态，导致CAS失败）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(p, ws, Node.SIGNAL))</span></span>
<span class="line"><span style="color:#24292E;">        LockSupport.</span><span style="color:#6F42C1;">unpark</span><span style="color:#24292E;">(node.thread);  </span><span style="color:#6A737D;">//直接唤醒线程</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>其实最让人不理解的就是倒数第二行，明明上面都正常进入到AQS等待队列了，应该是可以开始走正常流程了，那么这里为什么还要提前来一次unpark呢？</p><p>这里其实是为了进行优化而编写，直接unpark会有两种情况：</p><ul><li>如果插入结点前，AQS等待队列的队尾节点就已经被取消，则满足wc &gt; 0</li><li>如果插入node后，AQS内部等待队列的队尾节点已经稳定，满足tail.waitStatus == 0，但在执行ws &gt; 0之后!compareAndSetWaitStatus(p, ws, Node.SIGNAL)之前被取消，则CAS也会失败，满足compareAndSetWaitStatus(p, ws, Node.SIGNAL) == false</li></ul><p>如果这里被提前unpark，那么在<code>await()</code>方法中将可以被直接唤醒，并跳出while循环，直接开始争抢锁，因为前一个等待结点是被取消的状态，没有必要再等它了。所以，大致流程下：</p><p><img src="`+C+`" alt="image-20220307131536020"></p><h3 id="并发容器" tabindex="-1">并发容器 <a class="header-anchor" href="#并发容器" aria-label="Permalink to &quot;并发容器&quot;">​</a></h3><h4 id="copyonwritearraylist" tabindex="-1">CopyOnWriteArrayList <a class="header-anchor" href="#copyonwritearraylist" aria-label="Permalink to &quot;CopyOnWriteArrayList&quot;">​</a></h4><p><code>add()</code>：添加操作是直接上锁，并且会先拷贝一份当前存放元素的数组，然后对数组进行修改，再将此数组替换（CopyOnWrite）</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(E e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 直接加锁，保证同一时间只有一个线程进行添加操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();  </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 获取当前存储元素的数组</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] elements </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getArray</span><span style="color:#E1E4E8;">();  </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> len </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> elements.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 直接复制一份数组</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] newElements </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Arrays.</span><span style="color:#B392F0;">copyOf</span><span style="color:#E1E4E8;">(elements, len </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);   </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 修改复制出来的数组</span></span>
<span class="line"><span style="color:#E1E4E8;">        newElements[len] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将元素数组设定为复制出来的数组</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">setArray</span><span style="color:#E1E4E8;">(newElements);   </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(E e) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 直接加锁，保证同一时间只有一个线程进行添加操作</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();  </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 获取当前存储元素的数组</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] elements </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getArray</span><span style="color:#24292E;">();  </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> len </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> elements.length;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 直接复制一份数组</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] newElements </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Arrays.</span><span style="color:#6F42C1;">copyOf</span><span style="color:#24292E;">(elements, len </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);   </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 修改复制出来的数组</span></span>
<span class="line"><span style="color:#24292E;">        newElements[len] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将元素数组设定为复制出来的数组</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">setArray</span><span style="color:#24292E;">(newElements);   </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>get(int index)</code>：对于读操作不加锁</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> E </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> index) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getArray</span><span style="color:#E1E4E8;">(), index);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> E </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> index) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getArray</span><span style="color:#24292E;">(), index);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="concurrenthashmap" tabindex="-1">ConcurrentHashMap <a class="header-anchor" href="#concurrenthashmap" aria-label="Permalink to &quot;ConcurrentHashMap&quot;">​</a></h4><p>JDK7之前，ConcurrentHashMap的原理也比较类似，它将所有数据分为一段一段地存储，先分很多段出来，每一段都给一把锁，当一个线程占锁访问时，只会占用其中一把锁，也就是仅仅锁了一小段数据，而其他段的数据依然可以被其他线程正常访问。</p><p><img src="`+h+'" alt="image-20220406102137754"></p><p>JDK8之后，采用了CAS算法配合锁机制实现</p><p><img src="'+g+`" alt="image-20220406102232375"></p><p><code>put()</code>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(K key, V value) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">putVal</span><span style="color:#E1E4E8;">(key, value, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">putVal</span><span style="color:#E1E4E8;">(K key, V value, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> onlyIfAbsent) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 键值不能为空</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (key </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> value </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NullPointerException</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 计算键的hash值，用于确定在哈希表中的位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">spread</span><span style="color:#E1E4E8;">(key.</span><span style="color:#B392F0;">hashCode</span><span style="color:#E1E4E8;">());  </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 用来记录链表长度</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> binCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;   </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// CAS自旋锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Node&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;[] tab </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> table;;) {    </span></span>
<span class="line"><span style="color:#E1E4E8;">        Node&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; f; </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n, i, fh;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (tab </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tab.length) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果数组（哈希表）为空肯定是要进行初始化的，然后再重新进下一轮循环</span></span>
<span class="line"><span style="color:#E1E4E8;">            tab </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">initTable</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果哈希表该位置为null，直接CAS插入结点作为头结即可（注意这里会将f设置当前哈希表位置上的头结点）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((f </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tabAt</span><span style="color:#E1E4E8;">(tab, i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> hash)) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {   </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">casTabAt</span><span style="color:#E1E4E8;">(tab, i, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                         </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Node&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;(hash, key, value, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)))  </span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 如果CAS成功，直接break结束put方法，失败那就继续下一轮循环</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 头结点哈希值为-1，这里只需要知道是因为正在扩容即可</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((fh </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> f.hash) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> MOVED) </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 帮助进行迁移，完事之后再来下一次循环</span></span>
<span class="line"><span style="color:#E1E4E8;">            tab </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">helpTransfer</span><span style="color:#E1E4E8;">(tab, f); </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 正常流程走这里</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {     </span></span>
<span class="line"><span style="color:#E1E4E8;">            V oldVal </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 前面的循环中f肯定是被设定为了哈希表某个位置上的头结点，这里把它作为锁加锁了，防止同一时间其他线程也在操作哈希表中这个位置上的链表或是红黑树</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">synchronized</span><span style="color:#E1E4E8;"> (f) {   </span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">tabAt</span><span style="color:#E1E4E8;">(tab, i) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> f) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 头结点的哈希值大于等于0说明是链表，下面就是针对链表的一些列操作</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (fh </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {    </span></span>
<span class="line"><span style="color:#E1E4E8;">                        ...实现细节略</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 肯定不大于0，肯定也不是-1，还判断是不是TreeBin，所以不用猜了，肯定是红黑树，下面就是针对红黑树的情况进行操作        </span></span>
<span class="line"><span style="color:#E1E4E8;">                    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (f </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> TreeBin) {   </span></span>
<span class="line"><span style="color:#E1E4E8;">                      	</span><span style="color:#6A737D;">// 在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin</span></span>
<span class="line"><span style="color:#E1E4E8;">                        ...实现细节略</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">          	</span><span style="color:#6A737D;">// 根据链表长度决定是否要进化为红黑树</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (binCount </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (binCount </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> TREEIFY_THRESHOLD)</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 注意这里只是可能会进化为红黑树，如果当前哈希表的长度小于64，它会优先考虑对哈希表进行扩容</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">treeifyBin</span><span style="color:#E1E4E8;">(tab, i);   </span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldVal </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> oldVal;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">addCount</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1L</span><span style="color:#E1E4E8;">, binCount);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> V </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(K key, V value) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">putVal</span><span style="color:#24292E;">(key, value, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> V </span><span style="color:#6F42C1;">putVal</span><span style="color:#24292E;">(K key, V value, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> onlyIfAbsent) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 键值不能为空</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NullPointerException</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算键的hash值，用于确定在哈希表中的位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">spread</span><span style="color:#24292E;">(key.</span><span style="color:#6F42C1;">hashCode</span><span style="color:#24292E;">());  </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 用来记录链表长度</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> binCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;   </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// CAS自旋锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;[] tab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> table;;) {    </span></span>
<span class="line"><span style="color:#24292E;">        Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; f; </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n, i, fh;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (tab </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tab.length) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果数组（哈希表）为空肯定是要进行初始化的，然后再重新进下一轮循环</span></span>
<span class="line"><span style="color:#24292E;">            tab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">initTable</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果哈希表该位置为null，直接CAS插入结点作为头结即可（注意这里会将f设置当前哈希表位置上的头结点）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((f </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tabAt</span><span style="color:#24292E;">(tab, i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> hash)) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {   </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">casTabAt</span><span style="color:#24292E;">(tab, i, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                         </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;(hash, key, value, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)))  </span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 如果CAS成功，直接break结束put方法，失败那就继续下一轮循环</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 头结点哈希值为-1，这里只需要知道是因为正在扩容即可</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((fh </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> f.hash) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> MOVED) </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 帮助进行迁移，完事之后再来下一次循环</span></span>
<span class="line"><span style="color:#24292E;">            tab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">helpTransfer</span><span style="color:#24292E;">(tab, f); </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 正常流程走这里</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {     </span></span>
<span class="line"><span style="color:#24292E;">            V oldVal </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 前面的循环中f肯定是被设定为了哈希表某个位置上的头结点，这里把它作为锁加锁了，防止同一时间其他线程也在操作哈希表中这个位置上的链表或是红黑树</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> (f) {   </span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">tabAt</span><span style="color:#24292E;">(tab, i) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> f) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 头结点的哈希值大于等于0说明是链表，下面就是针对链表的一些列操作</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (fh </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {    </span></span>
<span class="line"><span style="color:#24292E;">                        ...实现细节略</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 肯定不大于0，肯定也不是-1，还判断是不是TreeBin，所以不用猜了，肯定是红黑树，下面就是针对红黑树的情况进行操作        </span></span>
<span class="line"><span style="color:#24292E;">                    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (f </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> TreeBin) {   </span></span>
<span class="line"><span style="color:#24292E;">                      	</span><span style="color:#6A737D;">// 在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin</span></span>
<span class="line"><span style="color:#24292E;">                        ...实现细节略</span></span>
<span class="line"><span style="color:#24292E;">                    }</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">          	</span><span style="color:#6A737D;">// 根据链表长度决定是否要进化为红黑树</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (binCount </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (binCount </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> TREEIFY_THRESHOLD)</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 注意这里只是可能会进化为红黑树，如果当前哈希表的长度小于64，它会优先考虑对哈希表进行扩容</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">treeifyBin</span><span style="color:#24292E;">(tab, i);   </span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldVal </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> oldVal;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">addCount</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1L</span><span style="color:#24292E;">, binCount);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>总结：</p><p><img src="`+B+`" alt="image-20220406102601299"></p><p><code>get()</code>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(Object key) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;[] tab; Node&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e, p; </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n, eh; K ek;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 计算哈希值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">spread</span><span style="color:#E1E4E8;">(key.</span><span style="color:#B392F0;">hashCode</span><span style="color:#E1E4E8;">());   </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((tab </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> table) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tab.length) </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">        (e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tabAt</span><span style="color:#E1E4E8;">(tab, (n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> h)) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 如果头结点就是我们要找的，那直接返回值就行了</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((eh </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.hash) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> h) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((ek </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.key) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (ek </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> key.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(ek)))</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> e.val;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//要么是正在扩容，要么就是红黑树，负数只有这两种情况</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (eh </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.</span><span style="color:#B392F0;">find</span><span style="color:#E1E4E8;">(h, key)) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> p.val </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 确认无误，肯定在列表里，开找</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> ((e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.next) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (e.hash </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">                ((ek </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.key) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (ek </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> key.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(ek))))</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> e.val;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">// 没找到只能null了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> V </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(Object key) {</span></span>
<span class="line"><span style="color:#24292E;">    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;[] tab; Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; e, p; </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n, eh; K ek;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算哈希值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">spread</span><span style="color:#24292E;">(key.</span><span style="color:#6F42C1;">hashCode</span><span style="color:#24292E;">());   </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((tab </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> table) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tab.length) </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">        (e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tabAt</span><span style="color:#24292E;">(tab, (n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> h)) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 如果头结点就是我们要找的，那直接返回值就行了</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((eh </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.hash) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> h) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((ek </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.key) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (ek </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(ek)))</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> e.val;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//要么是正在扩容，要么就是红黑树，负数只有这两种情况</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (eh </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.</span><span style="color:#6F42C1;">find</span><span style="color:#24292E;">(h, key)) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> p.val </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 确认无误，肯定在列表里，开找</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> ((e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.next) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (e.hash </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">                ((ek </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.key) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (ek </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> key.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(ek))))</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> e.val;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">// 没找到只能null了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>综上，ConcurrentHashMap的put操作，实际上是对哈希表上的所有头结点元素分别加锁，理论上来说哈希表的长度很大程度上决定了ConcurrentHashMap在同一时间能够处理的线程数量，这也是为什么<code>treeifyBin()</code>会优先考虑为哈希表进行扩容的原因。显然，这种加锁方式比JDK7的分段锁机制性能更好。</p><h3 id="阻塞队列" tabindex="-1">阻塞队列 <a class="header-anchor" href="#阻塞队列" aria-label="Permalink to &quot;阻塞队列&quot;">​</a></h3><ul><li>ArrayBlockingQueue：有界带缓冲阻塞队列（就是队列是有容量限制的，装满了肯定是不能再装的，只能阻塞，数组实现）</li><li>SynchronousQueue：无缓冲阻塞队列（相当于没有容量的ArrayBlockingQueue，因此只有阻塞的情况）</li><li>LinkedBlockingQueue：无界带缓冲阻塞队列（没有容量限制，也可以限制容量，也会阻塞，链表实现）</li><li>PriorityBlockingQueue - 是一个支持优先级的阻塞队列，元素的获取顺序按优先级决定。</li><li>DelayQueue - 它能够实现延迟获取元素，同样支持优先级。</li></ul><p>阻塞队列本身也是队列，但是它是适用于多线程环境下的，基于ReentrantLock实现的，它的接口定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BlockingQueue</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Queue</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">   	</span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(E </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 入队，如果队列已满，返回false否则返回true（非阻塞）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(E </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 入队，如果队列已满，阻塞线程直到能入队为止</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(E </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 入队，如果队列已满，阻塞线程直到能入队或超时、中断为止，入队成功返回true否则false</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(E </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">timeout</span><span style="color:#E1E4E8;">, TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 出队，如果队列为空，阻塞线程直到能出队为止</span></span>
<span class="line"><span style="color:#E1E4E8;">    E </span><span style="color:#B392F0;">take</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 出队，如果队列为空，阻塞线程直到能出队超时、中断为止，出队成功正常返回，否则返回null</span></span>
<span class="line"><span style="color:#E1E4E8;">    E </span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">timeout</span><span style="color:#E1E4E8;">, TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回此队列理想情况下（在没有内存或资源限制的情况下）可以不阻塞地入队的数量，如果没有限制，则返回 Integer.MAX_VALUE</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">remainingCapacity</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">o</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">o</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">// 一次性从BlockingQueue中获取所有可用的数据对象（还可以指定获取数据的个数）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">drainTo</span><span style="color:#E1E4E8;">(Collection&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">super</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">c</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">drainTo</span><span style="color:#E1E4E8;">(Collection&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">super</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">c</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">maxElements</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BlockingQueue</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Queue</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">   	</span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(E </span><span style="color:#E36209;">e</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 入队，如果队列已满，返回false否则返回true（非阻塞）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(E </span><span style="color:#E36209;">e</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 入队，如果队列已满，阻塞线程直到能入队为止</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(E </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 入队，如果队列已满，阻塞线程直到能入队或超时、中断为止，入队成功返回true否则false</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(E </span><span style="color:#E36209;">e</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">timeout</span><span style="color:#24292E;">, TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 出队，如果队列为空，阻塞线程直到能出队为止</span></span>
<span class="line"><span style="color:#24292E;">    E </span><span style="color:#6F42C1;">take</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 出队，如果队列为空，阻塞线程直到能出队超时、中断为止，出队成功正常返回，否则返回null</span></span>
<span class="line"><span style="color:#24292E;">    E </span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">timeout</span><span style="color:#24292E;">, TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回此队列理想情况下（在没有内存或资源限制的情况下）可以不阻塞地入队的数量，如果没有限制，则返回 Integer.MAX_VALUE</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">remainingCapacity</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(Object </span><span style="color:#E36209;">o</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(Object </span><span style="color:#E36209;">o</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">// 一次性从BlockingQueue中获取所有可用的数据对象（还可以指定获取数据的个数）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">drainTo</span><span style="color:#24292E;">(Collection&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">super</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">c</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">drainTo</span><span style="color:#24292E;">(Collection&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">super</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">c</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">maxElements</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>比如现在有一个容量为3的阻塞队列，这个时候一个线程<code>put</code>向其添加了三个元素，第二个线程接着<code>put</code>向其添加三个元素，那么这个时候由于容量已满，会直接被阻塞，而这时第三个线程从队列中取走2个元素，线程二停止阻塞，先丢两个进去，还有一个还是进不去，所以说继续阻塞。</p><p><img src="`+m+`" alt="image-20220406102943972"></p><h4 id="arrayblockingqueue" tabindex="-1">ArrayBlockingQueue <a class="header-anchor" href="#arrayblockingqueue" aria-label="Permalink to &quot;ArrayBlockingQueue&quot;">​</a></h4><p>构造方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Condition notEmpty;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Condition notFull;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ArrayBlockingQueue</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> capacity, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> fair) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (capacity </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IllegalArgumentException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.items </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[capacity];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 底层采用锁机制保证线程安全性，这里我们可以选择使用公平锁或是非公平锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReentrantLock</span><span style="color:#E1E4E8;">(fair);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里创建了两个Condition（都属于lock）一会用于入队和出队的线程阻塞控制</span></span>
<span class="line"><span style="color:#E1E4E8;">    notEmpty </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> lock.</span><span style="color:#B392F0;">newCondition</span><span style="color:#E1E4E8;">();   </span></span>
<span class="line"><span style="color:#E1E4E8;">    notFull </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">  lock.</span><span style="color:#B392F0;">newCondition</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Condition notEmpty;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Condition notFull;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ArrayBlockingQueue</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> capacity, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> fair) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (capacity </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalArgumentException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.items </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[capacity];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 底层采用锁机制保证线程安全性，这里我们可以选择使用公平锁或是非公平锁</span></span>
<span class="line"><span style="color:#24292E;">    lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantLock</span><span style="color:#24292E;">(fair);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里创建了两个Condition（都属于lock）一会用于入队和出队的线程阻塞控制</span></span>
<span class="line"><span style="color:#24292E;">    notEmpty </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> lock.</span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">();   </span></span>
<span class="line"><span style="color:#24292E;">    notFull </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  lock.</span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>put</code>方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(E e) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">checkNotNull</span><span style="color:#E1E4E8;">(e);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 需要进行加锁操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 注意这里是可以响应中断的</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">lockInterruptibly</span><span style="color:#E1E4E8;">();    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (count </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> items.length)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 可以看到当队列已满时会直接挂起当前线程，在其他线程出队操作时会被唤醒</span></span>
<span class="line"><span style="color:#E1E4E8;">            notFull.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 直到队列有空位才将线程入队</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">enqueue</span><span style="color:#E1E4E8;">(e);  </span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(E e) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">checkNotNull</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 需要进行加锁操作</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 注意这里是可以响应中断的</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">lockInterruptibly</span><span style="color:#24292E;">();    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (count </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> items.length)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 可以看到当队列已满时会直接挂起当前线程，在其他线程出队操作时会被唤醒</span></span>
<span class="line"><span style="color:#24292E;">            notFull.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 直到队列有空位才将线程入队</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">enqueue</span><span style="color:#24292E;">(e);  </span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>offer</code>方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(E e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">checkNotNull</span><span style="color:#E1E4E8;">(e);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 可以看到这里也是使用了类里面的ReentrantLock进行加锁操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 保证同一时间只有一个线程进入</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 直接看看队列是否已满，如果没满则直接入队，如果已满则返回false</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (count </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> items.length)   </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">enqueue</span><span style="color:#E1E4E8;">(e);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(E e) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">checkNotNull</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 可以看到这里也是使用了类里面的ReentrantLock进行加锁操作</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 保证同一时间只有一个线程进入</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 直接看看队列是否已满，如果没满则直接入队，如果已满则返回false</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (count </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> items.length)   </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">enqueue</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> E </span><span style="color:#B392F0;">dequeue</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// assert items[takeIndex] != null;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] items </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.items;</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">SuppressWarnings</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;unchecked&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    E x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (E) items[takeIndex];</span></span>
<span class="line"><span style="color:#E1E4E8;">    items[takeIndex] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">takeIndex </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> items.length)</span></span>
<span class="line"><span style="color:#E1E4E8;">        takeIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    count</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (itrs </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        itrs.</span><span style="color:#B392F0;">elementDequeued</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 出队操作会调用notFull的signal方法唤醒被挂起处于等待状态的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">    notFull.</span><span style="color:#B392F0;">signal</span><span style="color:#E1E4E8;">();    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> x;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> E </span><span style="color:#6F42C1;">dequeue</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// assert items[takeIndex] != null;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] items </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.items;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">SuppressWarnings</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;unchecked&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    E x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (E) items[takeIndex];</span></span>
<span class="line"><span style="color:#24292E;">    items[takeIndex] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">takeIndex </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> items.length)</span></span>
<span class="line"><span style="color:#24292E;">        takeIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    count</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (itrs </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        itrs.</span><span style="color:#6F42C1;">elementDequeued</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 出队操作会调用notFull的signal方法唤醒被挂起处于等待状态的线程</span></span>
<span class="line"><span style="color:#24292E;">    notFull.</span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">();    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>出队操作：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> E </span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 出队同样进行加锁操作，保证同一时间只能有一个线程执行</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果队列不为空则出队，否则返回null</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (count </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dequeue</span><span style="color:#E1E4E8;">();   </span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> E </span><span style="color:#B392F0;">take</span><span style="color:#E1E4E8;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 可以响应中断进行加锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">lockInterruptibly</span><span style="color:#E1E4E8;">();    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (count </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 和入队相反，也是一直等直到队列中有元素之后才可以出队，在入队时会唤醒此线程</span></span>
<span class="line"><span style="color:#E1E4E8;">            notEmpty.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();    </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dequeue</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> E </span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 出队同样进行加锁操作，保证同一时间只能有一个线程执行</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果队列不为空则出队，否则返回null</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (count </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dequeue</span><span style="color:#24292E;">();   </span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> E </span><span style="color:#6F42C1;">take</span><span style="color:#24292E;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 可以响应中断进行加锁</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">lockInterruptibly</span><span style="color:#24292E;">();    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (count </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 和入队相反，也是一直等直到队列中有元素之后才可以出队，在入队时会唤醒此线程</span></span>
<span class="line"><span style="color:#24292E;">            notEmpty.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();    </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dequeue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">enqueue</span><span style="color:#E1E4E8;">(E x) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// assert items[putIndex] == null;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] items </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.items;</span></span>
<span class="line"><span style="color:#E1E4E8;">    items[putIndex] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> x;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">putIndex </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> items.length)</span></span>
<span class="line"><span style="color:#E1E4E8;">        putIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    count</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 对notEmpty的signal唤醒操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    notEmpty.</span><span style="color:#B392F0;">signal</span><span style="color:#E1E4E8;">();    </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">enqueue</span><span style="color:#24292E;">(E x) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// assert items[putIndex] == null;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] items </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.items;</span></span>
<span class="line"><span style="color:#24292E;">    items[putIndex] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">putIndex </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> items.length)</span></span>
<span class="line"><span style="color:#24292E;">        putIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    count</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 对notEmpty的signal唤醒操作</span></span>
<span class="line"><span style="color:#24292E;">    notEmpty.</span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">();    </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="synchronousqueue" tabindex="-1">SynchronousQueue <a class="header-anchor" href="#synchronousqueue" aria-label="Permalink to &quot;SynchronousQueue&quot;">​</a></h4><p>没有任何容量，正常情况下出队必须和入队操作成对出现，我们先来看它的内部，可以看到内部有一个抽象类Transferer，它定义了一个<code>transfer</code>方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">abstract</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Transferer</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * 可以是put也可以是take操作</span></span>
<span class="line"><span style="color:#6A737D;">     *</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#6A737D;"> </span><span style="color:#FFAB70;">e</span><span style="color:#6A737D;"> 如果不是空，即作为生产者，那么表示会将传入参数元素e交给消费者</span></span>
<span class="line"><span style="color:#6A737D;">     *          如果为空，即作为消费者，那么表示会从生产者那里得到一个元素e并返回</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#6A737D;"> </span><span style="color:#FFAB70;">是否可以超时</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#6A737D;"> </span><span style="color:#FFAB70;">超时时间</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@return</span><span style="color:#6A737D;"> 不为空就是从生产者那里返回的，为空表示要么被中断要么超时。</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">abstract</span><span style="color:#E1E4E8;"> E </span><span style="color:#B392F0;">transfer</span><span style="color:#E1E4E8;">(E </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">timed</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">nanos</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">abstract</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Transferer</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * 可以是put也可以是take操作</span></span>
<span class="line"><span style="color:#6A737D;">     *</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#D73A49;">@param</span><span style="color:#6A737D;"> </span><span style="color:#E36209;">e</span><span style="color:#6A737D;"> 如果不是空，即作为生产者，那么表示会将传入参数元素e交给消费者</span></span>
<span class="line"><span style="color:#6A737D;">     *          如果为空，即作为消费者，那么表示会从生产者那里得到一个元素e并返回</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#D73A49;">@param</span><span style="color:#6A737D;"> </span><span style="color:#E36209;">是否可以超时</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#D73A49;">@param</span><span style="color:#6A737D;"> </span><span style="color:#E36209;">超时时间</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#D73A49;">@return</span><span style="color:#6A737D;"> 不为空就是从生产者那里返回的，为空表示要么被中断要么超时。</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">abstract</span><span style="color:#24292E;"> E </span><span style="color:#6F42C1;">transfer</span><span style="color:#24292E;">(E </span><span style="color:#E36209;">e</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#E36209;">timed</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">nanos</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>它是直接以生产者消费者模式进行的，由于不需要依靠任何容器结构来暂时存放数据，所以我们可以直接通过<code>transfer</code>方法来对生产者和消费者之间的数据进行传递。</p><p>比如一个线程put一个新的元素进入，这时如果没有其他线程调用take方法获取元素，那么会持续被阻塞，直到有线程取出元素，而<code>transfer</code>正是需要等生产者消费者双方都到齐了才能进行交接工作，单独只有其中一方都需要进行等待。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(E e) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 判空</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (e </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NullPointerException</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 直接使用transfer方法进行数据传递</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (transferer.</span><span style="color:#B392F0;">transfer</span><span style="color:#E1E4E8;">(e, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {  </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 为空表示要么被中断要么超时</span></span>
<span class="line"><span style="color:#E1E4E8;">        Thread.</span><span style="color:#B392F0;">interrupted</span><span style="color:#E1E4E8;">();    </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InterruptedException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(E e) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 判空</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (e </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NullPointerException</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 直接使用transfer方法进行数据传递</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (transferer.</span><span style="color:#6F42C1;">transfer</span><span style="color:#24292E;">(e, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {  </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 为空表示要么被中断要么超时</span></span>
<span class="line"><span style="color:#24292E;">        Thread.</span><span style="color:#6F42C1;">interrupted</span><span style="color:#24292E;">();    </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InterruptedException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>它在公平和非公平模式下，有两个实现。</p><p><strong>公平模式</strong>下的SynchronousQueue是如何实现的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TransferQueue</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Transferer</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#6A737D;">//头结点（头结点仅作为头结点，后续节点才是真正等待的线程节点）</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> QNode head;</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#6A737D;">//尾结点</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> QNode tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    /** 节点有生产者和消费者角色之分 */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">QNode</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> QNode next;          </span><span style="color:#6A737D;">// 后继节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Object item;         </span><span style="color:#6A737D;">// 存储的元素</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Thread waiter;       </span><span style="color:#6A737D;">// 处于等待的线程，和之前的AQS一样的思路，每个线程等待的时候都会被封装为节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> isData;         </span><span style="color:#6A737D;">// 是生产者节点还是消费者节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        ...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TransferQueue</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Transferer</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6A737D;">//头结点（头结点仅作为头结点，后续节点才是真正等待的线程节点）</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> QNode head;</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6A737D;">//尾结点</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> QNode tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    /** 节点有生产者和消费者角色之分 */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">QNode</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> QNode next;          </span><span style="color:#6A737D;">// 后继节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Object item;         </span><span style="color:#6A737D;">// 存储的元素</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Thread waiter;       </span><span style="color:#6A737D;">// 处于等待的线程，和之前的AQS一样的思路，每个线程等待的时候都会被封装为节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> isData;         </span><span style="color:#6A737D;">// 是生产者节点还是消费者节点</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        ...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>公平模式下，Transferer的实现是TransferQueue，是以先进先出的规则的进行的，内部有一个QNode类来保存等待的线程。</p><p><code>transfer()</code>方法的实现:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">E </span><span style="color:#B392F0;">transfer</span><span style="color:#E1E4E8;">(E e, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> timed, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> nanos) {   </span><span style="color:#6A737D;">//注意这里面没加锁，肯定会多个线程之间竞争</span></span>
<span class="line"><span style="color:#E1E4E8;">    QNode s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> isData </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (e </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//e为空表示消费者，不为空表示生产者</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        QNode t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail;</span></span>
<span class="line"><span style="color:#E1E4E8;">        QNode h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)         </span><span style="color:#6A737D;">// 头结点尾结点任意为空（但是在构造的时候就已经不是空了）</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;                       </span><span style="color:#6A737D;">// 自旋</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> t.isData </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> isData) { </span><span style="color:#6A737D;">// 头结点等于尾结点表示队列中只有一个头结点，肯定是空，或者尾结点角色和当前节点一样，这两种情况下，都需要进行入队操作</span></span>
<span class="line"><span style="color:#E1E4E8;">            QNode tn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> tail)                  </span><span style="color:#6A737D;">// 如果这段时间内t被其他线程修改了，如果是就进下一轮循环重新来</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (tn </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {               </span><span style="color:#6A737D;">// 继续校验是否为队尾，如果tn不为null，那肯定是其他线程改了队尾，可以进下一轮循环重新来了</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">advanceTail</span><span style="color:#E1E4E8;">(t, tn);					</span><span style="color:#6A737D;">// CAS将新的队尾节点设置为tn，成不成功都无所谓，反正这一轮肯定没戏了</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (timed </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> nanos </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)        </span><span style="color:#6A737D;">// 超时返回null</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">QNode</span><span style="color:#E1E4E8;">(e, isData);   </span><span style="color:#6A737D;">//构造当前结点，准备加入等待队列</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">casNext</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, s))        </span><span style="color:#6A737D;">// CAS添加当前节点为尾结点的下一个，如果失败肯定其他线程又抢先做了，直接进下一轮循环重新来</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">advanceTail</span><span style="color:#E1E4E8;">(t, s);              </span><span style="color:#6A737D;">// 上面的操作基本OK了，那么新的队尾元素就修改为s</span></span>
<span class="line"><span style="color:#E1E4E8;">            Object x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">awaitFulfill</span><span style="color:#E1E4E8;">(s, e, timed, nanos);   </span><span style="color:#6A737D;">//开始等待s所对应的消费者或是生产者进行交接，比如s现在是生产者，那么它就需要等到一个消费者的到来才会继续（这个方法会先进行自旋等待匹配，如果自旋一定次数后还是没有匹配成功，那么就挂起）</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (x </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> s) {                   </span><span style="color:#6A737D;">// 如果返回s本身说明等待状态下被取消</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">clean</span><span style="color:#E1E4E8;">(t, s);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">s.</span><span style="color:#B392F0;">isOffList</span><span style="color:#E1E4E8;">()) {           </span><span style="color:#6A737D;">// 如果s操作完成之后没有离开队列，那么这里将其手动丢弃</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">advanceHead</span><span style="color:#E1E4E8;">(t, s);          </span><span style="color:#6A737D;">// 将s设定为新的首节点(注意头节点仅作为头结点，并非处于等待的线程节点)</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (x </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)              </span><span style="color:#6A737D;">// 删除s内的其他信息</span></span>
<span class="line"><span style="color:#E1E4E8;">                    s.item </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s;</span></span>
<span class="line"><span style="color:#E1E4E8;">                s.waiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (x </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> (E)x </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> e;   </span><span style="color:#6A737D;">//假如当前是消费者，直接返回x即可，x就是从生产者那里拿来的元素</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {                            </span><span style="color:#6A737D;">// 这种情况下就是与队列中结点类型匹配的情况了（注意队列要么为空要么只会存在一种类型的节点，因为一旦出现不同类型的节点马上会被交接掉）</span></span>
<span class="line"><span style="color:#E1E4E8;">            QNode m </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> h.next;               </span><span style="color:#6A737D;">// 获取头结点的下一个接口，准备进行交接工作</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> tail </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> m </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> head)</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;                   </span><span style="color:#6A737D;">// 判断其他线程是否先修改，如果修改过那么开下一轮</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            Object x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> m.item;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (isData </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> (x </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 判断节点类型，如果是相同的操作，那肯定也是有问题的</span></span>
<span class="line"><span style="color:#E1E4E8;">                x </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> m </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;">                   </span><span style="color:#6A737D;">// 或是当前操作被取消</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">m.</span><span style="color:#B392F0;">casItem</span><span style="color:#E1E4E8;">(x, e)) {         </span><span style="color:#6A737D;">// 上面都不是？那么最后再进行CAS替换m中的元素，成功表示交接成功，失败就老老实实重开吧</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">advanceHead</span><span style="color:#E1E4E8;">(h, m);          </span><span style="color:#6A737D;">// dequeue and retry</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">advanceHead</span><span style="color:#E1E4E8;">(h, m);              </span><span style="color:#6A737D;">// 成功交接，新的头结点可以改为m了，原有的头结点直接不要了</span></span>
<span class="line"><span style="color:#E1E4E8;">            LockSupport.</span><span style="color:#B392F0;">unpark</span><span style="color:#E1E4E8;">(m.waiter);   </span><span style="color:#6A737D;">// m中的等待交接的线程可以继续了，已经交接完成</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (x </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> (E)x </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> e;  </span><span style="color:#6A737D;">// 同上，该返回什么就返回什么</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">E </span><span style="color:#6F42C1;">transfer</span><span style="color:#24292E;">(E e, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> timed, </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> nanos) {   </span><span style="color:#6A737D;">//注意这里面没加锁，肯定会多个线程之间竞争</span></span>
<span class="line"><span style="color:#24292E;">    QNode s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> isData </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (e </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//e为空表示消费者，不为空表示生产者</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {</span></span>
<span class="line"><span style="color:#24292E;">        QNode t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail;</span></span>
<span class="line"><span style="color:#24292E;">        QNode h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)         </span><span style="color:#6A737D;">// 头结点尾结点任意为空（但是在构造的时候就已经不是空了）</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;                       </span><span style="color:#6A737D;">// 自旋</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> t.isData </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> isData) { </span><span style="color:#6A737D;">// 头结点等于尾结点表示队列中只有一个头结点，肯定是空，或者尾结点角色和当前节点一样，这两种情况下，都需要进行入队操作</span></span>
<span class="line"><span style="color:#24292E;">            QNode tn </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t.next;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> tail)                  </span><span style="color:#6A737D;">// 如果这段时间内t被其他线程修改了，如果是就进下一轮循环重新来</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (tn </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {               </span><span style="color:#6A737D;">// 继续校验是否为队尾，如果tn不为null，那肯定是其他线程改了队尾，可以进下一轮循环重新来了</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">advanceTail</span><span style="color:#24292E;">(t, tn);					</span><span style="color:#6A737D;">// CAS将新的队尾节点设置为tn，成不成功都无所谓，反正这一轮肯定没戏了</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (timed </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> nanos </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)        </span><span style="color:#6A737D;">// 超时返回null</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">QNode</span><span style="color:#24292E;">(e, isData);   </span><span style="color:#6A737D;">//构造当前结点，准备加入等待队列</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">casNext</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, s))        </span><span style="color:#6A737D;">// CAS添加当前节点为尾结点的下一个，如果失败肯定其他线程又抢先做了，直接进下一轮循环重新来</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">advanceTail</span><span style="color:#24292E;">(t, s);              </span><span style="color:#6A737D;">// 上面的操作基本OK了，那么新的队尾元素就修改为s</span></span>
<span class="line"><span style="color:#24292E;">            Object x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">awaitFulfill</span><span style="color:#24292E;">(s, e, timed, nanos);   </span><span style="color:#6A737D;">//开始等待s所对应的消费者或是生产者进行交接，比如s现在是生产者，那么它就需要等到一个消费者的到来才会继续（这个方法会先进行自旋等待匹配，如果自旋一定次数后还是没有匹配成功，那么就挂起）</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (x </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> s) {                   </span><span style="color:#6A737D;">// 如果返回s本身说明等待状态下被取消</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">clean</span><span style="color:#24292E;">(t, s);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">s.</span><span style="color:#6F42C1;">isOffList</span><span style="color:#24292E;">()) {           </span><span style="color:#6A737D;">// 如果s操作完成之后没有离开队列，那么这里将其手动丢弃</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">advanceHead</span><span style="color:#24292E;">(t, s);          </span><span style="color:#6A737D;">// 将s设定为新的首节点(注意头节点仅作为头结点，并非处于等待的线程节点)</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (x </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)              </span><span style="color:#6A737D;">// 删除s内的其他信息</span></span>
<span class="line"><span style="color:#24292E;">                    s.item </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s;</span></span>
<span class="line"><span style="color:#24292E;">                s.waiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (x </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> (E)x </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> e;   </span><span style="color:#6A737D;">//假如当前是消费者，直接返回x即可，x就是从生产者那里拿来的元素</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {                            </span><span style="color:#6A737D;">// 这种情况下就是与队列中结点类型匹配的情况了（注意队列要么为空要么只会存在一种类型的节点，因为一旦出现不同类型的节点马上会被交接掉）</span></span>
<span class="line"><span style="color:#24292E;">            QNode m </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> h.next;               </span><span style="color:#6A737D;">// 获取头结点的下一个接口，准备进行交接工作</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> tail </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> m </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> head)</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;                   </span><span style="color:#6A737D;">// 判断其他线程是否先修改，如果修改过那么开下一轮</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            Object x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> m.item;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (isData </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> (x </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">||</span><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 判断节点类型，如果是相同的操作，那肯定也是有问题的</span></span>
<span class="line"><span style="color:#24292E;">                x </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> m </span><span style="color:#D73A49;">||</span><span style="color:#24292E;">                   </span><span style="color:#6A737D;">// 或是当前操作被取消</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">m.</span><span style="color:#6F42C1;">casItem</span><span style="color:#24292E;">(x, e)) {         </span><span style="color:#6A737D;">// 上面都不是？那么最后再进行CAS替换m中的元素，成功表示交接成功，失败就老老实实重开吧</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">advanceHead</span><span style="color:#24292E;">(h, m);          </span><span style="color:#6A737D;">// dequeue and retry</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">advanceHead</span><span style="color:#24292E;">(h, m);              </span><span style="color:#6A737D;">// 成功交接，新的头结点可以改为m了，原有的头结点直接不要了</span></span>
<span class="line"><span style="color:#24292E;">            LockSupport.</span><span style="color:#6F42C1;">unpark</span><span style="color:#24292E;">(m.waiter);   </span><span style="color:#6A737D;">// m中的等待交接的线程可以继续了，已经交接完成</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (x </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> (E)x </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> e;  </span><span style="color:#6A737D;">// 同上，该返回什么就返回什么</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>总结为以下流程：</p><p><img src="`+b+`" alt="image-20220406103844984"></p><p>对于<strong>非公平模式</strong>下的SynchronousQueue，则是采用的栈结构来存储等待节点</p><h4 id="linkedtransferqueue" tabindex="-1">LinkedTransferQueue <a class="header-anchor" href="#linkedtransferqueue" aria-label="Permalink to &quot;LinkedTransferQueue&quot;">​</a></h4><p>在JDK7的时候，基于SynchronousQueue产生了一个更强大的TransferQueue，它保留了SynchronousQueue的匹配交接机制，并且与等待队列进行融合。</p><p>SynchronousQueue并没有使用锁，而是采用CAS操作保证生产者与消费者的协调，但是它没有容量，而LinkedBlockingQueue虽然是有容量且无界的，但是内部基本都是基于锁实现的，性能并不是很好，这时，我们就可以将它们各自的优点单独拿出来，揉在一起，就成了性能更高的LinkedTransferQueue</p><p>相比 <code>SynchronousQueue</code> ，它多了一个可以存储的队列，我们依然可以像阻塞队列那样获取队列中所有元素的值，简单来说，<code>LinkedTransferQueue</code>其实就是一个多了存储队列的<code>SynchronousQueue</code>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    LinkedTransferQueue&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; queue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedTransferQueue&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    queue.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;1&quot;</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">//插入时，会先检查是否有其他线程等待获取，如果是，直接进行交接，否则插入到存储队列中</span></span>
<span class="line"><span style="color:#E1E4E8;">   	queue.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;2&quot;</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">//不会像SynchronousQueue那样必须等一个匹配的才可以</span></span>
<span class="line"><span style="color:#E1E4E8;">    queue.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(System.out</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">println);   </span><span style="color:#6A737D;">//直接打印所有的元素，这在SynchronousQueue下只能是空，因为单独的入队或出队操作都会被阻塞</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    LinkedTransferQueue&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; queue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedTransferQueue&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    queue.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;1&quot;</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">//插入时，会先检查是否有其他线程等待获取，如果是，直接进行交接，否则插入到存储队列中</span></span>
<span class="line"><span style="color:#24292E;">   	queue.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;2&quot;</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">//不会像SynchronousQueue那样必须等一个匹配的才可以</span></span>
<span class="line"><span style="color:#24292E;">    queue.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(System.out</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">println);   </span><span style="color:#6A737D;">//直接打印所有的元素，这在SynchronousQueue下只能是空，因为单独的入队或出队操作都会被阻塞</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="priorityblockingqueue" tabindex="-1">PriorityBlockingQueue <a class="header-anchor" href="#priorityblockingqueue" aria-label="Permalink to &quot;PriorityBlockingQueue&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 可以指定初始容量（可扩容）和优先级比较规则，这里我们使用升序</span></span>
<span class="line"><span style="color:#E1E4E8;">    PriorityBlockingQueue&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; queue </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> PriorityBlockingQueue&lt;&gt;(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">, Integer</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">compare);   </span></span>
<span class="line"><span style="color:#E1E4E8;">    queue.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    queue.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    queue.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 注意保存顺序并不会按照优先级排列，所以可以看到结果并不是排序后的结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(queue);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 但是出队顺序一定是按照优先级进行的</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(queue.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">());   </span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(queue.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(queue.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 可以指定初始容量（可扩容）和优先级比较规则，这里我们使用升序</span></span>
<span class="line"><span style="color:#24292E;">    PriorityBlockingQueue&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; queue </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> PriorityBlockingQueue&lt;&gt;(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">, Integer</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">compare);   </span></span>
<span class="line"><span style="color:#24292E;">    queue.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    queue.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    queue.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 注意保存顺序并不会按照优先级排列，所以可以看到结果并不是排序后的结果</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(queue);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 但是出队顺序一定是按照优先级进行的</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(queue.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">());   </span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(queue.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(queue.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="delayqueue" tabindex="-1">DelayQueue <a class="header-anchor" href="#delayqueue" aria-label="Permalink to &quot;DelayQueue&quot;">​</a></h4><p>实现延时出队，也就是说当一个元素插入后，如果没有超过一定时间，那么是无法让此元素出队的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DelayQueue</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Delayed</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractQueue</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BlockingQueue</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">E</span><span style="color:#E1E4E8;">&gt; {...}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DelayQueue</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Delayed</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractQueue</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BlockingQueue</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">E</span><span style="color:#24292E;">&gt; {...}</span></span></code></pre></div><p>此类只接受Delayed的实现类作为元素：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 这里继承了Comparable，它支持优先级</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Delayed</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Comparable</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">Delayed</span><span style="color:#E1E4E8;">&gt; {  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取剩余等待时间，正数表示还需要进行等待，0或负数表示等待结束</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getDelay</span><span style="color:#E1E4E8;">(TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 这里继承了Comparable，它支持优先级</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Delayed</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Comparable</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">Delayed</span><span style="color:#24292E;">&gt; {  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取剩余等待时间，正数表示还需要进行等待，0或负数表示等待结束</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getDelay</span><span style="color:#24292E;">(TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>手动实现一个<code>Test.class</code>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Test</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Delayed</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> time;   </span><span style="color:#6A737D;">//延迟时间，这里以毫秒为单位</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> priority;</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> startTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> String data;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Test</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">time</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">priority</span><span style="color:#E1E4E8;">, String </span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.time </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> TimeUnit.SECONDS.</span><span style="color:#B392F0;">toMillis</span><span style="color:#E1E4E8;">(time);   </span><span style="color:#6A737D;">//秒转换为毫秒</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.priority </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> priority;</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.startTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//这里我们以毫秒为单位</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.data </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> data;</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getDelay</span><span style="color:#E1E4E8;">(TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> leftTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> time </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> (System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> startTime); </span><span style="color:#6A737D;">//计算剩余时间 = 设定时间 - 已度过时间(= 当前时间 - 开始时间)</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> unit.</span><span style="color:#B392F0;">convert</span><span style="color:#E1E4E8;">(leftTime, TimeUnit.MILLISECONDS);   </span><span style="color:#6A737D;">//注意进行单位转换，单位由队列指定（默认是纳秒单位）</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compareTo</span><span style="color:#E1E4E8;">(Delayed </span><span style="color:#FFAB70;">o</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(o </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> Test)</span></span>
<span class="line"><span style="color:#E1E4E8;">           </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> priority </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> ((Test) o).priority;   </span><span style="color:#6A737D;">//优先级越小越优先</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> String </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> data;</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Test</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Delayed</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> time;   </span><span style="color:#6A737D;">//延迟时间，这里以毫秒为单位</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> priority;</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> startTime;</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> String data;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Test</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">time</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">priority</span><span style="color:#24292E;">, String </span><span style="color:#E36209;">data</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.time </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> TimeUnit.SECONDS.</span><span style="color:#6F42C1;">toMillis</span><span style="color:#24292E;">(time);   </span><span style="color:#6A737D;">//秒转换为毫秒</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.priority </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> priority;</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.startTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//这里我们以毫秒为单位</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.data </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> data;</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getDelay</span><span style="color:#24292E;">(TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> leftTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> time </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> (System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> startTime); </span><span style="color:#6A737D;">//计算剩余时间 = 设定时间 - 已度过时间(= 当前时间 - 开始时间)</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> unit.</span><span style="color:#6F42C1;">convert</span><span style="color:#24292E;">(leftTime, TimeUnit.MILLISECONDS);   </span><span style="color:#6A737D;">//注意进行单位转换，单位由队列指定（默认是纳秒单位）</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compareTo</span><span style="color:#24292E;">(Delayed </span><span style="color:#E36209;">o</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(o </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Test)</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> priority </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> ((Test) o).priority;   </span><span style="color:#6A737D;">//优先级越小越优先</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> String </span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> data;</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">   DelayQueue&lt;</span><span style="color:#F97583;">Test</span><span style="color:#E1E4E8;">&gt; queue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> DelayQueue&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">// 1秒钟延时</span></span>
<span class="line"><span style="color:#E1E4E8;">   queue.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Test</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;2号&quot;</span><span style="color:#E1E4E8;">)); </span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">// 1秒钟延时，优先级最高</span></span>
<span class="line"><span style="color:#E1E4E8;">   queue.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Test</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;1号&quot;</span><span style="color:#E1E4E8;">));   </span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 注意出队顺序是依照优先级来的，即使一个元素已经可以出队了，依然需要等待优先级更高的元素到期</span></span>
<span class="line"><span style="color:#E1E4E8;">   System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(queue.</span><span style="color:#B392F0;">take</span><span style="color:#E1E4E8;">());    </span></span>
<span class="line"><span style="color:#E1E4E8;">   System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(queue.</span><span style="color:#B392F0;">take</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">   DelayQueue&lt;</span><span style="color:#D73A49;">Test</span><span style="color:#24292E;">&gt; queue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> DelayQueue&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 1秒钟延时</span></span>
<span class="line"><span style="color:#24292E;">   queue.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Test</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;2号&quot;</span><span style="color:#24292E;">)); </span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 1秒钟延时，优先级最高</span></span>
<span class="line"><span style="color:#24292E;">   queue.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Test</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;1号&quot;</span><span style="color:#24292E;">));   </span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 注意出队顺序是依照优先级来的，即使一个元素已经可以出队了，依然需要等待优先级更高的元素到期</span></span>
<span class="line"><span style="color:#24292E;">   System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(queue.</span><span style="color:#6F42C1;">take</span><span style="color:#24292E;">());    </span></span>
<span class="line"><span style="color:#24292E;">   System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(queue.</span><span style="color:#6F42C1;">take</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></blockquote><p><code>add()</code>方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(E e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(e);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(E e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 注意这里是向内部维护的一个优先级队列添加元素，并不是DelayQueue本身存储元素</span></span>
<span class="line"><span style="color:#E1E4E8;">        q.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(e);  </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果入队后队首就是当前元素，那么直接进行一次唤醒操作（因为有可能之前就有其他线程等着take了）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (q.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> e) {   </span></span>
<span class="line"><span style="color:#E1E4E8;">            leader </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            available.</span><span style="color:#B392F0;">signal</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(E e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(e);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(E e) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(E e) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 注意这里是向内部维护的一个优先级队列添加元素，并不是DelayQueue本身存储元素</span></span>
<span class="line"><span style="color:#24292E;">        q.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(e);  </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果入队后队首就是当前元素，那么直接进行一次唤醒操作（因为有可能之前就有其他线程等着take了）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (q.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> e) {   </span></span>
<span class="line"><span style="color:#24292E;">            leader </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            available.</span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(E e) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>take()</code>方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> E </span><span style="color:#B392F0;">take</span><span style="color:#E1E4E8;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 出队也要先加锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;   </span></span>
<span class="line"><span style="color:#E1E4E8;">    lock.</span><span style="color:#B392F0;">lockInterruptibly</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 无限循环操作</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {    </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 获取队首元素</span></span>
<span class="line"><span style="color:#E1E4E8;">            E first </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> q.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果为空那肯定队列为空，先等着吧，等有元素进来</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (first </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)     </span></span>
<span class="line"><span style="color:#E1E4E8;">                available.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 获取延迟，这里传入的时间单位是纳秒</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> delay </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> first.</span><span style="color:#B392F0;">getDelay</span><span style="color:#E1E4E8;">(NANOSECONDS);    </span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (delay </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 如果获取到延迟时间已经小于0了，那说明ok，可以直接出队返回</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> q.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">();     </span></span>
<span class="line"><span style="color:#E1E4E8;">                first </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 这里用leader来减少不必要的等待时间，如果不是null那说明有线程在等待，为null说明没有线程等待</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (leader </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 如果其他线程已经在等元素了，那么当前线程直接进永久等待状态</span></span>
<span class="line"><span style="color:#E1E4E8;">                    available.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();   </span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    Thread thisThread </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                     </span><span style="color:#6A737D;">// 没有线程等待就将leader设定为当前线程</span></span>
<span class="line"><span style="color:#E1E4E8;">                    leader </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> thisThread;   </span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#6A737D;">// 获取到的延迟大于0，那么就需要等待延迟时间，再开始下一次获取</span></span>
<span class="line"><span style="color:#E1E4E8;">                        available.</span><span style="color:#B392F0;">awaitNanos</span><span style="color:#E1E4E8;">(delay);     </span></span>
<span class="line"><span style="color:#E1E4E8;">                    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (leader </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> thisThread)</span></span>
<span class="line"><span style="color:#E1E4E8;">                            leader </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (leader </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> q.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 当前take结束之后唤醒一个其他永久等待状态下的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">            available.</span><span style="color:#B392F0;">signal</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 解锁</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();   </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> E </span><span style="color:#6F42C1;">take</span><span style="color:#24292E;">() throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 出队也要先加锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;   </span></span>
<span class="line"><span style="color:#24292E;">    lock.</span><span style="color:#6F42C1;">lockInterruptibly</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 无限循环操作</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {    </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 获取队首元素</span></span>
<span class="line"><span style="color:#24292E;">            E first </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> q.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果为空那肯定队列为空，先等着吧，等有元素进来</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (first </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)     </span></span>
<span class="line"><span style="color:#24292E;">                available.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 获取延迟，这里传入的时间单位是纳秒</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> delay </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> first.</span><span style="color:#6F42C1;">getDelay</span><span style="color:#24292E;">(NANOSECONDS);    </span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (delay </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 如果获取到延迟时间已经小于0了，那说明ok，可以直接出队返回</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> q.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">();     </span></span>
<span class="line"><span style="color:#24292E;">                first </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 这里用leader来减少不必要的等待时间，如果不是null那说明有线程在等待，为null说明没有线程等待</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (leader </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 如果其他线程已经在等元素了，那么当前线程直接进永久等待状态</span></span>
<span class="line"><span style="color:#24292E;">                    available.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();   </span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    Thread thisThread </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                     </span><span style="color:#6A737D;">// 没有线程等待就将leader设定为当前线程</span></span>
<span class="line"><span style="color:#24292E;">                    leader </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> thisThread;   </span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6A737D;">// 获取到的延迟大于0，那么就需要等待延迟时间，再开始下一次获取</span></span>
<span class="line"><span style="color:#24292E;">                        available.</span><span style="color:#6F42C1;">awaitNanos</span><span style="color:#24292E;">(delay);     </span></span>
<span class="line"><span style="color:#24292E;">                    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (leader </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> thisThread)</span></span>
<span class="line"><span style="color:#24292E;">                            leader </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                    }</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (leader </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> q.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 当前take结束之后唤醒一个其他永久等待状态下的线程</span></span>
<span class="line"><span style="color:#24292E;">            available.</span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 解锁</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();   </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="原子类" tabindex="-1">原子类 <a class="header-anchor" href="#原子类" aria-label="Permalink to &quot;原子类&quot;">​</a></h3><ul><li><p>AtomicInteger：原子更新int</p></li><li><p>AtomicLong：原子更新long</p></li><li><p>AtomicBoolean：原子更新boolean</p></li><li><p>AtomicIntegerArray：原子更新int数组</p></li><li><p>AtomicLongArray：原子更新long数组</p></li><li><p>AtomicReferenceArray：原子更新引用数组</p></li><li><p>DoubleAdder</p></li><li><p>LongAdder</p></li><li><p>AtomicReference：引用类型</p></li><li><p>AtomicIntegerFieldUpdater：字段原子更新器</p></li></ul><h4 id="atomicinteger" tabindex="-1">AtomicInteger <a class="header-anchor" href="#atomicinteger" aria-label="Permalink to &quot;AtomicInteger&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> value;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicInteger</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> initialValue) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> initialValue;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicInteger</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> value;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicInteger</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> initialValue) {</span></span>
<span class="line"><span style="color:#24292E;">    value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> initialValue;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicInteger</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>构造方法</code></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Unsafe unsafe </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Unsafe.</span><span style="color:#B392F0;">getUnsafe</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> valueOffset;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        valueOffset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#E1E4E8;">            (AtomicInteger.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;value&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Exception </span><span style="color:#FFAB70;">ex</span><span style="color:#E1E4E8;">) { </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(ex); }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Unsafe unsafe </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Unsafe.</span><span style="color:#6F42C1;">getUnsafe</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> valueOffset;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        valueOffset </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#24292E;">            (AtomicInteger.class.</span><span style="color:#6F42C1;">getDeclaredField</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;value&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Exception </span><span style="color:#E36209;">ex</span><span style="color:#24292E;">) { </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(ex); }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>可以看到最上面是和AQS采用了类似的机制，因为要使用CAS算法更新value的值，所以得先计算出value字段在对象中的偏移地址，CAS直接修改对应位置的内存即可（可见Unsafe类的作用巨大，很多的底层操作都要靠它来完成）</p><p>自增操作是怎么在运行的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getAndIncrement</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> unsafe.</span><span style="color:#B392F0;">getAndAddInt</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, valueOffset, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getAndIncrement</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> unsafe.</span><span style="color:#6F42C1;">getAndAddInt</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, valueOffset, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>调用了<code>unsafe.getAndAddInt()</code>，我们接着看看Unsafe里面写了什么：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getAndAddInt</span><span style="color:#E1E4E8;">(Object o, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> offset, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> delta) {  </span><span style="color:#6A737D;">//delta就是变化的值，++操作就是自增1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> v;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//volatile版本的getInt()</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//能够保证可见性</span></span>
<span class="line"><span style="color:#E1E4E8;">        v </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getIntVolatile</span><span style="color:#E1E4E8;">(o, offset);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">compareAndSwapInt</span><span style="color:#E1E4E8;">(o, offset, v, v </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> delta));  </span><span style="color:#6A737D;">//这里是开始cas替换int的值，每次都去拿最新的值去进行替换，如果成功则离开循环，不成功说明这个时候其他线程先修改了值，就进下一次循环再获取最新的值然后再cas一次，直到成功为止</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> v;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getAndAddInt</span><span style="color:#24292E;">(Object o, </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> offset, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> delta) {  </span><span style="color:#6A737D;">//delta就是变化的值，++操作就是自增1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> v;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//volatile版本的getInt()</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//能够保证可见性</span></span>
<span class="line"><span style="color:#24292E;">        v </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getIntVolatile</span><span style="color:#24292E;">(o, offset);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">compareAndSwapInt</span><span style="color:#24292E;">(o, offset, v, v </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> delta));  </span><span style="color:#6A737D;">//这里是开始cas替换int的值，每次都去拿最新的值去进行替换，如果成功则离开循环，不成功说明这个时候其他线程先修改了值，就进下一次循环再获取最新的值然后再cas一次，直到成功为止</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> v;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这是一个<code>do-while</code>循环，采用自旋形式，来不断进行CAS操作，直到成功。</p><p><img src="`+k+`" alt="image-20220308131536403"></p><p>可见，原子类底层也是采用了CAS算法来保证的原子性，包括<code>getAndSet</code>、<code>getAndAdd</code>等方法都是这样。原子类也直接提供了CAS操作方法，我们可以直接使用：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    AtomicInteger integer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicInteger</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(integer.</span><span style="color:#B392F0;">compareAndSet</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">30</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(integer.</span><span style="color:#B392F0;">compareAndSet</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(integer);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    AtomicInteger integer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicInteger</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(integer.</span><span style="color:#6F42C1;">compareAndSet</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">30</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">20</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(integer.</span><span style="color:#6F42C1;">compareAndSet</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">20</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(integer);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如果想以普通变量的方式来设定值，那么可以使用<code>lazySet()</code>方法，这样就不采用<code>volatile</code>的立即可见机制了</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">AtomicInteger integer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicInteger</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">integer.</span><span style="color:#B392F0;">lazySet</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">AtomicInteger integer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicInteger</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">integer.</span><span style="color:#6F42C1;">lazySet</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span></code></pre></div><h4 id="atomicintegerarray" tabindex="-1">AtomicIntegerArray <a class="header-anchor" href="#atomicintegerarray" aria-label="Permalink to &quot;AtomicIntegerArray&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    AtomicIntegerArray array </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicIntegerArray</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[]{</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">    Runnable r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100000</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            array.</span><span style="color:#B392F0;">getAndAdd</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    };</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(r).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(r).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(array.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    AtomicIntegerArray array </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicIntegerArray</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[]{</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">    Runnable r </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100000</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            array.</span><span style="color:#6F42C1;">getAndAdd</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    };</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(r).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(r).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(array.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="longadder" tabindex="-1">LongAdder <a class="header-anchor" href="#longadder" aria-label="Permalink to &quot;LongAdder&quot;">​</a></h4><p>在JDK8之后，新增了<code>DoubleAdder</code>和<code>LongAdder</code>，在高并发情况下，<code>LongAdder</code>的性能比<code>AtomicLong</code>的性能更好，主要体现在自增上，它的大致原理如下：在低并发情况下，和<code>AtomicLong</code>是一样的，对value值进行CAS操作，但是出现高并发的情况时，<code>AtomicLong</code>会进行大量的循环操作来保证同步，而<code>LongAdder</code>会将对value值的CAS操作分散为对数组<code>cells</code>中多个元素的CAS操作（内部维护一个Cell[] as数组，每个Cell里面有一个初始值为0的long型变量，在高并发时会进行分散CAS，就是不同的线程可以对数组中不同的元素进行CAS自增，这样就避免了所有线程都对同一个值进行CAS），只需要最后再将结果加起来即可。</p><p><img src="`+v+`" alt="image-20220406100926787"></p><p>使用如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    LongAdder adder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LongAdder</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    Runnable r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100000</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            adder.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    };</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(r).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//100个线程</span></span>
<span class="line"><span style="color:#E1E4E8;">    TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(adder.</span><span style="color:#B392F0;">sum</span><span style="color:#E1E4E8;">());   </span><span style="color:#6A737D;">//最后求和即可</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    LongAdder adder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LongAdder</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    Runnable r </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100000</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            adder.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    };</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(r).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//100个线程</span></span>
<span class="line"><span style="color:#24292E;">    TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(adder.</span><span style="color:#6F42C1;">sum</span><span style="color:#24292E;">());   </span><span style="color:#6A737D;">//最后求和即可</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>LongAdder</code>&amp;<code>AtomicLong</code>性能对比:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;使用AtomicLong的时间消耗：&quot;</span><span style="color:#F97583;">+</span><span style="color:#B392F0;">test2</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;ms&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;使用LongAdder的时间消耗：&quot;</span><span style="color:#F97583;">+</span><span style="color:#B392F0;">test1</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;ms&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">test1</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        CountDownLatch latch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CountDownLatch</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        LongAdder adder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LongAdder</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> timeStart </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        Runnable r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100000</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                adder.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            latch.</span><span style="color:#B392F0;">countDown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        };</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(r).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        latch.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> timeStart;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">test2</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        CountDownLatch latch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CountDownLatch</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        AtomicLong atomicLong </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicLong</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> timeStart </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        Runnable r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100000</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                atomicLong.</span><span style="color:#B392F0;">incrementAndGet</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            latch.</span><span style="color:#B392F0;">countDown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        };</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(r).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        latch.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> timeStart;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Main</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;使用AtomicLong的时间消耗：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#6F42C1;">test2</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;ms&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;使用LongAdder的时间消耗：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#6F42C1;">test1</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;ms&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">test1</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">        CountDownLatch latch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CountDownLatch</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">100</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        LongAdder adder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LongAdder</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> timeStart </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        Runnable r </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100000</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                adder.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            latch.</span><span style="color:#6F42C1;">countDown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        };</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(r).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        latch.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> timeStart;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">test2</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">        CountDownLatch latch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CountDownLatch</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">100</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        AtomicLong atomicLong </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicLong</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> timeStart </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        Runnable r </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100000</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                atomicLong.</span><span style="color:#6F42C1;">incrementAndGet</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            latch.</span><span style="color:#6F42C1;">countDown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        };</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(r).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        latch.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> timeStart;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="atomicreference" tabindex="-1">AtomicReference <a class="header-anchor" href="#atomicreference" aria-label="Permalink to &quot;AtomicReference&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    String a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Hello&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    String b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;World&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    AtomicReference&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; reference </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> AtomicReference&lt;&gt;(a);</span></span>
<span class="line"><span style="color:#E1E4E8;">    reference.</span><span style="color:#B392F0;">compareAndSet</span><span style="color:#E1E4E8;">(a, b);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(reference.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    String a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    String b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;World&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    AtomicReference&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; reference </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> AtomicReference&lt;&gt;(a);</span></span>
<span class="line"><span style="color:#24292E;">    reference.</span><span style="color:#6F42C1;">compareAndSet</span><span style="color:#24292E;">(a, b);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(reference.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="atomicintegerfieldupdater" tabindex="-1">AtomicIntegerFieldUpdater <a class="header-anchor" href="#atomicintegerfieldupdater" aria-label="Permalink to &quot;AtomicIntegerFieldUpdater&quot;">​</a></h4><p>JUC还提供了字段原子更新器，可以对类中的某个指定字段进行原子操作（注意字段必须添加volatile关键字）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Student student </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Student</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        AtomicIntegerFieldUpdater&lt;</span><span style="color:#F97583;">Student</span><span style="color:#E1E4E8;">&gt; fieldUpdater </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">                AtomicIntegerFieldUpdater.</span><span style="color:#B392F0;">newUpdater</span><span style="color:#E1E4E8;">(Student.class, </span><span style="color:#9ECBFF;">&quot;age&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(fieldUpdater.</span><span style="color:#B392F0;">incrementAndGet</span><span style="color:#E1E4E8;">(student));</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Student</span><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> age;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Main</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">        Student student </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Student</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        AtomicIntegerFieldUpdater&lt;</span><span style="color:#D73A49;">Student</span><span style="color:#24292E;">&gt; fieldUpdater </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">                AtomicIntegerFieldUpdater.</span><span style="color:#6F42C1;">newUpdater</span><span style="color:#24292E;">(Student.class, </span><span style="color:#032F62;">&quot;age&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(fieldUpdater.</span><span style="color:#6F42C1;">incrementAndGet</span><span style="color:#24292E;">(student));</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Student</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> age;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="并发工具类" tabindex="-1">并发工具类 <a class="header-anchor" href="#并发工具类" aria-label="Permalink to &quot;并发工具类&quot;">​</a></h3><h4 id="countdownlatch-计数器锁" tabindex="-1">CountDownLatch 计数器锁 <a class="header-anchor" href="#countdownlatch-计数器锁" aria-label="Permalink to &quot;CountDownLatch 计数器锁&quot;">​</a></h4><blockquote><p>允许一个或多个线程，等待其他线程完成工作</p></blockquote><p><strong>实现原理</strong>：</p><ul><li>利用共享锁实现</li><li>在一开始的时候就是已经上了count层锁的状态，也就是<code>state = count</code></li><li><code>await()</code>就是加共享锁，但是必须<code>state</code>为<code>0</code>才能加锁成功，否则按照AQS的机制，会进入等待队列阻塞，加锁成功后结束阻塞</li><li><code>countDown()</code>就是解<code>1</code>层锁，也就是靠这个方法一点一点把<code>state</code>的值减到<code>0</code></li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CountDownLatch</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   	</span><span style="color:#6A737D;">//同样是通过内部类实现AbstractQueuedSynchronizer</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractQueuedSynchronizer</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">count</span><span style="color:#E1E4E8;">) {   </span><span style="color:#6A737D;">//这里直接使用AQS的state作为计数器（可见state能被玩出各种花样），也就是说一开始就加了count把共享锁，当线程调用countdown时，就解一层锁</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">setState</span><span style="color:#E1E4E8;">(count);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getCount</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getState</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//采用共享锁机制，因为可以被不同的线程countdown，所以实现的tryAcquireShared和tryReleaseShared</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//获取这把共享锁其实就是去等待state被其他线程减到0</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquireShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">acquires</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">getState</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryReleaseShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">releases</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 每次执行都会将state值-1，直到为0</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getState</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//如果已经是0了，那就false</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextc </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetState</span><span style="color:#E1E4E8;">(c, nextc))   </span><span style="color:#6A737D;">//CAS设置state值，失败直接下一轮循环</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> nextc </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;    </span><span style="color:#6A737D;">//返回c-1之后，是不是0，如果是那就true，否则false，也就是说只有刚好减到0的时候才会返回true</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Sync sync;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CountDownLatch</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">count</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (count </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IllegalArgumentException</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;count &lt; 0&quot;</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">//count那肯定不能小于0啊</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.sync </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;">(count);   </span><span style="color:#6A737D;">//构造Sync对象，将count作为state初始值</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   	</span><span style="color:#6A737D;">//通过acquireSharedInterruptibly方法获取共享锁，但是如果state不为0，那么会被持续阻塞，详细原理下面讲</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        sync.</span><span style="color:#B392F0;">acquireSharedInterruptibly</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//同上，但是会超时</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">timeout</span><span style="color:#E1E4E8;">, TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> sync.</span><span style="color:#B392F0;">tryAcquireSharedNanos</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, unit.</span><span style="color:#B392F0;">toNanos</span><span style="color:#E1E4E8;">(timeout));</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   	</span><span style="color:#6A737D;">//countDown其实就是解锁一次</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">countDown</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        sync.</span><span style="color:#B392F0;">releaseShared</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//获取当前的计数，也就是AQS中state的值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getCount</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> sync.</span><span style="color:#B392F0;">getCount</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//这个就不说了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> String </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;[Count = &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> sync.</span><span style="color:#B392F0;">getCount</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;]&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CountDownLatch</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   	</span><span style="color:#6A737D;">//同样是通过内部类实现AbstractQueuedSynchronizer</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractQueuedSynchronizer</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">count</span><span style="color:#24292E;">) {   </span><span style="color:#6A737D;">//这里直接使用AQS的state作为计数器（可见state能被玩出各种花样），也就是说一开始就加了count把共享锁，当线程调用countdown时，就解一层锁</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">setState</span><span style="color:#24292E;">(count);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getCount</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getState</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//采用共享锁机制，因为可以被不同的线程countdown，所以实现的tryAcquireShared和tryReleaseShared</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//获取这把共享锁其实就是去等待state被其他线程减到0</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquireShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">acquires</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">getState</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryReleaseShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">releases</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 每次执行都会将state值-1，直到为0</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getState</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//如果已经是0了，那就false</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextc </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetState</span><span style="color:#24292E;">(c, nextc))   </span><span style="color:#6A737D;">//CAS设置state值，失败直接下一轮循环</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> nextc </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;    </span><span style="color:#6A737D;">//返回c-1之后，是不是0，如果是那就true，否则false，也就是说只有刚好减到0的时候才会返回true</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Sync sync;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CountDownLatch</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">count</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (count </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalArgumentException</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;count &lt; 0&quot;</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">//count那肯定不能小于0啊</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.sync </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;">(count);   </span><span style="color:#6A737D;">//构造Sync对象，将count作为state初始值</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   	</span><span style="color:#6A737D;">//通过acquireSharedInterruptibly方法获取共享锁，但是如果state不为0，那么会被持续阻塞，详细原理下面讲</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">        sync.</span><span style="color:#6F42C1;">acquireSharedInterruptibly</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//同上，但是会超时</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">timeout</span><span style="color:#24292E;">, TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> sync.</span><span style="color:#6F42C1;">tryAcquireSharedNanos</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, unit.</span><span style="color:#6F42C1;">toNanos</span><span style="color:#24292E;">(timeout));</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   	</span><span style="color:#6A737D;">//countDown其实就是解锁一次</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">countDown</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        sync.</span><span style="color:#6F42C1;">releaseShared</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//获取当前的计数，也就是AQS中state的值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getCount</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> sync.</span><span style="color:#6F42C1;">getCount</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//这个就不说了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> String </span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;[Count = &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> sync.</span><span style="color:#6F42C1;">getCount</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;]&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h5 id="共享锁实现" tabindex="-1">共享锁实现 <a class="header-anchor" href="#共享锁实现" aria-label="Permalink to &quot;共享锁实现&quot;">​</a></h5><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">acquireShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">tryAcquireShared</span><span style="color:#E1E4E8;">(arg) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)   </span><span style="color:#6A737D;">//上来就调用tryAcquireShared尝试以共享模式获取锁，小于0则失败，上面判断的是state==0返回1，否则-1，也就是说如果计数器不为0，那么这里会判断成功</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">doAcquireShared</span><span style="color:#E1E4E8;">(arg);   </span><span style="color:#6A737D;">//计数器不为0的时候，按照它的机制，那么会阻塞，所以我们来看看doAcquireShared中是怎么进行阻塞的</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">acquireShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">tryAcquireShared</span><span style="color:#24292E;">(arg) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)   </span><span style="color:#6A737D;">//上来就调用tryAcquireShared尝试以共享模式获取锁，小于0则失败，上面判断的是state==0返回1，否则-1，也就是说如果计数器不为0，那么这里会判断成功</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">doAcquireShared</span><span style="color:#24292E;">(arg);   </span><span style="color:#6A737D;">//计数器不为0的时候，按照它的机制，那么会阻塞，所以我们来看看doAcquireShared中是怎么进行阻塞的</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doAcquireShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">addWaiter</span><span style="color:#E1E4E8;">(Node.SHARED);   </span><span style="color:#6A737D;">//向等待队列中添加一个新的共享模式结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> failed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> interrupted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {    </span><span style="color:#6A737D;">//无限循环</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.</span><span style="color:#B392F0;">predecessor</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//获取当前节点的前驱的结点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (p </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> head) {    </span><span style="color:#6A737D;">//如果p就是头结点，那么说明当前结点就是第一个等待节点</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquireShared</span><span style="color:#E1E4E8;">(arg);    </span><span style="color:#6A737D;">//会再次尝试获取共享锁</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (r </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {      </span><span style="color:#6A737D;">//要是获取成功</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">setHeadAndPropagate</span><span style="color:#E1E4E8;">(node, r);   </span><span style="color:#6A737D;">//那么就将当前节点设定为新的头结点，并且会继续唤醒后继节点</span></span>
<span class="line"><span style="color:#E1E4E8;">                    p.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// help GC</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (interrupted)</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#B392F0;">selfInterrupt</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    failed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">shouldParkAfterFailedAcquire</span><span style="color:#E1E4E8;">(p, node) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//和独占模式下一样的操作，这里不多说了</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">parkAndCheckInterrupt</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">                interrupted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (failed)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">cancelAcquire</span><span style="color:#E1E4E8;">(node);   </span><span style="color:#6A737D;">//如果最后都还是没获取到，那么就cancel</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">//其实感觉大体上和独占模式的获取有点像，但是它多了个传播机制，会继续唤醒后续节点</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doAcquireShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addWaiter</span><span style="color:#24292E;">(Node.SHARED);   </span><span style="color:#6A737D;">//向等待队列中添加一个新的共享模式结点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> failed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> interrupted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {    </span><span style="color:#6A737D;">//无限循环</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.</span><span style="color:#6F42C1;">predecessor</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//获取当前节点的前驱的结点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (p </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> head) {    </span><span style="color:#6A737D;">//如果p就是头结点，那么说明当前结点就是第一个等待节点</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> r </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquireShared</span><span style="color:#24292E;">(arg);    </span><span style="color:#6A737D;">//会再次尝试获取共享锁</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (r </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {      </span><span style="color:#6A737D;">//要是获取成功</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">setHeadAndPropagate</span><span style="color:#24292E;">(node, r);   </span><span style="color:#6A737D;">//那么就将当前节点设定为新的头结点，并且会继续唤醒后继节点</span></span>
<span class="line"><span style="color:#24292E;">                    p.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// help GC</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (interrupted)</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6F42C1;">selfInterrupt</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    failed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">shouldParkAfterFailedAcquire</span><span style="color:#24292E;">(p, node) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">   </span><span style="color:#6A737D;">//和独占模式下一样的操作，这里不多说了</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">parkAndCheckInterrupt</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">                interrupted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (failed)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">cancelAcquire</span><span style="color:#24292E;">(node);   </span><span style="color:#6A737D;">//如果最后都还是没获取到，那么就cancel</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">//其实感觉大体上和独占模式的获取有点像，但是它多了个传播机制，会继续唤醒后续节点</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setHeadAndPropagate</span><span style="color:#E1E4E8;">(Node node, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> propagate) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head; </span><span style="color:#6A737D;">// 取出头结点并将当前节点设定为新的头结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">setHead</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//因为一个线程成功获取到共享锁之后，有可能剩下的等待中的节点也有机会拿到共享锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (propagate </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> h.waitStatus </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">        (h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> h.waitStatus </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {   </span><span style="color:#6A737D;">//如果propagate大于0（表示共享锁还能继续获取）或是h.waitStatus &lt; 0，这是由于在其他线程释放共享锁时，doReleaseShared会将状态设定为PROPAGATE表示可以传播唤醒，后面会讲</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">isShared</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">doReleaseShared</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//继续唤醒下一个等待节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setHeadAndPropagate</span><span style="color:#24292E;">(Node node, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> propagate) {</span></span>
<span class="line"><span style="color:#24292E;">    Node h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head; </span><span style="color:#6A737D;">// 取出头结点并将当前节点设定为新的头结点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">setHead</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//因为一个线程成功获取到共享锁之后，有可能剩下的等待中的节点也有机会拿到共享锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (propagate </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> h.waitStatus </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">        (h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> h.waitStatus </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {   </span><span style="color:#6A737D;">//如果propagate大于0（表示共享锁还能继续获取）或是h.waitStatus &lt; 0，这是由于在其他线程释放共享锁时，doReleaseShared会将状态设定为PROPAGATE表示可以传播唤醒，后面会讲</span></span>
<span class="line"><span style="color:#24292E;">        Node s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.next;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">isShared</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">doReleaseShared</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//继续唤醒下一个等待节点</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>countdown过程：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">releaseShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">tryReleaseShared</span><span style="color:#E1E4E8;">(arg)) {   </span><span style="color:#6A737D;">//直接尝试释放锁，如果成功返回true（在CountDownLatch中只有state减到0的那一次，会返回true）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">doReleaseShared</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//这里也会调用doReleaseShared继续唤醒后面的结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//其他情况false</span></span>
<span class="line"><span style="color:#E1E4E8;">  									</span><span style="color:#6A737D;">//不过这里countdown并没有用到这些返回值</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">releaseShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">tryReleaseShared</span><span style="color:#24292E;">(arg)) {   </span><span style="color:#6A737D;">//直接尝试释放锁，如果成功返回true（在CountDownLatch中只有state减到0的那一次，会返回true）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">doReleaseShared</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//这里也会调用doReleaseShared继续唤醒后面的结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//其他情况false</span></span>
<span class="line"><span style="color:#24292E;">  									</span><span style="color:#6A737D;">//不过这里countdown并没有用到这些返回值</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doReleaseShared</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {   </span><span style="color:#6A737D;">//无限循环</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;    </span><span style="color:#6A737D;">//获取头结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> tail) {    </span><span style="color:#6A737D;">//如果头结点不为空且头结点不是尾结点，那么说明等待队列中存在节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ws </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> h.waitStatus;    </span><span style="color:#6A737D;">//取一下头结点的等待状态</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Node.SIGNAL) {    </span><span style="color:#6A737D;">//如果是SIGNAL，那么就CAS将头结点的状态设定为初始值</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(h, Node.SIGNAL, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;            </span><span style="color:#6A737D;">//失败就开下一轮循环重来</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">unparkSuccessor</span><span style="color:#E1E4E8;">(h);    </span><span style="color:#6A737D;">//和独占模式一样，当锁被释放，都会唤醒头结点的后继节点，doAcquireShared循环继续，如果成功，那么根据setHeadAndPropagate，又会继续调用当前方法，不断地传播下去，让后面的线程一个一个地获取到共享锁，直到不能再继续获取为止</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">                     </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(h, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, Node.PROPAGATE))   </span><span style="color:#6A737D;">//如果等待状态是默认值0，那么说明后继节点已经被唤醒，直接将状态设定为PROPAGATE，它代表在后续获取资源的时候，够向后面传播</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;                </span><span style="color:#6A737D;">//失败就开下一轮循环重来</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> head)                   </span><span style="color:#6A737D;">// 如果头结点发生了变化，不会break，而是继续循环，否则直接break退出</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doReleaseShared</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {   </span><span style="color:#6A737D;">//无限循环</span></span>
<span class="line"><span style="color:#24292E;">        Node h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;    </span><span style="color:#6A737D;">//获取头结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> tail) {    </span><span style="color:#6A737D;">//如果头结点不为空且头结点不是尾结点，那么说明等待队列中存在节点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ws </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> h.waitStatus;    </span><span style="color:#6A737D;">//取一下头结点的等待状态</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> Node.SIGNAL) {    </span><span style="color:#6A737D;">//如果是SIGNAL，那么就CAS将头结点的状态设定为初始值</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(h, Node.SIGNAL, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">))</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;            </span><span style="color:#6A737D;">//失败就开下一轮循环重来</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">unparkSuccessor</span><span style="color:#24292E;">(h);    </span><span style="color:#6A737D;">//和独占模式一样，当锁被释放，都会唤醒头结点的后继节点，doAcquireShared循环继续，如果成功，那么根据setHeadAndPropagate，又会继续调用当前方法，不断地传播下去，让后面的线程一个一个地获取到共享锁，直到不能再继续获取为止</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">                     </span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(h, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, Node.PROPAGATE))   </span><span style="color:#6A737D;">//如果等待状态是默认值0，那么说明后继节点已经被唤醒，直接将状态设定为PROPAGATE，它代表在后续获取资源的时候，够向后面传播</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;                </span><span style="color:#6A737D;">//失败就开下一轮循环重来</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> head)                   </span><span style="color:#6A737D;">// 如果头结点发生了变化，不会break，而是继续循环，否则直接break退出</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>总结：</p><ul><li>共享锁是线程共享的，同一时刻能有多个线程拥有共享锁。</li><li>如果一个线程刚获取了共享锁，那么在其之后等待的线程也很有可能能够获取到锁，所以得传播下去继续尝试唤醒后面的结点，不像独占锁，独占的压根不需要考虑这些。</li><li>如果一个线程刚释放了锁，不管是独占锁还是共享锁，都需要唤醒后续等待结点的线程。</li></ul><h5 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h5><blockquote><p>需求：</p><ul><li>有20个计算任务，我们需要先将这些任务的结果全部计算出来，每个任务的执行时间未知</li><li>当所有任务结束之后，立即整合统计最终结果</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">   CountDownLatch latch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CountDownLatch</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">//创建一个初始值为10的计数器锁</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> finalI </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">           </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">               Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">((</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;">) (</span><span style="color:#79B8FF;">2000</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Random</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">nextDouble</span><span style="color:#E1E4E8;">()));</span></span>
<span class="line"><span style="color:#E1E4E8;">               System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;子任务&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> finalI </span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;执行完成！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">           } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">               e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">           }</span></span>
<span class="line"><span style="color:#E1E4E8;">           latch.</span><span style="color:#B392F0;">countDown</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//每执行一次计数器都会-1</span></span>
<span class="line"><span style="color:#E1E4E8;">       }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//开始等待所有的线程完成，当计数器为0时，恢复运行</span></span>
<span class="line"><span style="color:#E1E4E8;">   latch.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//这个操作可以同时被多个线程执行，一起等待，这里只演示了一个</span></span>
<span class="line"><span style="color:#E1E4E8;">   System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;所有子任务都完成！任务完成！！！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;"> 	</span><span style="color:#6A737D;">//注意这个计数器只能使用一次，用完只能重新创一个，没有重置的说法</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">   CountDownLatch latch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CountDownLatch</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">20</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">//创建一个初始值为10的计数器锁</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">20</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> finalI </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">               Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">((</span><span style="color:#D73A49;">long</span><span style="color:#24292E;">) (</span><span style="color:#005CC5;">2000</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Random</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">nextDouble</span><span style="color:#24292E;">()));</span></span>
<span class="line"><span style="color:#24292E;">               System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;子任务&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> finalI </span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;执行完成！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">           } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">               e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">           }</span></span>
<span class="line"><span style="color:#24292E;">           latch.</span><span style="color:#6F42C1;">countDown</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//每执行一次计数器都会-1</span></span>
<span class="line"><span style="color:#24292E;">       }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//开始等待所有的线程完成，当计数器为0时，恢复运行</span></span>
<span class="line"><span style="color:#24292E;">   latch.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//这个操作可以同时被多个线程执行，一起等待，这里只演示了一个</span></span>
<span class="line"><span style="color:#24292E;">   System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;所有子任务都完成！任务完成！！！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;"> 	</span><span style="color:#6A737D;">//注意这个计数器只能使用一次，用完只能重新创一个，没有重置的说法</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在调用<code>await()</code>方法之后，实际上就是一个等待计数器衰减为0的过程，而进行自减操作则由各个子线程来完成，当子线程完成工作后，那么就将计数器-1，所有的子线程完成之后，计数器为0，结束等待。</p></blockquote><h4 id="cyclicbarrier-循环屏障" tabindex="-1">CyclicBarrier 循环屏障 <a class="header-anchor" href="#cyclicbarrier-循环屏障" aria-label="Permalink to &quot;CyclicBarrier 循环屏障&quot;">​</a></h4><blockquote><p>假如现在游戏房间内一共5人，但是游戏开始需要10人，所以我们必须等待剩下5人到来之后才能开始游戏，并且保证游戏开始时所有玩家都是同时进入，那么怎么实现这个功能呢？</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    CyclicBarrier barrier </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CyclicBarrier</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">,   </span><span style="color:#6A737D;">//创建一个初始值为10的循环屏障</span></span>
<span class="line"><span style="color:#E1E4E8;">                () </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;飞机马上就要起飞了，各位特种兵请准备！&quot;</span><span style="color:#E1E4E8;">));   </span><span style="color:#6A737D;">//人等够之后执行的任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> finalI </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">((</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;">) (</span><span style="color:#79B8FF;">2000</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Random</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">nextDouble</span><span style="color:#E1E4E8;">()));</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;玩家 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> finalI </span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 进入房间进行等待... (&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">barrier.</span><span style="color:#B392F0;">getNumberWaiting</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;/10)&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">                barrier.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//调用await方法进行等待，直到等待的线程足够多为止</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">//开始游戏，所有玩家一起进入游戏</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;玩家 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> finalI </span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 进入游戏！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException | BrokenBarrierException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) {</span></span>
<span class="line"><span style="color:#24292E;">    CyclicBarrier barrier </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CyclicBarrier</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">,   </span><span style="color:#6A737D;">//创建一个初始值为10的循环屏障</span></span>
<span class="line"><span style="color:#24292E;">                () </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;飞机马上就要起飞了，各位特种兵请准备！&quot;</span><span style="color:#24292E;">));   </span><span style="color:#6A737D;">//人等够之后执行的任务</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> finalI </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">((</span><span style="color:#D73A49;">long</span><span style="color:#24292E;">) (</span><span style="color:#005CC5;">2000</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Random</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">nextDouble</span><span style="color:#24292E;">()));</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;玩家 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> finalI </span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 进入房间进行等待... (&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">barrier.</span><span style="color:#6F42C1;">getNumberWaiting</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;/10)&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                barrier.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//调用await方法进行等待，直到等待的线程足够多为止</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">//开始游戏，所有玩家一起进入游戏</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;玩家 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> finalI </span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 进入游戏！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException | BrokenBarrierException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>循环屏障会不断阻挡线程，直到被阻挡的线程足够多时，才能一起冲破屏障，并且在冲破屏障时，我们也可以做一些其他的任务。</strong></p><p>屏障由于是可循环的，所以它在被冲破后，会重新开始计数，继续阻挡后续的线程：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    CyclicBarrier barrier </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CyclicBarrier</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">//创建一个初始值为5的循环屏障</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {   </span><span style="color:#6A737D;">//创建5个线程</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> finalI </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">((</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;">) (</span><span style="color:#79B8FF;">2000</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Random</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">nextDouble</span><span style="color:#E1E4E8;">()));</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;玩家 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> finalI </span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 进入房间进行等待... (&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">barrier.</span><span style="color:#B392F0;">getNumberWaiting</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;/5)&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">                barrier.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//调用await方法进行等待，直到等待线程到达5才会一起继续执行</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">//人数到齐之后，可以开始游戏了</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;玩家 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> finalI </span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 进入游戏！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException | BrokenBarrierException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) {</span></span>
<span class="line"><span style="color:#24292E;">    CyclicBarrier barrier </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CyclicBarrier</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">//创建一个初始值为5的循环屏障</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {   </span><span style="color:#6A737D;">//创建5个线程</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> finalI </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">((</span><span style="color:#D73A49;">long</span><span style="color:#24292E;">) (</span><span style="color:#005CC5;">2000</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Random</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">nextDouble</span><span style="color:#24292E;">()));</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;玩家 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> finalI </span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 进入房间进行等待... (&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">barrier.</span><span style="color:#6F42C1;">getNumberWaiting</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;/5)&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                barrier.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//调用await方法进行等待，直到等待线程到达5才会一起继续执行</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">//人数到齐之后，可以开始游戏了</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;玩家 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> finalI </span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 进入游戏！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException | BrokenBarrierException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过使用循环屏障，我们可以对线程进行一波一波地放行，每一波都放行5个线程，当然除了自动重置之外，我们也可以调用<code>reset()</code>方法来手动进行重置操作，同样会重新计数：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    CyclicBarrier barrier </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CyclicBarrier</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">//创建一个初始值为10的计数器锁</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                barrier.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException | BrokenBarrierException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">500</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//等一下上面的线程开始运行</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;当前屏障前的等待线程数：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">barrier.</span><span style="color:#B392F0;">getNumberWaiting</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    barrier.</span><span style="color:#B392F0;">reset</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;重置后屏障前的等待线程数：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">barrier.</span><span style="color:#B392F0;">getNumberWaiting</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    CyclicBarrier barrier </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CyclicBarrier</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">//创建一个初始值为10的计数器锁</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                barrier.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException | BrokenBarrierException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">500</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//等一下上面的线程开始运行</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;当前屏障前的等待线程数：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">barrier.</span><span style="color:#6F42C1;">getNumberWaiting</span><span style="color:#24292E;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    barrier.</span><span style="color:#6F42C1;">reset</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;重置后屏障前的等待线程数：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">barrier.</span><span style="color:#6F42C1;">getNumberWaiting</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在调用<code>reset()</code>之后，处于等待状态下的线程，全部被中断并且抛出BrokenBarrierException异常，循环屏障等待线程数归零。那么要是处于等待状态下的线程被中断了呢？屏障的线程等待数量会不会自动减少？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    CyclicBarrier barrier </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CyclicBarrier</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Runnable r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            barrier.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException | BrokenBarrierException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    };</span></span>
<span class="line"><span style="color:#E1E4E8;">    Thread t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(r);</span></span>
<span class="line"><span style="color:#E1E4E8;">    t.</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    t.</span><span style="color:#B392F0;">interrupt</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(r).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    CyclicBarrier barrier </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CyclicBarrier</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    Runnable r </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            barrier.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException | BrokenBarrierException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    };</span></span>
<span class="line"><span style="color:#24292E;">    Thread t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(r);</span></span>
<span class="line"><span style="color:#24292E;">    t.</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    t.</span><span style="color:#6F42C1;">interrupt</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(r).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>当<code>await()</code>状态下的线程被中断，那么屏障会直接变成损坏状态，一旦屏障损坏，那么这一轮就无法再做任何等待操作了。</p><p>只能进行<code>reset()</code>重置操作进行重置才能恢复正常。</p><p>**区分 **CountDownLatch&amp;CyclicBarrier：</p><ul><li>CountDownLatch： <ol><li>它只能使用一次，是一个一次性的工具</li><li>它是一个或多个线程用于等待其他线程完成的同步工具</li></ol></li><li>CyclicBarrier <ol><li>它可以反复使用，允许自动或手动重置计数</li><li>它是让一定数量的线程在同一时间开始运行的同步工具</li></ol></li></ul><p><strong>循环屏障的实现细节：</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CyclicBarrier</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//内部类，存放broken标记，表示屏障是否损坏，损坏的屏障是无法正常工作的</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Generation</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> broken </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    /** 内部维护一个可重入锁 */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReentrantLock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">    /** 再维护一个Condition */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Condition trip </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> lock.</span><span style="color:#B392F0;">newCondition</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">    /** 这个就是屏障的最大阻挡容量，就是构造方法传入的初始值 */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> parties;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/* 在屏障破裂时做的事情 */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Runnable barrierCommand;</span></span>
<span class="line"><span style="color:#6A737D;">    /** 当前这一轮的Generation对象，每一轮都有一个新的，用于保存broken标记 */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Generation generation </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Generation</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//默认为最大阻挡容量，每来一个线程-1，和CountDownLatch挺像，当屏障破裂或是被重置时，都会将其重置为最大阻挡容量</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> count;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//构造方法</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CyclicBarrier</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">parties</span><span style="color:#E1E4E8;">, Runnable </span><span style="color:#FFAB70;">barrierAction</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (parties </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IllegalArgumentException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.parties </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> parties;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> parties;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.barrierCommand </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> barrierAction;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CyclicBarrier</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">parties</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">(parties, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//开启下一轮屏障，一般屏障被冲破之后，就自动重置了，进入到下一轮</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">nextGeneration</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 唤醒所有等待状态的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">        trip.</span><span style="color:#B392F0;">signalAll</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 重置count的值</span></span>
<span class="line"><span style="color:#E1E4E8;">        count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> parties;</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//创建新的Generation对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        generation </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Generation</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//破坏当前屏障，变为损坏状态，之后就不能再使用了，除非重置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">breakBarrier</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        generation.broken </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> parties;</span></span>
<span class="line"><span style="color:#E1E4E8;">        trip.</span><span style="color:#B392F0;">signalAll</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//开始等待</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException, BrokenBarrierException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dowait</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0L</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (TimeoutException </span><span style="color:#FFAB70;">toe</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(toe); </span><span style="color:#6A737D;">// 因为这里没有使用定时机制，不可能发生异常，如果发生怕是出了错误</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//可超时的等待</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">timeout</span><span style="color:#E1E4E8;">, TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException,</span></span>
<span class="line"><span style="color:#E1E4E8;">               BrokenBarrierException,</span></span>
<span class="line"><span style="color:#E1E4E8;">               TimeoutException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dowait</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">, unit.</span><span style="color:#B392F0;">toNanos</span><span style="color:#E1E4E8;">(timeout));</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//这里就是真正的等待流程了，让我们细细道来</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dowait</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">timed</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">nanos</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException, BrokenBarrierException,</span></span>
<span class="line"><span style="color:#E1E4E8;">               TimeoutException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//加锁，注意，因为多个线程都会调用await方法，因此只有一个线程能进，其他都被卡着了</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Generation g </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> generation;   </span><span style="color:#6A737D;">//获取当前这一轮屏障的Generation对象</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (g.broken)</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BrokenBarrierException</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//如果这一轮屏障已经损坏，那就没办法使用了</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Thread.</span><span style="color:#B392F0;">interrupted</span><span style="color:#E1E4E8;">()) {   </span><span style="color:#6A737D;">//如果当前等待状态的线程被中断，那么会直接破坏掉屏障，并抛出中断异常（破坏屏障的第1种情况）</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">breakBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InterruptedException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">count;     </span><span style="color:#6A737D;">//如果上面都没有出现不正常，那么就走正常流程，首先count自减并赋值给index，index表示当前是等待的第几个线程</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (index </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {  </span><span style="color:#6A737D;">// 如果自减之后就是0了，那么说明来的线程已经足够，可以冲破屏障了</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> ranAction </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Runnable command </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> barrierCommand;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (command </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                        command.</span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//执行冲破屏障后的任务，如果这里抛异常了，那么会进finally</span></span>
<span class="line"><span style="color:#E1E4E8;">                    ranAction </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">nextGeneration</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//一切正常，开启下一轮屏障（方法进入之后会唤醒所有等待的线程，这样所有的线程都可以同时继续运行了）然后返回0，注意最下面finally中会解锁，不然其他线程唤醒了也拿不到锁啊</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">ranAction)   </span><span style="color:#6A737D;">//如果是上面出现异常进来的，那么也会直接破坏屏障（破坏屏障的第2种情况）</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#B392F0;">breakBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 能走到这里，那么说明当前等待的线程数还不够多，不足以冲破屏障</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {   </span><span style="color:#6A737D;">//无限循环，一直等，等到能冲破屏障或是出现异常为止</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">timed)</span></span>
<span class="line"><span style="color:#E1E4E8;">                        trip.</span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//如果不是定时的，那么就直接永久等待</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nanos </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0L</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                        nanos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> trip.</span><span style="color:#B392F0;">awaitNanos</span><span style="color:#E1E4E8;">(nanos);   </span><span style="color:#6A737D;">//否则最多等一段时间</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">ie</span><span style="color:#E1E4E8;">) {    </span><span style="color:#6A737D;">//等的时候会判断是否被中断（依然是破坏屏障的第1种情况）</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (g </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> generation </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;"> g.broken) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#B392F0;">breakBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> ie;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">interrupt</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (g.broken)</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BrokenBarrierException</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//如果线程被唤醒之后发现屏障已经被破坏，那么直接抛异常</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (g </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> generation)   </span><span style="color:#6A737D;">//成功冲破屏障开启下一轮，那么直接返回当前是第几个等待的线程。</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> index;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (timed </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> nanos </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0L</span><span style="color:#E1E4E8;">) {   </span><span style="color:#6A737D;">//线程等待超时，也会破坏屏障（破坏屏障的第3种情况）然后抛异常</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">breakBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TimeoutException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//最后别忘了解锁，不然其他线程拿不到锁</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//不多说了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getParties</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> parties;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//判断是否被破坏，也是加锁访问，因为有可能这时有其他线程正在执行dowait</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isBroken</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> generation.broken;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//重置操作，也要加锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reset</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">breakBarrier</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">// 先破坏这一轮的线程，注意这个方法会先破坏再唤醒所有等待的线程，那么所有等待的线程会直接抛BrokenBarrierException异常（详情请看上方dowait倒数第13行）</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">nextGeneration</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 开启下一轮</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//获取等待线程数量，也要加锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getNumberWaiting</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock lock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8;">        lock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> parties </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> count;   </span><span style="color:#6A737D;">//最大容量 - 当前剩余容量 = 正在等待线程数</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            lock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CyclicBarrier</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//内部类，存放broken标记，表示屏障是否损坏，损坏的屏障是无法正常工作的</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Generation</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> broken </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    /** 内部维护一个可重入锁 */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReentrantLock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">    /** 再维护一个Condition */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Condition trip </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> lock.</span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">    /** 这个就是屏障的最大阻挡容量，就是构造方法传入的初始值 */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> parties;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/* 在屏障破裂时做的事情 */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Runnable barrierCommand;</span></span>
<span class="line"><span style="color:#6A737D;">    /** 当前这一轮的Generation对象，每一轮都有一个新的，用于保存broken标记 */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Generation generation </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Generation</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//默认为最大阻挡容量，每来一个线程-1，和CountDownLatch挺像，当屏障破裂或是被重置时，都会将其重置为最大阻挡容量</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> count;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//构造方法</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CyclicBarrier</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">parties</span><span style="color:#24292E;">, Runnable </span><span style="color:#E36209;">barrierAction</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (parties </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalArgumentException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.parties </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> parties;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> parties;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.barrierCommand </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> barrierAction;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CyclicBarrier</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">parties</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">(parties, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//开启下一轮屏障，一般屏障被冲破之后，就自动重置了，进入到下一轮</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">nextGeneration</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 唤醒所有等待状态的线程</span></span>
<span class="line"><span style="color:#24292E;">        trip.</span><span style="color:#6F42C1;">signalAll</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 重置count的值</span></span>
<span class="line"><span style="color:#24292E;">        count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> parties;</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//创建新的Generation对象</span></span>
<span class="line"><span style="color:#24292E;">        generation </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Generation</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//破坏当前屏障，变为损坏状态，之后就不能再使用了，除非重置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">breakBarrier</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        generation.broken </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> parties;</span></span>
<span class="line"><span style="color:#24292E;">        trip.</span><span style="color:#6F42C1;">signalAll</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//开始等待</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException, BrokenBarrierException {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dowait</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">false</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0L</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (TimeoutException </span><span style="color:#E36209;">toe</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(toe); </span><span style="color:#6A737D;">// 因为这里没有使用定时机制，不可能发生异常，如果发生怕是出了错误</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//可超时的等待</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">timeout</span><span style="color:#24292E;">, TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException,</span></span>
<span class="line"><span style="color:#24292E;">               BrokenBarrierException,</span></span>
<span class="line"><span style="color:#24292E;">               TimeoutException {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dowait</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, unit.</span><span style="color:#6F42C1;">toNanos</span><span style="color:#24292E;">(timeout));</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//这里就是真正的等待流程了，让我们细细道来</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dowait</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#E36209;">timed</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">nanos</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException, BrokenBarrierException,</span></span>
<span class="line"><span style="color:#24292E;">               TimeoutException {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//加锁，注意，因为多个线程都会调用await方法，因此只有一个线程能进，其他都被卡着了</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Generation g </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> generation;   </span><span style="color:#6A737D;">//获取当前这一轮屏障的Generation对象</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (g.broken)</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BrokenBarrierException</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//如果这一轮屏障已经损坏，那就没办法使用了</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Thread.</span><span style="color:#6F42C1;">interrupted</span><span style="color:#24292E;">()) {   </span><span style="color:#6A737D;">//如果当前等待状态的线程被中断，那么会直接破坏掉屏障，并抛出中断异常（破坏屏障的第1种情况）</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">breakBarrier</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InterruptedException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">--</span><span style="color:#24292E;">count;     </span><span style="color:#6A737D;">//如果上面都没有出现不正常，那么就走正常流程，首先count自减并赋值给index，index表示当前是等待的第几个线程</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (index </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {  </span><span style="color:#6A737D;">// 如果自减之后就是0了，那么说明来的线程已经足够，可以冲破屏障了</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> ranAction </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Runnable command </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> barrierCommand;</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (command </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                        command.</span><span style="color:#6F42C1;">run</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//执行冲破屏障后的任务，如果这里抛异常了，那么会进finally</span></span>
<span class="line"><span style="color:#24292E;">                    ranAction </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">nextGeneration</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//一切正常，开启下一轮屏障（方法进入之后会唤醒所有等待的线程，这样所有的线程都可以同时继续运行了）然后返回0，注意最下面finally中会解锁，不然其他线程唤醒了也拿不到锁啊</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">ranAction)   </span><span style="color:#6A737D;">//如果是上面出现异常进来的，那么也会直接破坏屏障（破坏屏障的第2种情况）</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6F42C1;">breakBarrier</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 能走到这里，那么说明当前等待的线程数还不够多，不足以冲破屏障</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {   </span><span style="color:#6A737D;">//无限循环，一直等，等到能冲破屏障或是出现异常为止</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">timed)</span></span>
<span class="line"><span style="color:#24292E;">                        trip.</span><span style="color:#6F42C1;">await</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//如果不是定时的，那么就直接永久等待</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nanos </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0L</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                        nanos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> trip.</span><span style="color:#6F42C1;">awaitNanos</span><span style="color:#24292E;">(nanos);   </span><span style="color:#6A737D;">//否则最多等一段时间</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">ie</span><span style="color:#24292E;">) {    </span><span style="color:#6A737D;">//等的时候会判断是否被中断（依然是破坏屏障的第1种情况）</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (g </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> generation </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;"> g.broken) {</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6F42C1;">breakBarrier</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> ie;</span></span>
<span class="line"><span style="color:#24292E;">                    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                        Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">interrupt</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    }</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (g.broken)</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BrokenBarrierException</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//如果线程被唤醒之后发现屏障已经被破坏，那么直接抛异常</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (g </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> generation)   </span><span style="color:#6A737D;">//成功冲破屏障开启下一轮，那么直接返回当前是第几个等待的线程。</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> index;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (timed </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> nanos </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0L</span><span style="color:#24292E;">) {   </span><span style="color:#6A737D;">//线程等待超时，也会破坏屏障（破坏屏障的第3种情况）然后抛异常</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">breakBarrier</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TimeoutException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//最后别忘了解锁，不然其他线程拿不到锁</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//不多说了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getParties</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> parties;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//判断是否被破坏，也是加锁访问，因为有可能这时有其他线程正在执行dowait</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isBroken</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> generation.broken;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//重置操作，也要加锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reset</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">breakBarrier</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">// 先破坏这一轮的线程，注意这个方法会先破坏再唤醒所有等待的线程，那么所有等待的线程会直接抛BrokenBarrierException异常（详情请看上方dowait倒数第13行）</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">nextGeneration</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 开启下一轮</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//获取等待线程数量，也要加锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getNumberWaiting</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock lock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lock;</span></span>
<span class="line"><span style="color:#24292E;">        lock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> parties </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> count;   </span><span style="color:#6A737D;">//最大容量 - 当前剩余容量 = 正在等待线程数</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            lock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="semaphore-信号量" tabindex="-1">Semaphore 信号量 <a class="header-anchor" href="#semaphore-信号量" aria-label="Permalink to &quot;Semaphore 信号量&quot;">​</a></h4><blockquote><p>信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。</p></blockquote><p>通过使用信号量，我们可以决定某个资源同一时间能够被访问的最大线程数，它相当于对某个资源的访问进行了流量控制。简单来说，它就是一个可以被N个线程占用的排它锁（因此也支持公平和非公平模式），我们可以在最开始设定Semaphore的许可证数量，每个线程都可以获得1个或n个许可证，当许可证耗尽或不足以供其他线程获取时，其他线程将被阻塞。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span></span>
<span class="line"><span style="color:#E1E4E8;">    Semaphore semaphore </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Semaphore</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//许可证配额设定为2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                semaphore.</span><span style="color:#B392F0;">acquire</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//申请一个许可证</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;许可证申请成功！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                semaphore.</span><span style="color:#B392F0;">release</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//归还一个许可证</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span></span>
<span class="line"><span style="color:#24292E;">    Semaphore semaphore </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Semaphore</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//许可证配额设定为2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                semaphore.</span><span style="color:#6F42C1;">acquire</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//申请一个许可证</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;许可证申请成功！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                semaphore.</span><span style="color:#6F42C1;">release</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//归还一个许可证</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span></span>
<span class="line"><span style="color:#E1E4E8;">    Semaphore semaphore </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Semaphore</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//许可证配额设定为3</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                semaphore.</span><span style="color:#B392F0;">acquire</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);    </span><span style="color:#6A737D;">//一次性申请两个许可证</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;许可证申请成功！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span></span>
<span class="line"><span style="color:#24292E;">    Semaphore semaphore </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Semaphore</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//许可证配额设定为3</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                semaphore.</span><span style="color:#6F42C1;">acquire</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);    </span><span style="color:#6A737D;">//一次性申请两个许可证</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;许可证申请成功！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过Semaphore获取一些常规信息：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Semaphore semaphore </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Semaphore</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//只配置一个许可证，5个线程进行争抢，不内卷还想要许可证？</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(semaphore</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">acquireUninterruptibly).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//可以以不响应中断（主要是能简写一行，方便）</span></span>
<span class="line"><span style="color:#E1E4E8;">    Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">500</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;剩余许可证数量：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">semaphore.</span><span style="color:#B392F0;">availablePermits</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;是否存在线程等待许可证：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">(semaphore.</span><span style="color:#B392F0;">hasQueuedThreads</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;是&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;否&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;等待许可证线程数量：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">semaphore.</span><span style="color:#B392F0;">getQueueLength</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    Semaphore semaphore </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Semaphore</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//只配置一个许可证，5个线程进行争抢，不内卷还想要许可证？</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(semaphore</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">acquireUninterruptibly).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//可以以不响应中断（主要是能简写一行，方便）</span></span>
<span class="line"><span style="color:#24292E;">    Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">500</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;剩余许可证数量：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">semaphore.</span><span style="color:#6F42C1;">availablePermits</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;是否存在线程等待许可证：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">(semaphore.</span><span style="color:#6F42C1;">hasQueuedThreads</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;是&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;否&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;等待许可证线程数量：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">semaphore.</span><span style="color:#6F42C1;">getQueueLength</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>手动回收掉所有的许可证：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Semaphore semaphore </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Semaphore</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(semaphore</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">acquireUninterruptibly).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">500</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;收回剩余许可数量：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">semaphore.</span><span style="color:#B392F0;">drainPermits</span><span style="color:#E1E4E8;">());   </span><span style="color:#6A737D;">//直接回收掉剩余的许可证</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    Semaphore semaphore </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Semaphore</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(semaphore</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">acquireUninterruptibly).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">500</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;收回剩余许可数量：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">semaphore.</span><span style="color:#6F42C1;">drainPermits</span><span style="color:#24292E;">());   </span><span style="color:#6A737D;">//直接回收掉剩余的许可证</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="exchanger-数据交换" tabindex="-1">Exchanger 数据交换 <a class="header-anchor" href="#exchanger-数据交换" aria-label="Permalink to &quot;Exchanger 数据交换&quot;">​</a></h4><p>Exchanger，它能够实现线程之间的数据交换：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Exchanger&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; exchanger </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Exchanger&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;收到主线程传递的交换数据：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">exchanger.</span><span style="color:#B392F0;">exchange</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;AAAA&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;收到子线程传递的交换数据：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">exchanger.</span><span style="color:#B392F0;">exchange</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;BBBB&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    Exchanger&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; exchanger </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Exchanger&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;收到主线程传递的交换数据：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">exchanger.</span><span style="color:#6F42C1;">exchange</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;AAAA&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;收到子线程传递的交换数据：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">exchanger.</span><span style="color:#6F42C1;">exchange</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;BBBB&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在调用<code>exchange</code>方法后，当前线程会等待其他线程调用同一个exchanger对象的<code>exchange</code>方法，当另一个线程也调用之后，方法会返回对方线程传入的参数。</p><h4 id="fork-join框架" tabindex="-1">Fork/Join框架 <a class="header-anchor" href="#fork-join框架" aria-label="Permalink to &quot;Fork/Join框架&quot;">​</a></h4><ul><li><p>使用多线程拆分任务</p></li><li><p>利用工作窃取算法,提高线程的利用率</p><ul><li><p>**工作窃取算法：**是指某个线程从其他队列里窃取任务来执行。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p></li><li><p><img src="`+S+`" alt="image-20220406181701396"></p></li><li><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ForkJoinPool pool </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ForkJoinPool</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(pool.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">)).</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//继承RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RecursiveTask</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> start;   </span><span style="color:#6A737D;">//比如我们要计算一个范围内所有数的和，那么就需要限定一下范围，这里用了两个int存放</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> end;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">start</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">end</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.start </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> start;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.end </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> end;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> Integer </span><span style="color:#B392F0;">compute</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(end </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> start </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">125</span><span style="color:#E1E4E8;">) {    </span><span style="color:#6A737D;">//每个任务最多计算125个数的和，如果大于继续拆分，小于就可以开始算了</span></span>
<span class="line"><span style="color:#E1E4E8;">                SubTask subTask1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;">(start, (end </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> start) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                subTask1.</span><span style="color:#B392F0;">fork</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//会继续划分子任务执行</span></span>
<span class="line"><span style="color:#E1E4E8;">                SubTask subTask2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubTask</span><span style="color:#E1E4E8;">((end </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> start) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, end);</span></span>
<span class="line"><span style="color:#E1E4E8;">                subTask2.</span><span style="color:#B392F0;">fork</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//会继续划分子任务执行</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> subTask1.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> subTask2.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//越玩越有递归那味了</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 开始计算 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">start</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;-&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">end</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 的值!&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> start; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> end; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    res </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res;   </span><span style="color:#6A737D;">//返回的结果会作为join的结果</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Main</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#24292E;">        ForkJoinPool pool </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ForkJoinPool</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(pool.</span><span style="color:#6F42C1;">submit</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">)).</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//继承RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RecursiveTask</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> start;   </span><span style="color:#6A737D;">//比如我们要计算一个范围内所有数的和，那么就需要限定一下范围，这里用了两个int存放</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> end;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">start</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">end</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.start </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> start;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.end </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> end;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> Integer </span><span style="color:#6F42C1;">compute</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(end </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> start </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">125</span><span style="color:#24292E;">) {    </span><span style="color:#6A737D;">//每个任务最多计算125个数的和，如果大于继续拆分，小于就可以开始算了</span></span>
<span class="line"><span style="color:#24292E;">                SubTask subTask1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;">(start, (end </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> start) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                subTask1.</span><span style="color:#6F42C1;">fork</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//会继续划分子任务执行</span></span>
<span class="line"><span style="color:#24292E;">                SubTask subTask2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubTask</span><span style="color:#24292E;">((end </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> start) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, end);</span></span>
<span class="line"><span style="color:#24292E;">                subTask2.</span><span style="color:#6F42C1;">fork</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//会继续划分子任务执行</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> subTask1.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> subTask2.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//越玩越有递归那味了</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 开始计算 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">start</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;-&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">end</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 的值!&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> start; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> end; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    res </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res;   </span><span style="color:#6A737D;">//返回的结果会作为join的结果</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></li></ul></li></ul><p>Arrays工具类提供的并行排序也是利用了ForkJoinPool来实现：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">parallelSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] a) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a.length, p, g;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> MIN_ARRAY_SORT_GRAN </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">        (p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ForkJoinPool.</span><span style="color:#B392F0;">getCommonPoolParallelism</span><span style="color:#E1E4E8;">()) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        DualPivotQuicksort.</span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(a, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArraysParallelSortHelpers.FJByte.Sorter</span></span>
<span class="line"><span style="color:#E1E4E8;">            (</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, a, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[n], </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, n, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">             ((g </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> (p </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)) </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> MIN_ARRAY_SORT_GRAN) </span><span style="color:#F97583;">?</span></span>
<span class="line"><span style="color:#E1E4E8;">             MIN_ARRAY_SORT_GRAN </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> g).</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">parallelSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] a) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a.length, p, g;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> MIN_ARRAY_SORT_GRAN </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">        (p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ForkJoinPool.</span><span style="color:#6F42C1;">getCommonPoolParallelism</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        DualPivotQuicksort.</span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(a, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArraysParallelSortHelpers.FJByte.Sorter</span></span>
<span class="line"><span style="color:#24292E;">            (</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, a, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[n], </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, n, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">             ((g </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> (p </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)) </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> MIN_ARRAY_SORT_GRAN) </span><span style="color:#D73A49;">?</span></span>
<span class="line"><span style="color:#24292E;">             MIN_ARRAY_SORT_GRAN </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> g).</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="队列同步器aqs" tabindex="-1">队列同步器AQS <a class="header-anchor" href="#队列同步器aqs" aria-label="Permalink to &quot;队列同步器AQS&quot;">​</a></h3><h5 id="底层实现" tabindex="-1">底层实现 <a class="header-anchor" href="#底层实现" aria-label="Permalink to &quot;底层实现&quot;">​</a></h5><p>AbstractQueuedSynchronizer，简称队列同步器：内部封装了包括锁的获取、释放、以及等待队列。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">abstract</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractQueuedSynchronizer</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NonfairSync</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;"> {}</span></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FairSync</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;"> {}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">abstract</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractQueuedSynchronizer</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NonfairSync</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;"> {}</span></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FairSync</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;"> {}</span></span></code></pre></div><p>一个锁（排他锁为例）的基本功能就是获取锁、释放锁、当锁被占用时，其他线程来争抢会进入等待队列，AQS已经将这些基本的功能封装完成了，其中等待队列是核心内容，等待队列是由双向链表数据结构实现的，每个等待状态下的线程都可以被封装进结点中并放入双向链表中，而对于双向链表是以队列的形式进行操作的，如下：</p><p><img src="`+f+`" alt="image-20220405201620171"></p><p>AQS中有一个<code>head</code>字段和一个<code>tail</code>字段分别记录双向链表的头结点和尾结点，而之后的一系列操作都是围绕此队列来进行的。</p><p>了哪些内容：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//每个处于等待状态的线程都可以是一个节点，并且每个节点是有很多状态的</span></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node SHARED </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node EXCLUSIVE </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//等待状态，这里都定义好了</span></span>
<span class="line"><span style="color:#E1E4E8;">   	</span><span style="color:#6A737D;">//唯一一个大于0的状态，表示已失效，可能是由于超时或中断，此节点被取消。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> CANCELLED </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//此节点后面的节点被挂起（进入等待状态）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> SIGNAL    </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;	</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//在条件队列中的节点才是这个状态</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> CONDITION </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//传播，一般用于共享锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> PROPAGATE </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> waitStatus;    </span><span style="color:#6A737D;">//等待状态值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Node prev;   </span><span style="color:#6A737D;">//双向链表基操</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Node next;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Thread thread;   </span><span style="color:#6A737D;">//每一个线程都可以被封装进一个节点进入到等待队列</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">    Node nextWaiter;   </span><span style="color:#6A737D;">//在等待队列中表示模式，条件队列中作为下一个结点的指针</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isShared</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> nextWaiter </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> SHARED;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node </span><span style="color:#B392F0;">predecessor</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> NullPointerException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> prev;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (p </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NullPointerException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">(Thread </span><span style="color:#FFAB70;">thread</span><span style="color:#E1E4E8;">, Node </span><span style="color:#FFAB70;">mode</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.nextWaiter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mode;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.thread </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> thread;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">(Thread </span><span style="color:#FFAB70;">thread</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">waitStatus</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.waitStatus </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> waitStatus;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.thread </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> thread;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//每个处于等待状态的线程都可以是一个节点，并且每个节点是有很多状态的</span></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node SHARED </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node EXCLUSIVE </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//等待状态，这里都定义好了</span></span>
<span class="line"><span style="color:#24292E;">   	</span><span style="color:#6A737D;">//唯一一个大于0的状态，表示已失效，可能是由于超时或中断，此节点被取消。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> CANCELLED </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//此节点后面的节点被挂起（进入等待状态）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> SIGNAL    </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;	</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//在条件队列中的节点才是这个状态</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> CONDITION </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//传播，一般用于共享锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> PROPAGATE </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> waitStatus;    </span><span style="color:#6A737D;">//等待状态值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Node prev;   </span><span style="color:#6A737D;">//双向链表基操</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Node next;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Thread thread;   </span><span style="color:#6A737D;">//每一个线程都可以被封装进一个节点进入到等待队列</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">    Node nextWaiter;   </span><span style="color:#6A737D;">//在等待队列中表示模式，条件队列中作为下一个结点的指针</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isShared</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> nextWaiter </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> SHARED;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node </span><span style="color:#6F42C1;">predecessor</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> NullPointerException {</span></span>
<span class="line"><span style="color:#24292E;">        Node p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> prev;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (p </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NullPointerException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">(Thread </span><span style="color:#E36209;">thread</span><span style="color:#24292E;">, Node </span><span style="color:#E36209;">mode</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.nextWaiter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mode;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.thread </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> thread;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">(Thread </span><span style="color:#E36209;">thread</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">waitStatus</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.waitStatus </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> waitStatus;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.thread </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> thread;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在一开始的时候，<code>head</code>和<code>tail</code>都是<code>null</code>，<code>state</code>为默认值<code>0</code>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Node head;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> Node tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> state;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Node head;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> Node tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> state;</span></span></code></pre></div><p>不用担心双向链表不会进行初始化，初始化是在实际使用时才开始的，先不管，我们接着来看其他的初始化内容：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//直接使用Unsafe类进行操作</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Unsafe unsafe </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Unsafe.</span><span style="color:#B392F0;">getUnsafe</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">//记录类中属性的在内存中的偏移地址，方便Unsafe类直接操作内存进行赋值等（直接修改对应地址的内存）</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> stateOffset;   </span><span style="color:#6A737D;">//这里对应的就是AQS类中的state成员字段</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> headOffset;    </span><span style="color:#6A737D;">//这里对应的就是AQS类中的head头结点成员字段</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> tailOffset;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> waitStatusOffset;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> nextOffset;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> {   </span><span style="color:#6A737D;">//静态代码块，在类加载的时候就会自动获取偏移地址</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        stateOffset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#E1E4E8;">            (AbstractQueuedSynchronizer.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;state&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">        headOffset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#E1E4E8;">            (AbstractQueuedSynchronizer.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;head&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">        tailOffset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#E1E4E8;">            (AbstractQueuedSynchronizer.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;tail&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">        waitStatusOffset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#E1E4E8;">            (Node.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;waitStatus&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">        nextOffset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#E1E4E8;">            (Node.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;next&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Exception </span><span style="color:#FFAB70;">ex</span><span style="color:#E1E4E8;">) { </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(ex); }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//通过CAS操作来修改头结点</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compareAndSetHead</span><span style="color:#E1E4E8;">(Node update) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//调用的是Unsafe类的compareAndSwapObject方法，通过CAS算法比较对象并替换</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> unsafe.</span><span style="color:#B392F0;">compareAndSwapObject</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, headOffset, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, update);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//同上，省略部分代码</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compareAndSetTail</span><span style="color:#E1E4E8;">(Node expect, Node update) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(Node node, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> expect, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> update) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compareAndSetNext</span><span style="color:#E1E4E8;">(Node node, Node expect, Node update) {</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//直接使用Unsafe类进行操作</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Unsafe unsafe </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Unsafe.</span><span style="color:#6F42C1;">getUnsafe</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">//记录类中属性的在内存中的偏移地址，方便Unsafe类直接操作内存进行赋值等（直接修改对应地址的内存）</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> stateOffset;   </span><span style="color:#6A737D;">//这里对应的就是AQS类中的state成员字段</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> headOffset;    </span><span style="color:#6A737D;">//这里对应的就是AQS类中的head头结点成员字段</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> tailOffset;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> waitStatusOffset;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> nextOffset;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> {   </span><span style="color:#6A737D;">//静态代码块，在类加载的时候就会自动获取偏移地址</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        stateOffset </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#24292E;">            (AbstractQueuedSynchronizer.class.</span><span style="color:#6F42C1;">getDeclaredField</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;state&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">        headOffset </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#24292E;">            (AbstractQueuedSynchronizer.class.</span><span style="color:#6F42C1;">getDeclaredField</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;head&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">        tailOffset </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#24292E;">            (AbstractQueuedSynchronizer.class.</span><span style="color:#6F42C1;">getDeclaredField</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;tail&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">        waitStatusOffset </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#24292E;">            (Node.class.</span><span style="color:#6F42C1;">getDeclaredField</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;waitStatus&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">        nextOffset </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unsafe.objectFieldOffset</span></span>
<span class="line"><span style="color:#24292E;">            (Node.class.</span><span style="color:#6F42C1;">getDeclaredField</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;next&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Exception </span><span style="color:#E36209;">ex</span><span style="color:#24292E;">) { </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(ex); }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//通过CAS操作来修改头结点</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compareAndSetHead</span><span style="color:#24292E;">(Node update) {</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//调用的是Unsafe类的compareAndSwapObject方法，通过CAS算法比较对象并替换</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> unsafe.</span><span style="color:#6F42C1;">compareAndSwapObject</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, headOffset, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, update);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//同上，省略部分代码</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compareAndSetTail</span><span style="color:#24292E;">(Node expect, Node update) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(Node node, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> expect, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> update) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compareAndSetNext</span><span style="color:#24292E;">(Node node, Node expect, Node update) {</span></span></code></pre></div><p>可以发现，队列同步器由于要使用到CAS算法，所以，直接使用了Unsafe工具类，Unsafe类中提供了CAS操作的方法（Java无法实现，底层由C++实现）所有对AQS类中成员字段的修改，都有对应的CAS操作封装。</p><p>现在我们大致了解了一下它的底层运作机制，我们接着来看这个类是如何进行使用的，它提供了一些可重写的方法（根据不同的锁类型和机制，可以自由定制规则，并且为独占式和非独占式锁都提供了对应的方法），以及一些已经写好的模板方法（模板方法会调用这些可重写的方法），使用此类只需要将可重写的方法进行重写，并调用提供的模板方法，从而实现锁功能（学习过设计模式会比较好理解一些）</p><p>我们首先来看可重写方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//独占式获取同步状态，查看同步状态是否和参数一致，如果返没有问题，那么会使用CAS操作设置同步状态并返回true</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//独占式释放同步状态</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryRelease</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//共享式获取同步状态，返回值大于0表示成功，否则失败</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquireShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//共享式释放同步状态</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryReleaseShared</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//是否在独占模式下被当前线程占用（锁是否被当前线程持有）</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isHeldExclusively</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">UnsupportedOperationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//独占式获取同步状态，查看同步状态是否和参数一致，如果返没有问题，那么会使用CAS操作设置同步状态并返回true</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//独占式释放同步状态</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryRelease</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//共享式获取同步状态，返回值大于0表示成功，否则失败</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquireShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//共享式释放同步状态</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryReleaseShared</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//是否在独占模式下被当前线程占用（锁是否被当前线程持有）</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isHeldExclusively</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">UnsupportedOperationException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>可以看到，这些需要重写的方法默认是直接抛出<code>UnsupportedOperationException</code>，也就是说根据不同的锁类型，我们需要去实现对应的方法，我们可以来看一下ReentrantLock（此类是全局独占式的）中的公平锁是如何借助AQS实现的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FairSync</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> serialVersionUID </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">3000897897090466540L</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//加锁操作调用了模板方法acquire</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//为了防止各位绕晕，请时刻记住，lock方法一定是在某个线程下为了加锁而调用的，并且同一时间可能会有其他线程也在调用此方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">acquire</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    ...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FairSync</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> serialVersionUID </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">3000897897090466540L</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//加锁操作调用了模板方法acquire</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//为了防止各位绕晕，请时刻记住，lock方法一定是在某个线程下为了加锁而调用的，并且同一时间可能会有其他线程也在调用此方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">acquire</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    ...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>我们先看看加锁操作干了什么事情，这里直接调用了AQS提供的模板方法<code>acquire()</code>，我们来看看它在AQS类中的实现细节：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">ReservedStackAccess</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">//这个是JEP 270添加的新注解，它会保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出，下同</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">acquire</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(arg) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">acquireQueued</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">addWaiter</span><span style="color:#E1E4E8;">(Node.EXCLUSIVE), arg))   </span><span style="color:#6A737D;">//节点为独占模式Node.EXCLUSIVE</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">selfInterrupt</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">ReservedStackAccess</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">//这个是JEP 270添加的新注解，它会保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出，下同</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">acquire</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(arg) </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">acquireQueued</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">addWaiter</span><span style="color:#24292E;">(Node.EXCLUSIVE), arg))   </span><span style="color:#6A737D;">//节点为独占模式Node.EXCLUSIVE</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">selfInterrupt</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>首先会调用<code>tryAcquire()</code>方法（这里是由FairSync类实现的），如果尝试加独占锁失败（返回false了）说明可能这个时候有其他线程持有了此独占锁，所以当前线程得先等着，那么会调用<code>addWaiter()</code>方法将线程加入等待队列中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Node </span><span style="color:#B392F0;">addWaiter</span><span style="color:#E1E4E8;">(Node mode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">(), mode);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 先尝试使用CAS直接入队，如果这个时候其他线程也在入队（就是不止一个线程在同一时间争抢这把锁）就进入enq()</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node pred </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (pred </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        node.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetTail</span><span style="color:#E1E4E8;">(pred, node)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            pred.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//此方法是CAS快速入队失败时调用</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">enq</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Node </span><span style="color:#B392F0;">enq</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//自旋形式入队，可以看到这里是一个无限循环</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {  </span><span style="color:#6A737D;">//这种情况只能说明头结点和尾结点都还没初始化</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetHead</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">()))   </span><span style="color:#6A737D;">//初始化头结点和尾结点</span></span>
<span class="line"><span style="color:#E1E4E8;">                tail </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            node.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetTail</span><span style="color:#E1E4E8;">(t, node)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                t.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> t;   </span><span style="color:#6A737D;">//只有CAS成功的情况下，才算入队成功，如果CAS失败，那说明其他线程同一时间也在入队，并且手速还比当前线程快，刚好走到CAS操作的时候，其他线程就先入队了，那么这个时候node.prev就不是我们预期的节点了，而是另一个线程新入队的节点，所以说得进下一次循环再来一次CAS，这种形式就是自旋</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Node </span><span style="color:#6F42C1;">addWaiter</span><span style="color:#24292E;">(Node mode) {</span></span>
<span class="line"><span style="color:#24292E;">    Node node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">(), mode);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 先尝试使用CAS直接入队，如果这个时候其他线程也在入队（就是不止一个线程在同一时间争抢这把锁）就进入enq()</span></span>
<span class="line"><span style="color:#24292E;">    Node pred </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (pred </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        node.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetTail</span><span style="color:#24292E;">(pred, node)) {</span></span>
<span class="line"><span style="color:#24292E;">            pred.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//此方法是CAS快速入队失败时调用</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">enq</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Node </span><span style="color:#6F42C1;">enq</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node node) {</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//自旋形式入队，可以看到这里是一个无限循环</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {</span></span>
<span class="line"><span style="color:#24292E;">        Node t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {  </span><span style="color:#6A737D;">//这种情况只能说明头结点和尾结点都还没初始化</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetHead</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">()))   </span><span style="color:#6A737D;">//初始化头结点和尾结点</span></span>
<span class="line"><span style="color:#24292E;">                tail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            node.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetTail</span><span style="color:#24292E;">(t, node)) {</span></span>
<span class="line"><span style="color:#24292E;">                t.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t;   </span><span style="color:#6A737D;">//只有CAS成功的情况下，才算入队成功，如果CAS失败，那说明其他线程同一时间也在入队，并且手速还比当前线程快，刚好走到CAS操作的时候，其他线程就先入队了，那么这个时候node.prev就不是我们预期的节点了，而是另一个线程新入队的节点，所以说得进下一次循环再来一次CAS，这种形式就是自旋</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在了解了<code>addWaiter()</code>方法会将节点加入等待队列之后，我们接着来看，<code>addWaiter()</code>会返回已经加入的节点，<code>acquireQueued()</code>在得到返回的节点时，也会进入自旋状态，等待唤醒（也就是开始进入到拿锁的环节了）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">acquireQueued</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node node, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> failed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> interrupted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.</span><span style="color:#B392F0;">predecessor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (p </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> head </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(arg)) {   </span><span style="color:#6A737D;">//可以看到当此节点位于队首(node.prev == head)时，会再次调用tryAcquire方法获取锁，如果获取成功，会返回此过程中是否被中断的值</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">setHead</span><span style="color:#E1E4E8;">(node);    </span><span style="color:#6A737D;">//新的头结点设置为当前结点</span></span>
<span class="line"><span style="color:#E1E4E8;">                p.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 原有的头结点没有存在的意义了</span></span>
<span class="line"><span style="color:#E1E4E8;">                failed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//没有失败</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> interrupted;   </span><span style="color:#6A737D;">//直接返回等待过程中是否被中断</span></span>
<span class="line"><span style="color:#E1E4E8;">            }	</span></span>
<span class="line"><span style="color:#E1E4E8;">          	</span><span style="color:#6A737D;">//依然没获取成功，</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">shouldParkAfterFailedAcquire</span><span style="color:#E1E4E8;">(p, node) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//将当前节点的前驱节点等待状态设置为SIGNAL，如果失败将直接开启下一轮循环，直到成功为止，如果成功接着往下</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">parkAndCheckInterrupt</span><span style="color:#E1E4E8;">())   </span><span style="color:#6A737D;">//挂起线程进入等待状态，等待被唤醒，如果在等待状态下被中断，那么会返回true，直接将中断标志设为true，否则就是正常唤醒，继续自旋</span></span>
<span class="line"><span style="color:#E1E4E8;">                interrupted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (failed)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">cancelAcquire</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">parkAndCheckInterrupt</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    LockSupport.</span><span style="color:#B392F0;">park</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//通过unsafe类操作底层挂起线程（会直接进入阻塞状态）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">interrupted</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">acquireQueued</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node node, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> failed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> interrupted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.</span><span style="color:#6F42C1;">predecessor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (p </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> head </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(arg)) {   </span><span style="color:#6A737D;">//可以看到当此节点位于队首(node.prev == head)时，会再次调用tryAcquire方法获取锁，如果获取成功，会返回此过程中是否被中断的值</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">setHead</span><span style="color:#24292E;">(node);    </span><span style="color:#6A737D;">//新的头结点设置为当前结点</span></span>
<span class="line"><span style="color:#24292E;">                p.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 原有的头结点没有存在的意义了</span></span>
<span class="line"><span style="color:#24292E;">                failed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//没有失败</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> interrupted;   </span><span style="color:#6A737D;">//直接返回等待过程中是否被中断</span></span>
<span class="line"><span style="color:#24292E;">            }	</span></span>
<span class="line"><span style="color:#24292E;">          	</span><span style="color:#6A737D;">//依然没获取成功，</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">shouldParkAfterFailedAcquire</span><span style="color:#24292E;">(p, node) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">   </span><span style="color:#6A737D;">//将当前节点的前驱节点等待状态设置为SIGNAL，如果失败将直接开启下一轮循环，直到成功为止，如果成功接着往下</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">parkAndCheckInterrupt</span><span style="color:#24292E;">())   </span><span style="color:#6A737D;">//挂起线程进入等待状态，等待被唤醒，如果在等待状态下被中断，那么会返回true，直接将中断标志设为true，否则就是正常唤醒，继续自旋</span></span>
<span class="line"><span style="color:#24292E;">                interrupted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (failed)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">cancelAcquire</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">parkAndCheckInterrupt</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    LockSupport.</span><span style="color:#6F42C1;">park</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//通过unsafe类操作底层挂起线程（会直接进入阻塞状态）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">interrupted</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">shouldParkAfterFailedAcquire</span><span style="color:#E1E4E8;">(Node pred, Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ws </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred.waitStatus;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Node.SIGNAL)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//已经是SIGNAL，直接true</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {   </span><span style="color:#6A737D;">//不能是已经取消的节点，必须找到一个没被取消的</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            node.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred.prev;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (pred.waitStatus </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        pred.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;   </span><span style="color:#6A737D;">//直接抛弃被取消的节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">//不是SIGNAL，先CAS设置为SIGNAL（这里没有返回true因为CAS不一定成功，需要下一轮再判断一次）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(pred, ws, Node.SIGNAL);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//返回false，马上开启下一轮循环</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">shouldParkAfterFailedAcquire</span><span style="color:#24292E;">(Node pred, Node node) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ws </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred.waitStatus;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> Node.SIGNAL)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//已经是SIGNAL，直接true</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {   </span><span style="color:#6A737D;">//不能是已经取消的节点，必须找到一个没被取消的</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            node.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred.prev;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (pred.waitStatus </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        pred.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;   </span><span style="color:#6A737D;">//直接抛弃被取消的节点</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//不是SIGNAL，先CAS设置为SIGNAL（这里没有返回true因为CAS不一定成功，需要下一轮再判断一次）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(pred, ws, Node.SIGNAL);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//返回false，马上开启下一轮循环</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>所以，<code>acquire()</code>中的if条件如果为true，那么只有一种情况，就是等待过程中被中断了，其他任何情况下都是成功获取到独占锁，所以当等待过程被中断时，会调用<code>selfInterrupt()</code>方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">selfInterrupt</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">interrupt</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">selfInterrupt</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">interrupt</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里就是直接向当前线程发送中断信号了。</p><p>上面提到了LockSupport类，它是一个工具类，我们也可以来玩一下这个<code>park</code>和<code>unpark</code>:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Thread t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">//先拿到主线程的Thread对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;主线程可以继续运行了！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            LockSupport.</span><span style="color:#B392F0;">unpark</span><span style="color:#E1E4E8;">(t);</span></span>
<span class="line"><span style="color:#E1E4E8;">          	</span><span style="color:#6A737D;">//t.interrupt();   发送中断信号也可以恢复运行</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;主线程被挂起！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    LockSupport.</span><span style="color:#B392F0;">park</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;主线程继续运行！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    Thread t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">();  </span><span style="color:#6A737D;">//先拿到主线程的Thread对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;主线程可以继续运行了！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            LockSupport.</span><span style="color:#6F42C1;">unpark</span><span style="color:#24292E;">(t);</span></span>
<span class="line"><span style="color:#24292E;">          	</span><span style="color:#6A737D;">//t.interrupt();   发送中断信号也可以恢复运行</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;主线程被挂起！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    LockSupport.</span><span style="color:#6F42C1;">park</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;主线程继续运行！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里我们就把公平锁的<code>lock()</code>方法实现讲解完毕了（让我猜猜，已经晕了对吧，越是到源码越考验个人的基础知识掌握，基础不牢地动山摇）接着我们来看公平锁的<code>tryAcquire()</code>方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FairSync</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//可重入独占锁的公平实现</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">acquires</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Thread current </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//先获取当前线程的Thread对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getState</span><span style="color:#E1E4E8;">();     </span><span style="color:#6A737D;">//获取当前AQS对象状态（独占模式下0为未占用，大于0表示已占用）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {       </span><span style="color:#6A737D;">//如果是0，那就表示没有占用，现在我们的线程就要来尝试占用它</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">hasQueuedPredecessors</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//等待队列是否不为空且当前线程没有拿到锁，其实就是看看当前线程有没有必要进行排队，如果没必要排队，就说明可以直接获取锁</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">compareAndSetState</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, acquires)) {   </span><span style="color:#6A737D;">//CAS设置状态，如果成功则说明成功拿到了这把锁，失败则说明可能这个时候其他线程在争抢，并且还比你先抢到</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">setExclusiveOwnerThread</span><span style="color:#E1E4E8;">(current);    </span><span style="color:#6A737D;">//成功拿到锁，会将独占模式所有者线程设定为当前线程（这个方法是父类AbstractOwnableSynchronizer中的，就表示当前这把锁已经是这个线程的了）</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//占用锁成功，返回true</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (current </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getExclusiveOwnerThread</span><span style="color:#E1E4E8;">()) {   </span><span style="color:#6A737D;">//如果不是0，那就表示被线程占用了，这个时候看看是不是自己占用的，如果是，由于是可重入锁，可以继续加锁</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextc </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> acquires;    </span><span style="color:#6A737D;">//多次加锁会将状态值进行增加，状态值就是加锁次数</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nextc </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)   </span><span style="color:#6A737D;">//加到int值溢出了？</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Maximum lock count exceeded&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">setState</span><span style="color:#E1E4E8;">(nextc);   </span><span style="color:#6A737D;">//设置为新的加锁次数</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//其他任何情况都是加锁失败</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FairSync</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//可重入独占锁的公平实现</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">acquires</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Thread current </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//先获取当前线程的Thread对象</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getState</span><span style="color:#24292E;">();     </span><span style="color:#6A737D;">//获取当前AQS对象状态（独占模式下0为未占用，大于0表示已占用）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {       </span><span style="color:#6A737D;">//如果是0，那就表示没有占用，现在我们的线程就要来尝试占用它</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">hasQueuedPredecessors</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">    </span><span style="color:#6A737D;">//等待队列是否不为空且当前线程没有拿到锁，其实就是看看当前线程有没有必要进行排队，如果没必要排队，就说明可以直接获取锁</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">compareAndSetState</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, acquires)) {   </span><span style="color:#6A737D;">//CAS设置状态，如果成功则说明成功拿到了这把锁，失败则说明可能这个时候其他线程在争抢，并且还比你先抢到</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">setExclusiveOwnerThread</span><span style="color:#24292E;">(current);    </span><span style="color:#6A737D;">//成功拿到锁，会将独占模式所有者线程设定为当前线程（这个方法是父类AbstractOwnableSynchronizer中的，就表示当前这把锁已经是这个线程的了）</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//占用锁成功，返回true</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (current </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getExclusiveOwnerThread</span><span style="color:#24292E;">()) {   </span><span style="color:#6A737D;">//如果不是0，那就表示被线程占用了，这个时候看看是不是自己占用的，如果是，由于是可重入锁，可以继续加锁</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextc </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> acquires;    </span><span style="color:#6A737D;">//多次加锁会将状态值进行增加，状态值就是加锁次数</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nextc </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)   </span><span style="color:#6A737D;">//加到int值溢出了？</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Maximum lock count exceeded&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">setState</span><span style="color:#24292E;">(nextc);   </span><span style="color:#6A737D;">//设置为新的加锁次数</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//其他任何情况都是加锁失败</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在了解了公平锁的实现之后，是不是感觉有点恍然大悟的感觉，虽然整个过程非常复杂，但是只要理清思路，还是比较简单的。</p><p>加锁过程已经OK，我们接着来看，它的解锁过程，<code>unlock()</code>方法是在AQS中实现的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    sync.</span><span style="color:#B392F0;">release</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);    </span><span style="color:#6A737D;">//直接调用了AQS中的release方法，参数为1表示解锁一次state值-1</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    sync.</span><span style="color:#6F42C1;">release</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);    </span><span style="color:#6A737D;">//直接调用了AQS中的release方法，参数为1表示解锁一次state值-1</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">release</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> arg) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">tryRelease</span><span style="color:#E1E4E8;">(arg)) {   </span><span style="color:#6A737D;">//和tryAcquire一样，也得子类去重写，释放锁操作</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;    </span><span style="color:#6A737D;">//释放锁成功后，获取新的头结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> h.waitStatus </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)   </span><span style="color:#6A737D;">//如果新的头结点不为空并且不是刚刚建立的结点（初始状态下status为默认值0，而上面在进行了shouldParkAfterFailedAcquire之后，会被设定为SIGNAL状态，值为-1）</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">unparkSuccessor</span><span style="color:#E1E4E8;">(h);   </span><span style="color:#6A737D;">//唤醒头节点下一个节点中的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">release</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> arg) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">tryRelease</span><span style="color:#24292E;">(arg)) {   </span><span style="color:#6A737D;">//和tryAcquire一样，也得子类去重写，释放锁操作</span></span>
<span class="line"><span style="color:#24292E;">        Node h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;    </span><span style="color:#6A737D;">//释放锁成功后，获取新的头结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (h </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> h.waitStatus </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)   </span><span style="color:#6A737D;">//如果新的头结点不为空并且不是刚刚建立的结点（初始状态下status为默认值0，而上面在进行了shouldParkAfterFailedAcquire之后，会被设定为SIGNAL状态，值为-1）</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">unparkSuccessor</span><span style="color:#24292E;">(h);   </span><span style="color:#6A737D;">//唤醒头节点下一个节点中的线程</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">unparkSuccessor</span><span style="color:#E1E4E8;">(Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将等待状态waitStatus设置为初始值0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ws </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.waitStatus;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ws </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">compareAndSetWaitStatus</span><span style="color:#E1E4E8;">(node, ws, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//获取下一个结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> s.waitStatus </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {   </span><span style="color:#6A737D;">//如果下一个结点为空或是等待状态是已取消，那肯定是不能通知unpark的，这时就要遍历所有节点再另外找一个符合unpark要求的节点了</span></span>
<span class="line"><span style="color:#E1E4E8;">        s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Node t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail; t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> node; t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t.prev)   </span><span style="color:#6A737D;">//这里是从队尾向前，因为enq()方法中的t.next = node是在CAS之后进行的，而 node.prev = t 是CAS之前进行的，所以从后往前一定能够保证遍历所有节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t.waitStatus </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)   </span><span style="color:#6A737D;">//要是找到了，就直接unpark，要是还是没找到，那就算了</span></span>
<span class="line"><span style="color:#E1E4E8;">        LockSupport.</span><span style="color:#B392F0;">unpark</span><span style="color:#E1E4E8;">(s.thread);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">unparkSuccessor</span><span style="color:#24292E;">(Node node) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将等待状态waitStatus设置为初始值0</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ws </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.waitStatus;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ws </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">compareAndSetWaitStatus</span><span style="color:#24292E;">(node, ws, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//获取下一个结点</span></span>
<span class="line"><span style="color:#24292E;">    Node s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.next;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> s.waitStatus </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {   </span><span style="color:#6A737D;">//如果下一个结点为空或是等待状态是已取消，那肯定是不能通知unpark的，这时就要遍历所有节点再另外找一个符合unpark要求的节点了</span></span>
<span class="line"><span style="color:#24292E;">        s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Node t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail; t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> node; t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t.prev)   </span><span style="color:#6A737D;">//这里是从队尾向前，因为enq()方法中的t.next = node是在CAS之后进行的，而 node.prev = t 是CAS之前进行的，所以从后往前一定能够保证遍历所有节点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t.waitStatus </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)   </span><span style="color:#6A737D;">//要是找到了，就直接unpark，要是还是没找到，那就算了</span></span>
<span class="line"><span style="color:#24292E;">        LockSupport.</span><span style="color:#6F42C1;">unpark</span><span style="color:#24292E;">(s.thread);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>那么我们来看看<code>tryRelease()</code>方法是怎么实现的，具体实现在Sync中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryRelease</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> releases) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getState</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> releases;   </span><span style="color:#6A737D;">//先计算本次解锁之后的状态值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getExclusiveOwnerThread</span><span style="color:#E1E4E8;">())   </span><span style="color:#6A737D;">//因为是独占锁，那肯定这把锁得是当前线程持有才行</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IllegalMonitorStateException</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//否则直接抛异常</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> free </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {  </span><span style="color:#6A737D;">//如果解锁之后的值为0，表示已经完全释放此锁</span></span>
<span class="line"><span style="color:#E1E4E8;">        free </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">setExclusiveOwnerThread</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">//将独占锁持有线程设置为null</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">setState</span><span style="color:#E1E4E8;">(c);   </span><span style="color:#6A737D;">//状态值设定为c</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> free;  </span><span style="color:#6A737D;">//如果不是0表示此锁还没完全释放，返回false，是0就返回true</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryRelease</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> releases) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getState</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> releases;   </span><span style="color:#6A737D;">//先计算本次解锁之后的状态值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getExclusiveOwnerThread</span><span style="color:#24292E;">())   </span><span style="color:#6A737D;">//因为是独占锁，那肯定这把锁得是当前线程持有才行</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalMonitorStateException</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//否则直接抛异常</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> free </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {  </span><span style="color:#6A737D;">//如果解锁之后的值为0，表示已经完全释放此锁</span></span>
<span class="line"><span style="color:#24292E;">        free </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">setExclusiveOwnerThread</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">//将独占锁持有线程设置为null</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">setState</span><span style="color:#24292E;">(c);   </span><span style="color:#6A737D;">//状态值设定为c</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> free;  </span><span style="color:#6A737D;">//如果不是0表示此锁还没完全释放，返回false，是0就返回true</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>综上，我们来画一个 公平锁 完整的流程图：</p><p><img src="`+w+`" alt="image-20220306141248030"></p><h5 id="公平锁的不公平性" tabindex="-1">公平锁的不公平性 <a class="header-anchor" href="#公平锁的不公平性" aria-label="Permalink to &quot;公平锁的不公平性&quot;">​</a></h5><p><code>tryAcquire()</code>实现：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> acquires) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Thread current </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getState</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">hasQueuedPredecessors</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//注意这里，公平锁的机制是，一开始会查看是否有节点处于等待</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">compareAndSetState</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, acquires)) {   </span><span style="color:#6A737D;">//如果前面的方法执行后发现没有等待节点，就直接进入占锁环节了</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">setExclusiveOwnerThread</span><span style="color:#E1E4E8;">(current);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (current </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getExclusiveOwnerThread</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextc </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> acquires;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nextc </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Maximum lock count exceeded&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">setState</span><span style="color:#E1E4E8;">(nextc);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">ReservedStackAccess</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> acquires) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Thread current </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getState</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">hasQueuedPredecessors</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">   </span><span style="color:#6A737D;">//注意这里，公平锁的机制是，一开始会查看是否有节点处于等待</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">compareAndSetState</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, acquires)) {   </span><span style="color:#6A737D;">//如果前面的方法执行后发现没有等待节点，就直接进入占锁环节了</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">setExclusiveOwnerThread</span><span style="color:#24292E;">(current);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (current </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getExclusiveOwnerThread</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextc </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> acquires;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nextc </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Maximum lock count exceeded&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">setState</span><span style="color:#24292E;">(nextc);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>所以<code>hasQueuedPredecessors()</code>这个环节容不得半点闪失，否则会直接破坏掉公平性，假如现在出现了这样的情况：</p><p>线程1已经持有锁了，这时线程2来争抢这把锁，走到<code>hasQueuedPredecessors()</code>，判断出为 <code>false</code>，线程2继续运行，然后线程2肯定获取锁失败（因为锁这时是被线程1占有的），因此就进入到等待队列中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Node </span><span style="color:#B392F0;">enq</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Node node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Node t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 线程2进来之后，肯定是要先走这里的，因为head和tail都是null</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetHead</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">()))</span></span>
<span class="line"><span style="color:#E1E4E8;">                tail </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;   </span><span style="color:#6A737D;">//这里就将tail直接等于head了，注意这里完了之后还没完，这里只是初始化过程</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            node.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetTail</span><span style="color:#E1E4E8;">(t, node)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                t.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Node </span><span style="color:#B392F0;">addWaiter</span><span style="color:#E1E4E8;">(Node mode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">(), mode);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node pred </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (pred </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {   </span><span style="color:#6A737D;">//由于一开始head和tail都是null，所以线程2直接就进enq()了</span></span>
<span class="line"><span style="color:#E1E4E8;">        node.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pred;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndSetTail</span><span style="color:#E1E4E8;">(pred, node)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            pred.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">enq</span><span style="color:#E1E4E8;">(node);   </span><span style="color:#6A737D;">//请看上面</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Node </span><span style="color:#6F42C1;">enq</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Node node) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {</span></span>
<span class="line"><span style="color:#24292E;">        Node t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 线程2进来之后，肯定是要先走这里的，因为head和tail都是null</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetHead</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">()))</span></span>
<span class="line"><span style="color:#24292E;">                tail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;   </span><span style="color:#6A737D;">//这里就将tail直接等于head了，注意这里完了之后还没完，这里只是初始化过程</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            node.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetTail</span><span style="color:#24292E;">(t, node)) {</span></span>
<span class="line"><span style="color:#24292E;">                t.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Node </span><span style="color:#6F42C1;">addWaiter</span><span style="color:#24292E;">(Node mode) {</span></span>
<span class="line"><span style="color:#24292E;">    Node node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">(), mode);</span></span>
<span class="line"><span style="color:#24292E;">    Node pred </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (pred </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {   </span><span style="color:#6A737D;">//由于一开始head和tail都是null，所以线程2直接就进enq()了</span></span>
<span class="line"><span style="color:#24292E;">        node.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pred;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndSetTail</span><span style="color:#24292E;">(pred, node)) {</span></span>
<span class="line"><span style="color:#24292E;">            pred.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">enq</span><span style="color:#24292E;">(node);   </span><span style="color:#6A737D;">//请看上面</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>而碰巧不巧，这个时候线程3也来抢锁了，按照正常流程走到了<code>hasQueuedPredecessors()</code>方法，而在此方法中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">hasQueuedPredecessors</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail; </span><span style="color:#6A737D;">// Read fields in reverse initialization order</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head;</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node s;</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//这里直接判断h != t，而此时线程2才刚刚执行完 tail = head，所以直接就返回false了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">        ((s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> h.next) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> s.thread </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hasQueuedPredecessors</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    Node t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail; </span><span style="color:#6A737D;">// Read fields in reverse initialization order</span></span>
<span class="line"><span style="color:#24292E;">    Node h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head;</span></span>
<span class="line"><span style="color:#24292E;">    Node s;</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//这里直接判断h != t，而此时线程2才刚刚执行完 tail = head，所以直接就返回false了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">        ((s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> h.next) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> s.thread </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>因此，线程3这时就紧接着准备开始CAS操作了，又碰巧，这时线程1释放锁了，现在的情况就是，线程3直接开始CAS判断，而线程2还在插入节点状态，结果可想而知，居然是线程3先拿到了锁，这显然是违背了公平锁的公平机制。一张图就是：</p><p><img src="`+x+`" alt="image-20220306155509195"></p><p>因此公不公平全看<code>hasQueuedPredecessors()</code>，而此方法只有在等待队列中存在节点时才能保证不会出现问题。所以公平锁，只有在等待队列存在节点时，才是真正公平的。</p><h3 id="线程池" tabindex="-1">线程池 <a class="header-anchor" href="#线程池" aria-label="Permalink to &quot;线程池&quot;">​</a></h3><blockquote><p>将已创建的线程复用，利用池化技术，就像数据库连接池一样，我们也可以创建很多个线程，然后反复地使用这些线程，而不对它们进行销毁。</p></blockquote><h5 id="构造方法" tabindex="-1">构造方法 <a class="header-anchor" href="#构造方法" aria-label="Permalink to &quot;构造方法&quot;">​</a></h5><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> corePoolSize,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> maximumPoolSize,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> keepAliveTime,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          TimeUnit unit,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          BlockingQueue</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Runnable</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> workQueue,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          ThreadFactory threadFactory,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          RejectedExecutionHandler handler) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (corePoolSize </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">        maximumPoolSize </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">        maximumPoolSize </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> corePoolSize </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">        keepAliveTime </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IllegalArgumentException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (workQueue </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> threadFactory </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> handler </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NullPointerException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.acc </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">getSecurityManager</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">            AccessController.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.corePoolSize </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> corePoolSize;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.maximumPoolSize </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> maximumPoolSize;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.workQueue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workQueue;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.keepAliveTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unit.</span><span style="color:#B392F0;">toNanos</span><span style="color:#E1E4E8;">(keepAliveTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.threadFactory </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> threadFactory;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.handler </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> handler;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> corePoolSize,</span></span>
<span class="line"><span style="color:#24292E;">                          </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> maximumPoolSize,</span></span>
<span class="line"><span style="color:#24292E;">                          </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> keepAliveTime,</span></span>
<span class="line"><span style="color:#24292E;">                          TimeUnit unit,</span></span>
<span class="line"><span style="color:#24292E;">                          BlockingQueue</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Runnable</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> workQueue,</span></span>
<span class="line"><span style="color:#24292E;">                          ThreadFactory threadFactory,</span></span>
<span class="line"><span style="color:#24292E;">                          RejectedExecutionHandler handler) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (corePoolSize </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">        maximumPoolSize </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">        maximumPoolSize </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> corePoolSize </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">        keepAliveTime </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalArgumentException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (workQueue </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> threadFactory </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> handler </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NullPointerException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.acc </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> System.</span><span style="color:#6F42C1;">getSecurityManager</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">            AccessController.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.corePoolSize </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> corePoolSize;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.maximumPoolSize </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> maximumPoolSize;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.workQueue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> workQueue;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.keepAliveTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unit.</span><span style="color:#6F42C1;">toNanos</span><span style="color:#24292E;">(keepAliveTime);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.threadFactory </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> threadFactory;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.handler </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> handler;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>参数讲解：</p><ul><li>corePoolSize：<strong>核心线程池大小</strong>，我们每向线程池提交一个多线程任务时，都会创建一个新的<code>核心线程</code>，无论是否存在其他空闲线程，直到到达核心线程池大小为止，之后会尝试复用线程资源。当然也可以在一开始就全部初始化好，调用<code> prestartAllCoreThreads()</code>即可。</li><li>maximumPoolSize：<strong>最大线程池大小</strong>，当目前线程池中所有的线程都处于运行状态，并且这时来了新的多线程任务，如果当前线程池中线程数量小于最大线程池大小，那么会继续创建新的<code>非核心线程</code>运行，直到最大大小。</li><li>keepAliveTime：<strong>线程最大空闲时间</strong>，当一个<code>非核心线程</code>空闲超过一定时间，会自动销毁。</li><li>unit：<strong>线程最大空闲时间的时间单位</strong></li><li>workQueue：<strong>线程等待队列</strong>，当线程池中确实无法分配线程执行任务的时候，就会将任务暂时存到等待队列中，直到有线程资源可用为止，这里可以使用我们上一章学到的阻塞队列。</li><li>threadFactory：<strong>线程创建工厂</strong>，我们可以干涉线程池中线程的创建过程，进行自定义。</li><li>handler：<strong>拒绝策略</strong>，当等待队列和线程池都没有空间了，真的不能再来新的任务时，来了个新的多线程任务，那么只能拒绝了，这时就会根据当前设定的拒绝策略进行处理。</li></ul><p>最为重要的就是线程池大小的限定了，这个也是很有学问的，合理地分配大小会使得线程池的执行效率事半功倍：</p><ul><li>首先我们可以分析一下，线程池执行任务的特性，是CPU 密集型还是 IO 密集型 <ul><li>**CPU密集型：**主要是执行计算任务，响应时间很快，CPU一直在运行，这种任务CPU的利用率很高，那么线程数应该是根据 CPU 核心数来决定，CPU 核心数 = 最大同时执行线程数，以 i5-9400F 处理器为例，CPU 核心数为 6，那么最多就能同时执行 6 个线程。</li><li>**IO密集型：**主要是进行 IO 操作，因为执行 IO 操作的时间比较较长，比如从硬盘读取数据之类的，CPU就得等着IO操作，很容易出现空闲状态，导致 CPU 的利用率不高，这种情况下可以适当增加线程池的大小，让更多的线程可以一起进行IO操作，一般可以配置为CPU核心数的2倍。</li></ul></li></ul><p>手动创建一个新的线程池：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ThreadPoolExecutor executor </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">,   </span><span style="color:#6A737D;">//2个核心线程，最大线程数为4个</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS,        </span><span style="color:#6A737D;">//最大空闲时间为3秒钟</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayBlockingQueue&lt;&gt;(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">));     </span><span style="color:#6A737D;">//这里使用容量为2的ArrayBlockingQueue队列</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {   </span><span style="color:#6A737D;">//开始6个任务</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> finalI </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">        executor.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 开始执行！（&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> finalI);</span></span>
<span class="line"><span style="color:#E1E4E8;">                TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 已结束！（&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">finalI);</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        });</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);    </span><span style="color:#6A737D;">//看看当前线程池中的线程数量</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;线程池中线程数量：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">executor.</span><span style="color:#B392F0;">getPoolSize</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">);     </span><span style="color:#6A737D;">//等到超过空闲时间</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;线程池中线程数量：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">executor.</span><span style="color:#B392F0;">getPoolSize</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">shutdownNow</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//使用完线程池记得关闭，不然程序不会结束，它会取消所有等待中的任务以及试图中断正在执行的任务，关闭后，无法再提交任务，一律拒绝</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//executor.shutdown();     同样可以关闭，但是会执行完等待队列中的任务再关闭</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ThreadPoolExecutor executor </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">,   </span><span style="color:#6A737D;">//2个核心线程，最大线程数为4个</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, TimeUnit.SECONDS,        </span><span style="color:#6A737D;">//最大空闲时间为3秒钟</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayBlockingQueue&lt;&gt;(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">));     </span><span style="color:#6A737D;">//这里使用容量为2的ArrayBlockingQueue队列</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">6</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {   </span><span style="color:#6A737D;">//开始6个任务</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> finalI </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">        executor.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 开始执行！（&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> finalI);</span></span>
<span class="line"><span style="color:#24292E;">                TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 已结束！（&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">finalI);</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        });</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);    </span><span style="color:#6A737D;">//看看当前线程池中的线程数量</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;线程池中线程数量：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">executor.</span><span style="color:#6F42C1;">getPoolSize</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">);     </span><span style="color:#6A737D;">//等到超过空闲时间</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;线程池中线程数量：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">executor.</span><span style="color:#6F42C1;">getPoolSize</span><span style="color:#24292E;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">shutdownNow</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//使用完线程池记得关闭，不然程序不会结束，它会取消所有等待中的任务以及试图中断正在执行的任务，关闭后，无法再提交任务，一律拒绝</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//executor.shutdown();     同样可以关闭，但是会执行完等待队列中的任务再关闭</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>创建了一个核心容量为2，最大容量为4，等待队列长度为2，空闲时间为3秒的线程池，现在我们向其中执行6个任务，每个任务都会进行1秒钟休眠，那么当线程池中4个线程都被占用时，还有两个线程就只能进入到等待队列中了，当线程池中4个线程完成后，等待队列中的两个任务才能开始执行。并且在等待5秒后，超过了线程池的最大空闲时间，<code>非核心线程</code>被回收了，所以线程池中只有2个线程存在。</p><p><strong>当等待队列超过容量，执行拒绝任务，拒绝的操作会根据拒绝策略决定</strong></p><p>线程池的拒绝策略：</p><ul><li>AbortPolicy(默认)：像上面一样，直接抛异常。</li><li>CallerRunsPolicy：直接让提交任务的线程运行这个任务，比如在主线程向线程池提交了任务，那么就直接由主线程执行。</li><li>DiscardOldestPolicy：丢弃队列中最近的一个任务，替换为当前任务。</li><li>DiscardPolicy：什么也不用做。</li></ul><p><code>DiscardOldestPolicy</code></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DiscardOldestPolicy</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RejectedExecutionHandler</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DiscardOldestPolicy</span><span style="color:#E1E4E8;">() { }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">rejectedExecution</span><span style="color:#E1E4E8;">(Runnable </span><span style="color:#FFAB70;">r</span><span style="color:#E1E4E8;">, ThreadPoolExecutor </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">e.</span><span style="color:#B392F0;">isShutdown</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 会先执行一次出队操作</span></span>
<span class="line"><span style="color:#E1E4E8;">            e.</span><span style="color:#B392F0;">getQueue</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">();   </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 这里会再次调用execute方法</span></span>
<span class="line"><span style="color:#E1E4E8;">            e.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(r);     </span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DiscardOldestPolicy</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RejectedExecutionHandler</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DiscardOldestPolicy</span><span style="color:#24292E;">() { }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">rejectedExecution</span><span style="color:#24292E;">(Runnable </span><span style="color:#E36209;">r</span><span style="color:#24292E;">, ThreadPoolExecutor </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">e.</span><span style="color:#6F42C1;">isShutdown</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 会先执行一次出队操作</span></span>
<span class="line"><span style="color:#24292E;">            e.</span><span style="color:#6F42C1;">getQueue</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">();   </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 这里会再次调用execute方法</span></span>
<span class="line"><span style="color:#24292E;">            e.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(r);     </span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>除了使用官方提供的4种策略之外，我们还可以使用自定义的策略：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ThreadPoolExecutor executor </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> SynchronousQueue&lt;&gt;(),</span></span>
<span class="line"><span style="color:#E1E4E8;">                    (r, executor1) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {   </span><span style="color:#6A737D;">//比如这里我们也来实现一个就在当前线程执行的策略</span></span>
<span class="line"><span style="color:#E1E4E8;">                        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;哎呀，线程池和等待队列都满了，你自己耗子尾汁吧&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                        r.</span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//直接运行</span></span>
<span class="line"><span style="color:#E1E4E8;">                    });</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ThreadPoolExecutor executor </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, TimeUnit.SECONDS,</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> SynchronousQueue&lt;&gt;(),</span></span>
<span class="line"><span style="color:#24292E;">                    (r, executor1) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {   </span><span style="color:#6A737D;">//比如这里我们也来实现一个就在当前线程执行的策略</span></span>
<span class="line"><span style="color:#24292E;">                        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;哎呀，线程池和等待队列都满了，你自己耗子尾汁吧&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                        r.</span><span style="color:#6F42C1;">run</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//直接运行</span></span>
<span class="line"><span style="color:#24292E;">                    });</span></span></code></pre></div><p><code>ThreadFactory</code></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ThreadPoolExecutor executor </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> SynchronousQueue&lt;&gt;(),</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadFactory</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> counter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                        @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#6A737D;">// 传入的Runnable对象就是我们提交的任务</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Thread </span><span style="color:#B392F0;">newThread</span><span style="color:#E1E4E8;">(Runnable </span><span style="color:#FFAB70;">r</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(r, </span><span style="color:#9ECBFF;">&quot;我的自定义线程-&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">counter</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                        }</span></span>
<span class="line"><span style="color:#E1E4E8;">                    });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        executor.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 开始执行！&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ThreadPoolExecutor executor </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, TimeUnit.SECONDS,</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> SynchronousQueue&lt;&gt;(),</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadFactory</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> counter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                        @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6A737D;">// 传入的Runnable对象就是我们提交的任务</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Thread </span><span style="color:#6F42C1;">newThread</span><span style="color:#24292E;">(Runnable </span><span style="color:#E36209;">r</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(r, </span><span style="color:#032F62;">&quot;我的自定义线程-&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">counter</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                        }</span></span>
<span class="line"><span style="color:#24292E;">                    });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        executor.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 开始执行！&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h5 id="executors工具类" tabindex="-1"><code>Executors</code>工具类 <a class="header-anchor" href="#executors工具类" aria-label="Permalink to &quot;\`Executors\`工具类&quot;">​</a></h5><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newFixedThreadPool</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//直接创建一个固定容量的线程池</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newFixedThreadPool</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//直接创建一个固定容量的线程池</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>内部实现为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> ExecutorService </span><span style="color:#B392F0;">newFixedThreadPool</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nThreads) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadPoolExecutor</span><span style="color:#E1E4E8;">(nThreads, nThreads,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                  </span><span style="color:#79B8FF;">0L</span><span style="color:#E1E4E8;">, TimeUnit.MILLISECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                  </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedBlockingQueue&lt;</span><span style="color:#F97583;">Runnable</span><span style="color:#E1E4E8;">&gt;());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> ExecutorService </span><span style="color:#6F42C1;">newFixedThreadPool</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nThreads) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadPoolExecutor</span><span style="color:#24292E;">(nThreads, nThreads,</span></span>
<span class="line"><span style="color:#24292E;">                                  </span><span style="color:#005CC5;">0L</span><span style="color:#24292E;">, TimeUnit.MILLISECONDS,</span></span>
<span class="line"><span style="color:#24292E;">                                  </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedBlockingQueue&lt;</span><span style="color:#D73A49;">Runnable</span><span style="color:#24292E;">&gt;());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里直接将最大线程和核心线程数量设定为一样的，并且等待时间为0，因为压根不需要，并且采用的是一个无界的LinkedBlockingQueue作为等待队列。</p><p>使用newSingleThreadExecutor来创建只有一个线程的线程池：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newSingleThreadExecutor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//创建一个只有一个线程的线程池</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newSingleThreadExecutor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//创建一个只有一个线程的线程池</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>原理如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> ExecutorService </span><span style="color:#B392F0;">newSingleThreadExecutor</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> FinalizableDelegatedExecutorService</span></span>
<span class="line"><span style="color:#E1E4E8;">        (</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                </span><span style="color:#79B8FF;">0L</span><span style="color:#E1E4E8;">, TimeUnit.MILLISECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedBlockingQueue&lt;</span><span style="color:#F97583;">Runnable</span><span style="color:#E1E4E8;">&gt;()));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> ExecutorService </span><span style="color:#6F42C1;">newSingleThreadExecutor</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> FinalizableDelegatedExecutorService</span></span>
<span class="line"><span style="color:#24292E;">        (</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                                </span><span style="color:#005CC5;">0L</span><span style="color:#24292E;">, TimeUnit.MILLISECONDS,</span></span>
<span class="line"><span style="color:#24292E;">                                </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedBlockingQueue&lt;</span><span style="color:#D73A49;">Runnable</span><span style="color:#24292E;">&gt;()));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>可以看到这里并不是直接创建的一个ThreadPoolExecutor对象，而是套了一层FinalizableDelegatedExecutorService，那么这个又是什么东西呢？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FinalizableDelegatedExecutorService</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DelegatedExecutorService</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">FinalizableDelegatedExecutorService</span><span style="color:#E1E4E8;">(ExecutorService </span><span style="color:#FFAB70;">executor</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(executor);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">finalize</span><span style="color:#E1E4E8;">() {    </span><span style="color:#6A737D;">//在GC时，会执行finalize方法，此方法中会关闭掉线程池，释放资源</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FinalizableDelegatedExecutorService</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DelegatedExecutorService</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">FinalizableDelegatedExecutorService</span><span style="color:#24292E;">(ExecutorService </span><span style="color:#E36209;">executor</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(executor);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">finalize</span><span style="color:#24292E;">() {    </span><span style="color:#6A737D;">//在GC时，会执行finalize方法，此方法中会关闭掉线程池，释放资源</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DelegatedExecutorService</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractExecutorService</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ExecutorService e;    </span><span style="color:#6A737D;">//被委派对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">DelegatedExecutorService</span><span style="color:#E1E4E8;">(ExecutorService </span><span style="color:#FFAB70;">executor</span><span style="color:#E1E4E8;">) { e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executor; }   </span><span style="color:#6A737D;">//实际上所以的操作都是让委派对象执行的，有点像代理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(Runnable </span><span style="color:#FFAB70;">command</span><span style="color:#E1E4E8;">) { e.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(command); }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">() { e.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">(); }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">Runnable</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">shutdownNow</span><span style="color:#E1E4E8;">() { </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> e.</span><span style="color:#B392F0;">shutdownNow</span><span style="color:#E1E4E8;">(); }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DelegatedExecutorService</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractExecutorService</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ExecutorService e;    </span><span style="color:#6A737D;">//被委派对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">DelegatedExecutorService</span><span style="color:#24292E;">(ExecutorService </span><span style="color:#E36209;">executor</span><span style="color:#24292E;">) { e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executor; }   </span><span style="color:#6A737D;">//实际上所以的操作都是让委派对象执行的，有点像代理</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(Runnable </span><span style="color:#E36209;">command</span><span style="color:#24292E;">) { e.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(command); }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">() { e.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">(); }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> List&lt;</span><span style="color:#D73A49;">Runnable</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">shutdownNow</span><span style="color:#24292E;">() { </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> e.</span><span style="color:#6F42C1;">shutdownNow</span><span style="color:#24292E;">(); }</span></span></code></pre></div><p>所以，下面两种写法的区别在于：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newSingleThreadExecutor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newFixedThreadPool</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newSingleThreadExecutor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newFixedThreadPool</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>前者实际上是被代理了，我们没办法直接修改前者的相关属性，显然使用前者创建只有一个线程的线程池更加专业和安全（可以防止属性被修改）一些。</p><p>最后我们来看<code>newCachedThreadPool</code>方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newCachedThreadPool</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//它是一个会根据需要无限制创建新线程的线程池</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newCachedThreadPool</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//它是一个会根据需要无限制创建新线程的线程池</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>我们来看看它的实现：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> ExecutorService </span><span style="color:#B392F0;">newCachedThreadPool</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, Integer.MAX_VALUE,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                  </span><span style="color:#79B8FF;">60L</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                  </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> SynchronousQueue&lt;</span><span style="color:#F97583;">Runnable</span><span style="color:#E1E4E8;">&gt;());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> ExecutorService </span><span style="color:#6F42C1;">newCachedThreadPool</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, Integer.MAX_VALUE,</span></span>
<span class="line"><span style="color:#24292E;">                                  </span><span style="color:#005CC5;">60L</span><span style="color:#24292E;">, TimeUnit.SECONDS,</span></span>
<span class="line"><span style="color:#24292E;">                                  </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> SynchronousQueue&lt;</span><span style="color:#D73A49;">Runnable</span><span style="color:#24292E;">&gt;());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>可以看到，核心线程数为0，那么也就是说所有的线程都是<code>非核心线程</code>，也就是说线程空闲时间超过1秒钟，一律销毁。但是它的最大容量是<code>Integer.MAX_VALUE</code>，也就是说，它可以无限制地增长下去，所以这玩意一定要慎用。</p><h5 id="执行带返回值的任务" tabindex="-1">执行带返回值的任务 <a class="header-anchor" href="#执行带返回值的任务" aria-label="Permalink to &quot;执行带返回值的任务&quot;">​</a></h5><p><strong>可以使用Future</strong>，它可以返回任务的计算结果，我们可以通过它来获取任务的结果以及任务当前是否完成：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newSingleThreadExecutor</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//直接用Executors创建，方便就完事了</span></span>
<span class="line"><span style="color:#E1E4E8;">    Future&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; future </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executor.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;我是字符串!&quot;</span><span style="color:#E1E4E8;">);     </span><span style="color:#6A737D;">//使用submit提交任务，会返回一个Future对象，注意提交的对象可以是Runable也可以是Callable，这里使用的是Callable能够自定义返回值</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(future.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());    </span><span style="color:#6A737D;">//如果任务未完成，get会被阻塞，任务完成返回Callable执行结果返回值</span></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//结果也可以一开始就定义好，然后等待Runnable执行完之后再返回：</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newSingleThreadExecutor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    Future&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; future </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executor.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }, </span><span style="color:#9ECBFF;">&quot;我是字符串！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(future.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//通过Future对象获取当前任务的一些状态：</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newSingleThreadExecutor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    Future&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; future </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executor.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;都看到这里了，不赏UP主一个一键三连吗？&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(future.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;任务是否执行完成：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">future.</span><span style="color:#B392F0;">isDone</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;任务是否被取消：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">future.</span><span style="color:#B392F0;">isCancelled</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//在任务执行途中取消任务：</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newSingleThreadExecutor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    Future&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; future </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executor.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;这次一定！&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(future.</span><span style="color:#B392F0;">cancel</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(future.</span><span style="color:#B392F0;">isCancelled</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newSingleThreadExecutor</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//直接用Executors创建，方便就完事了</span></span>
<span class="line"><span style="color:#24292E;">    Future&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; future </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executor.</span><span style="color:#6F42C1;">submit</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;我是字符串!&quot;</span><span style="color:#24292E;">);     </span><span style="color:#6A737D;">//使用submit提交任务，会返回一个Future对象，注意提交的对象可以是Runable也可以是Callable，这里使用的是Callable能够自定义返回值</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(future.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());    </span><span style="color:#6A737D;">//如果任务未完成，get会被阻塞，任务完成返回Callable执行结果返回值</span></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//结果也可以一开始就定义好，然后等待Runnable执行完之后再返回：</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newSingleThreadExecutor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    Future&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; future </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executor.</span><span style="color:#6F42C1;">submit</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }, </span><span style="color:#032F62;">&quot;我是字符串！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(future.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//通过Future对象获取当前任务的一些状态：</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newSingleThreadExecutor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    Future&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; future </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executor.</span><span style="color:#6F42C1;">submit</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;都看到这里了，不赏UP主一个一键三连吗？&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(future.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;任务是否执行完成：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">future.</span><span style="color:#6F42C1;">isDone</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;任务是否被取消：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">future.</span><span style="color:#6F42C1;">isCancelled</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//在任务执行途中取消任务：</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newSingleThreadExecutor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    Future&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; future </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executor.</span><span style="color:#6F42C1;">submit</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;这次一定！&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(future.</span><span style="color:#6F42C1;">cancel</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(future.</span><span style="color:#6F42C1;">isCancelled</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>通过传入FutureTask对象</strong>的方式：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService service </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newSingleThreadExecutor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    FutureTask&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; task </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> FutureTask&lt;&gt;(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;我是字符串！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    service.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">(task);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(task.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService service </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newSingleThreadExecutor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    FutureTask&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; task </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> FutureTask&lt;&gt;(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;我是字符串！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    service.</span><span style="color:#6F42C1;">submit</span><span style="color:#24292E;">(task);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(task.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h5 id="执行定时任务" tabindex="-1">执行定时任务 <a class="header-anchor" href="#执行定时任务" aria-label="Permalink to &quot;执行定时任务&quot;">​</a></h5><blockquote><p>JDK5之后，我们可以使用ScheduledThreadPoolExecutor来提交定时任务，它继承自ThreadPoolExecutor，并且所有的构造方法都必须要求最大线程池容量为Integer.MAX_VALUE，并且都是采用的DelayedWorkQueue作为等待队列。</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ScheduledThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> corePoolSize) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(corePoolSize, Integer.MAX_VALUE, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, NANOSECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DelayedWorkQueue</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ScheduledThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> corePoolSize,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                   ThreadFactory threadFactory) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(corePoolSize, Integer.MAX_VALUE, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, NANOSECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DelayedWorkQueue</span><span style="color:#E1E4E8;">(), threadFactory);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ScheduledThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> corePoolSize,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                   RejectedExecutionHandler handler) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(corePoolSize, Integer.MAX_VALUE, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, NANOSECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DelayedWorkQueue</span><span style="color:#E1E4E8;">(), handler);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ScheduledThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> corePoolSize,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                   ThreadFactory threadFactory,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                   RejectedExecutionHandler handler) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(corePoolSize, Integer.MAX_VALUE, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, NANOSECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DelayedWorkQueue</span><span style="color:#E1E4E8;">(), threadFactory, handler);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ScheduledThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> corePoolSize) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(corePoolSize, Integer.MAX_VALUE, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, NANOSECONDS,</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DelayedWorkQueue</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ScheduledThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> corePoolSize,</span></span>
<span class="line"><span style="color:#24292E;">                                   ThreadFactory threadFactory) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(corePoolSize, Integer.MAX_VALUE, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, NANOSECONDS,</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DelayedWorkQueue</span><span style="color:#24292E;">(), threadFactory);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ScheduledThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> corePoolSize,</span></span>
<span class="line"><span style="color:#24292E;">                                   RejectedExecutionHandler handler) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(corePoolSize, Integer.MAX_VALUE, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, NANOSECONDS,</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DelayedWorkQueue</span><span style="color:#24292E;">(), handler);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ScheduledThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> corePoolSize,</span></span>
<span class="line"><span style="color:#24292E;">                                   ThreadFactory threadFactory,</span></span>
<span class="line"><span style="color:#24292E;">                                   RejectedExecutionHandler handler) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(corePoolSize, Integer.MAX_VALUE, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, NANOSECONDS,</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DelayedWorkQueue</span><span style="color:#24292E;">(), threadFactory, handler);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>测试一下它的方法，这个方法可以提交一个延时任务，只有到达指定时间之后才会开始：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//直接设定核心线程数为1</span></span>
<span class="line"><span style="color:#E1E4E8;">    ScheduledThreadPoolExecutor executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ScheduledThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//这里我们计划在3秒后执行</span></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">schedule</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;HelloWorld!&quot;</span><span style="color:#E1E4E8;">), </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//直接设定核心线程数为1</span></span>
<span class="line"><span style="color:#24292E;">    ScheduledThreadPoolExecutor executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ScheduledThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//这里我们计划在3秒后执行</span></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">schedule</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;HelloWorld!&quot;</span><span style="color:#24292E;">), </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, TimeUnit.SECONDS);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>我们也可以像之前一样，传入一个Callable对象，用于接收返回值：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ScheduledThreadPoolExecutor executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ScheduledThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//这里使用ScheduledFuture</span></span>
<span class="line"><span style="color:#E1E4E8;">    ScheduledFuture&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; future </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executor.</span><span style="color:#B392F0;">schedule</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;????&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;任务剩余等待时间：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">future.</span><span style="color:#B392F0;">getDelay</span><span style="color:#E1E4E8;">(TimeUnit.MILLISECONDS) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1000.0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;s&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;任务执行结果：&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">future.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ScheduledThreadPoolExecutor executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ScheduledThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//这里使用ScheduledFuture</span></span>
<span class="line"><span style="color:#24292E;">    ScheduledFuture&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; future </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executor.</span><span style="color:#6F42C1;">schedule</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;????&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, TimeUnit.SECONDS);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;任务剩余等待时间：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">future.</span><span style="color:#6F42C1;">getDelay</span><span style="color:#24292E;">(TimeUnit.MILLISECONDS) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1000.0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;s&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;任务执行结果：&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">future.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>可以看到<code>schedule</code>方法返回了一个ScheduledFuture对象，和Future一样，它也支持返回值的获取、包括对任务的取消同时还支持获取剩余等待时间。</p><p>那么如果我们希望按照一定的频率不断执行任务呢？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ScheduledThreadPoolExecutor executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ScheduledThreadPoolExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    executor.</span><span style="color:#B392F0;">scheduleAtFixedRate</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Hello World!&quot;</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS);</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//三秒钟延迟开始，之后每隔一秒钟执行一次</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ScheduledThreadPoolExecutor executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ScheduledThreadPoolExecutor</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    executor.</span><span style="color:#6F42C1;">scheduleAtFixedRate</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Hello World!&quot;</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, TimeUnit.SECONDS);</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//三秒钟延迟开始，之后每隔一秒钟执行一次</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Executors也为我们预置了newScheduledThreadPool方法用于创建线程池：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ScheduledExecutorService service </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newScheduledThreadPool</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    service.</span><span style="color:#B392F0;">schedule</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Hello World!&quot;</span><span style="color:#E1E4E8;">), </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">    ScheduledExecutorService service </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newScheduledThreadPool</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    service.</span><span style="color:#6F42C1;">schedule</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Hello World!&quot;</span><span style="color:#24292E;">), </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, TimeUnit.SECONDS);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h5 id="线程池实现原理" tabindex="-1">线程池实现原理 <a class="header-anchor" href="#线程池实现原理" aria-label="Permalink to &quot;线程池实现原理&quot;">​</a></h5><h6 id="ctl变量" tabindex="-1">ctl变量 <a class="header-anchor" href="#ctl变量" aria-label="Permalink to &quot;ctl变量&quot;">​</a></h6><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//这个变量比较关键，用到了原子AtomicInteger，用于同时保存线程池运行状态和线程数量（使用原子类是为了保证原子性）</span></span>
<span class="line"><span style="color:#6A737D;">//它是通过拆分32个bit位来保存数据的，前3位保存状态，后29位保存工作线程数量（那要是工作线程数量29位装不下不就GG？）</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> AtomicInteger ctl </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicInteger</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">ctlOf</span><span style="color:#E1E4E8;">(RUNNING, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> COUNT_BITS </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Integer.SIZE </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">;    </span><span style="color:#6A737D;">//29位，线程数量位</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> CAPACITY   </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> COUNT_BITS) </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//计算得出最大容量（1左移29位，最大容量为2的29次方-1）</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 所有的运行状态，注意都是只占用前3位，不会占用后29位</span></span>
<span class="line"><span style="color:#6A737D;">// 接收新任务，并等待执行队列中的任务</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> RUNNING    </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> COUNT_BITS;   </span><span style="color:#6A737D;">//111 | 0000... (后29数量位，下同)</span></span>
<span class="line"><span style="color:#6A737D;">// 不接收新任务，但是依然等待执行队列中的任务</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> SHUTDOWN   </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> COUNT_BITS;   </span><span style="color:#6A737D;">//000 | 数量位</span></span>
<span class="line"><span style="color:#6A737D;">// 不接收新任务，也不执行队列中的任务，并且还要中断正在执行中的任务</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> STOP       </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> COUNT_BITS;   </span><span style="color:#6A737D;">//001 | 数量位</span></span>
<span class="line"><span style="color:#6A737D;">// 所有的任务都已结束，线程数量为0，即将完全关闭</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> TIDYING    </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> COUNT_BITS;   </span><span style="color:#6A737D;">//010 | 数量位</span></span>
<span class="line"><span style="color:#6A737D;">// 完全关闭</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> TERMINATED </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> COUNT_BITS;   </span><span style="color:#6A737D;">//011 | 数量位</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 封装和解析ctl变量的一些方法</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runStateOf</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c)     { </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">~</span><span style="color:#E1E4E8;">CAPACITY; }   </span><span style="color:#6A737D;">//对CAPACITY取反就是后29位全部为0，前三位全部为1，接着与c进行与运算，这样就可以只得到前三位的结果了，所以这里是取运行状态</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">workerCountOf</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c)  { </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> CAPACITY; }</span></span>
<span class="line"><span style="color:#6A737D;">//同上，这里是为了得到后29位的结果，所以这里是取线程数量</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ctlOf</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> rs, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> wc) { </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> rs </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> wc; }   </span></span>
<span class="line"><span style="color:#6A737D;">// 比如上面的RUNNING, 0，进行与运算之后：</span></span>
<span class="line"><span style="color:#6A737D;">// 111 | 0000000000000000000000000</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//这个变量比较关键，用到了原子AtomicInteger，用于同时保存线程池运行状态和线程数量（使用原子类是为了保证原子性）</span></span>
<span class="line"><span style="color:#6A737D;">//它是通过拆分32个bit位来保存数据的，前3位保存状态，后29位保存工作线程数量（那要是工作线程数量29位装不下不就GG？）</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> AtomicInteger ctl </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicInteger</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">ctlOf</span><span style="color:#24292E;">(RUNNING, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> COUNT_BITS </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.SIZE </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">;    </span><span style="color:#6A737D;">//29位，线程数量位</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> CAPACITY   </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> COUNT_BITS) </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//计算得出最大容量（1左移29位，最大容量为2的29次方-1）</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 所有的运行状态，注意都是只占用前3位，不会占用后29位</span></span>
<span class="line"><span style="color:#6A737D;">// 接收新任务，并等待执行队列中的任务</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> RUNNING    </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> COUNT_BITS;   </span><span style="color:#6A737D;">//111 | 0000... (后29数量位，下同)</span></span>
<span class="line"><span style="color:#6A737D;">// 不接收新任务，但是依然等待执行队列中的任务</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> SHUTDOWN   </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> COUNT_BITS;   </span><span style="color:#6A737D;">//000 | 数量位</span></span>
<span class="line"><span style="color:#6A737D;">// 不接收新任务，也不执行队列中的任务，并且还要中断正在执行中的任务</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> STOP       </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> COUNT_BITS;   </span><span style="color:#6A737D;">//001 | 数量位</span></span>
<span class="line"><span style="color:#6A737D;">// 所有的任务都已结束，线程数量为0，即将完全关闭</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> TIDYING    </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> COUNT_BITS;   </span><span style="color:#6A737D;">//010 | 数量位</span></span>
<span class="line"><span style="color:#6A737D;">// 完全关闭</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> TERMINATED </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  </span><span style="color:#005CC5;">3</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> COUNT_BITS;   </span><span style="color:#6A737D;">//011 | 数量位</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 封装和解析ctl变量的一些方法</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runStateOf</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c)     { </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">~</span><span style="color:#24292E;">CAPACITY; }   </span><span style="color:#6A737D;">//对CAPACITY取反就是后29位全部为0，前三位全部为1，接着与c进行与运算，这样就可以只得到前三位的结果了，所以这里是取运行状态</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">workerCountOf</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c)  { </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> CAPACITY; }</span></span>
<span class="line"><span style="color:#6A737D;">//同上，这里是为了得到后29位的结果，所以这里是取线程数量</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ctlOf</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> rs, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> wc) { </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> rs </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> wc; }   </span></span>
<span class="line"><span style="color:#6A737D;">// 比如上面的RUNNING, 0，进行与运算之后：</span></span>
<span class="line"><span style="color:#6A737D;">// 111 | 0000000000000000000000000</span></span></code></pre></div><p><img src="`+q+`" alt="image-20220406112223538"></p><p>在调用<code>execute</code>方法之后，线程池会做些什么：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//这个就是我们指定的阻塞队列</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> BlockingQueue&lt;</span><span style="color:#F97583;">Runnable</span><span style="color:#E1E4E8;">&gt; workQueue;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//再次提醒，这里没加锁！！该有什么意识不用我说了吧，所以说ctl才会使用原子类。</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(Runnable command) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (command </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NullPointerException</span><span style="color:#E1E4E8;">();     </span><span style="color:#6A737D;">//如果任务为null，那执行个寂寞，所以说直接空指针</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();      </span><span style="color:#6A737D;">//获取ctl的值，一会要读取信息的</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">workerCountOf</span><span style="color:#E1E4E8;">(c) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> corePoolSize) {   </span><span style="color:#6A737D;">//判断工作线程数量是否小于核心线程数</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">addWorker</span><span style="color:#E1E4E8;">(command, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">))    </span><span style="color:#6A737D;">//如果是，那不管三七二十一，直接加新的线程执行，然后返回即可</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//如果线程添加失败（有可能其他线程也在对线程池进行操作），那就更新一下c的值</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isRunning</span><span style="color:#E1E4E8;">(c) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> workQueue.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(command)) {   </span><span style="color:#6A737D;">//继续判断，如果当前线程池是运行状态，那就尝试向阻塞队列中添加一个新的等待任务</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> recheck </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//再次获取ctl的值</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isRunning</span><span style="color:#E1E4E8;">(recheck) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(command))   </span><span style="color:#6A737D;">//这里是再次确认当前线程池是否关闭，如果添加等待任务后线程池关闭了，那就把刚刚加进去任务的又拿出来</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">reject</span><span style="color:#E1E4E8;">(command);   </span><span style="color:#6A737D;">//然后直接拒绝当前任务的提交（会根据我们的拒绝策略决定如何进行拒绝操作）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">workerCountOf</span><span style="color:#E1E4E8;">(recheck) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)   </span><span style="color:#6A737D;">//如果这个时候线程池依然在运行状态，那么就检查一下当前工作线程数是否为0，如果是那就直接添加新线程执行</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">addWorker</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//添加一个新的非核心线程</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//其他情况就啥也不用做了</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">addWorker</span><span style="color:#E1E4E8;">(command, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">))   </span><span style="color:#6A737D;">//这种情况要么就是线程池没有运行，要么就是队列满了，这里再尝试添加一个非核心线程碰碰运气</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">reject</span><span style="color:#E1E4E8;">(command);   </span><span style="color:#6A737D;">//要是实在不行就拒绝</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//这个就是我们指定的阻塞队列</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> BlockingQueue&lt;</span><span style="color:#D73A49;">Runnable</span><span style="color:#24292E;">&gt; workQueue;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//再次提醒，这里没加锁！！该有什么意识不用我说了吧，所以说ctl才会使用原子类。</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(Runnable command) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (command </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NullPointerException</span><span style="color:#24292E;">();     </span><span style="color:#6A737D;">//如果任务为null，那执行个寂寞，所以说直接空指针</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();      </span><span style="color:#6A737D;">//获取ctl的值，一会要读取信息的</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">workerCountOf</span><span style="color:#24292E;">(c) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> corePoolSize) {   </span><span style="color:#6A737D;">//判断工作线程数量是否小于核心线程数</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">addWorker</span><span style="color:#24292E;">(command, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">))    </span><span style="color:#6A737D;">//如果是，那不管三七二十一，直接加新的线程执行，然后返回即可</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//如果线程添加失败（有可能其他线程也在对线程池进行操作），那就更新一下c的值</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isRunning</span><span style="color:#24292E;">(c) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> workQueue.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(command)) {   </span><span style="color:#6A737D;">//继续判断，如果当前线程池是运行状态，那就尝试向阻塞队列中添加一个新的等待任务</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> recheck </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//再次获取ctl的值</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isRunning</span><span style="color:#24292E;">(recheck) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(command))   </span><span style="color:#6A737D;">//这里是再次确认当前线程池是否关闭，如果添加等待任务后线程池关闭了，那就把刚刚加进去任务的又拿出来</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">reject</span><span style="color:#24292E;">(command);   </span><span style="color:#6A737D;">//然后直接拒绝当前任务的提交（会根据我们的拒绝策略决定如何进行拒绝操作）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">workerCountOf</span><span style="color:#24292E;">(recheck) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)   </span><span style="color:#6A737D;">//如果这个时候线程池依然在运行状态，那么就检查一下当前工作线程数是否为0，如果是那就直接添加新线程执行</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">addWorker</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//添加一个新的非核心线程</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//其他情况就啥也不用做了</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">addWorker</span><span style="color:#24292E;">(command, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">))   </span><span style="color:#6A737D;">//这种情况要么就是线程池没有运行，要么就是队列满了，这里再尝试添加一个非核心线程碰碰运气</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">reject</span><span style="color:#24292E;">(command);   </span><span style="color:#6A737D;">//要是实在不行就拒绝</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>addWorker</code>是怎么创建和执行任务的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">addWorker</span><span style="color:#E1E4E8;">(Runnable firstTask, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> core) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//这里给最外层循环打了个标签，方便一会的跳转操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    retry</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {    </span><span style="color:#6A737D;">//无限循环，老套路了，注意这里全程没加锁</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();     </span><span style="color:#6A737D;">//获取ctl值</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> rs </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runStateOf</span><span style="color:#E1E4E8;">(c);    </span><span style="color:#6A737D;">//解析当前的运行状态</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// Check if queue empty only if necessary.</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (rs </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> SHUTDOWN </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//判断线程池是否不是处于运行状态</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;"> (rs </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> SHUTDOWN </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//如果不是运行状态，判断线程是SHUTDOWN状态并、任务不为null、等待队列不为空，只要有其中一者不满足，直接返回false，添加失败</span></span>
<span class="line"><span style="color:#E1E4E8;">               firstTask </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">   </span></span>
<span class="line"><span style="color:#E1E4E8;">               </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;"> workQueue.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()))</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {   </span><span style="color:#6A737D;">//内层又一轮无限循环，这个循环是为了将线程计数增加，然后才可以真正地添加一个新的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> wc </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">workerCountOf</span><span style="color:#E1E4E8;">(c);    </span><span style="color:#6A737D;">//解析当前的工作线程数量</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (wc </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> CAPACITY </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">                wc </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> (core </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> corePoolSize </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> maximumPoolSize))    </span><span style="color:#6A737D;">//判断一下还装得下不，如果装得下，看看是核心线程还是非核心线程，如果是核心线程，不能大于核心线程数的限制，如果是非核心线程，不能大于最大线程数限制</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndIncrementWorkerCount</span><span style="color:#E1E4E8;">(c))    </span><span style="color:#6A737D;">//CAS自增线程计数，如果增加成功，任务完成，直接跳出继续</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;"> retry;    </span><span style="color:#6A737D;">//注意这里要直接跳出最外层循环，所以用到了标签（类似于goto语句）</span></span>
<span class="line"><span style="color:#E1E4E8;">            c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 如果CAS失败，更新一下c的值</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">runStateOf</span><span style="color:#E1E4E8;">(c) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> rs)    </span><span style="color:#6A737D;">//如果CAS失败的原因是因为线程池状态和一开始的不一样了，那么就重新从外层循环再来一次</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;"> retry;    </span><span style="color:#6A737D;">//注意这里要直接从最外层循环继续，所以用到了标签（类似于goto语句）</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果是其他原因导致的CAS失败，那只可能是其他线程同时在自增，所以重新再来一次内层循环</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">//好了，线程计数自增也完了，接着就是添加新的工作线程了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> workerStarted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//工作线程是否已启动</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> workerAdded </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;    </span><span style="color:#6A737D;">//工作线程是否已添加</span></span>
<span class="line"><span style="color:#E1E4E8;">    Worker w </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;     </span><span style="color:#6A737D;">//暂时理解为工作线程，别急，我们之后会解读Worker类</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        w </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Worker</span><span style="color:#E1E4E8;">(firstTask);     </span><span style="color:#6A737D;">//创建新的工作线程，传入我们提交的任务</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Thread t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> w.thread;    </span><span style="color:#6A737D;">//拿到工作线程中封装的Thread对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {      </span><span style="color:#6A737D;">//如果线程不为null，那就可以安排干活了</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock mainLock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.mainLock;      </span><span style="color:#6A737D;">//又是ReentrantLock加锁环节，这里开始就是只有一个线程能进入了</span></span>
<span class="line"><span style="color:#E1E4E8;">            mainLock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// Recheck while holding lock.</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// Back out on ThreadFactory failure or if</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// shut down before lock acquired.</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> rs </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runStateOf</span><span style="color:#E1E4E8;">(ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());    </span><span style="color:#6A737D;">//获取当前线程的运行状态</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (rs </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> SHUTDOWN </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">                    (rs </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> SHUTDOWN </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> firstTask </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)) {    </span><span style="color:#6A737D;">//只有当前线程池是正在运行状态，或是SHUTDOWN状态且firstTask为空，那么就继续</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t.</span><span style="color:#B392F0;">isAlive</span><span style="color:#E1E4E8;">()) </span><span style="color:#6A737D;">// 检查一下线程是否正在运行状态</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IllegalThreadStateException</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//如果是那肯定是不能运行我们的任务的</span></span>
<span class="line"><span style="color:#E1E4E8;">                    workers.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(w);    </span><span style="color:#6A737D;">//直接将新创建的Work丢进 workers 集合中</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workers.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//看看当前workers的大小</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> largestPoolSize)   </span><span style="color:#6A737D;">//这里是记录线程池运行以来，历史上的最多线程数</span></span>
<span class="line"><span style="color:#E1E4E8;">                        largestPoolSize </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    workerAdded </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//工作线程已添加</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                mainLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//解锁</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (workerAdded) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                t.</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//启动线程</span></span>
<span class="line"><span style="color:#E1E4E8;">                workerStarted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">//工作线程已启动</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;"> workerStarted)    </span><span style="color:#6A737D;">//如果线程在上面的启动过程中失败了</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">addWorkerFailed</span><span style="color:#E1E4E8;">(w);    </span><span style="color:#6A737D;">//将w移出workers并将计数器-1，最后如果线程池是终止状态，会尝试加速终止线程池</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> workerStarted;   </span><span style="color:#6A737D;">//返回是否成功</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addWorker</span><span style="color:#24292E;">(Runnable firstTask, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> core) {</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//这里给最外层循环打了个标签，方便一会的跳转操作</span></span>
<span class="line"><span style="color:#24292E;">    retry</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {    </span><span style="color:#6A737D;">//无限循环，老套路了，注意这里全程没加锁</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();     </span><span style="color:#6A737D;">//获取ctl值</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> rs </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runStateOf</span><span style="color:#24292E;">(c);    </span><span style="color:#6A737D;">//解析当前的运行状态</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// Check if queue empty only if necessary.</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (rs </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> SHUTDOWN </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">   </span><span style="color:#6A737D;">//判断线程池是否不是处于运行状态</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">!</span><span style="color:#24292E;"> (rs </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> SHUTDOWN </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">   </span><span style="color:#6A737D;">//如果不是运行状态，判断线程是SHUTDOWN状态并、任务不为null、等待队列不为空，只要有其中一者不满足，直接返回false，添加失败</span></span>
<span class="line"><span style="color:#24292E;">               firstTask </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">   </span></span>
<span class="line"><span style="color:#24292E;">               </span><span style="color:#D73A49;">!</span><span style="color:#24292E;"> workQueue.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()))</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {   </span><span style="color:#6A737D;">//内层又一轮无限循环，这个循环是为了将线程计数增加，然后才可以真正地添加一个新的线程</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> wc </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">workerCountOf</span><span style="color:#24292E;">(c);    </span><span style="color:#6A737D;">//解析当前的工作线程数量</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (wc </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> CAPACITY </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">                wc </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> (core </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> corePoolSize </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> maximumPoolSize))    </span><span style="color:#6A737D;">//判断一下还装得下不，如果装得下，看看是核心线程还是非核心线程，如果是核心线程，不能大于核心线程数的限制，如果是非核心线程，不能大于最大线程数限制</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndIncrementWorkerCount</span><span style="color:#24292E;">(c))    </span><span style="color:#6A737D;">//CAS自增线程计数，如果增加成功，任务完成，直接跳出继续</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">break</span><span style="color:#24292E;"> retry;    </span><span style="color:#6A737D;">//注意这里要直接跳出最外层循环，所以用到了标签（类似于goto语句）</span></span>
<span class="line"><span style="color:#24292E;">            c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();  </span><span style="color:#6A737D;">// 如果CAS失败，更新一下c的值</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">runStateOf</span><span style="color:#24292E;">(c) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> rs)    </span><span style="color:#6A737D;">//如果CAS失败的原因是因为线程池状态和一开始的不一样了，那么就重新从外层循环再来一次</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;"> retry;    </span><span style="color:#6A737D;">//注意这里要直接从最外层循环继续，所以用到了标签（类似于goto语句）</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果是其他原因导致的CAS失败，那只可能是其他线程同时在自增，所以重新再来一次内层循环</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">//好了，线程计数自增也完了，接着就是添加新的工作线程了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> workerStarted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//工作线程是否已启动</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> workerAdded </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;    </span><span style="color:#6A737D;">//工作线程是否已添加</span></span>
<span class="line"><span style="color:#24292E;">    Worker w </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;     </span><span style="color:#6A737D;">//暂时理解为工作线程，别急，我们之后会解读Worker类</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        w </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Worker</span><span style="color:#24292E;">(firstTask);     </span><span style="color:#6A737D;">//创建新的工作线程，传入我们提交的任务</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Thread t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> w.thread;    </span><span style="color:#6A737D;">//拿到工作线程中封装的Thread对象</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {      </span><span style="color:#6A737D;">//如果线程不为null，那就可以安排干活了</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock mainLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.mainLock;      </span><span style="color:#6A737D;">//又是ReentrantLock加锁环节，这里开始就是只有一个线程能进入了</span></span>
<span class="line"><span style="color:#24292E;">            mainLock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// Recheck while holding lock.</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// Back out on ThreadFactory failure or if</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// shut down before lock acquired.</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> rs </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runStateOf</span><span style="color:#24292E;">(ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());    </span><span style="color:#6A737D;">//获取当前线程的运行状态</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (rs </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> SHUTDOWN </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">                    (rs </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> SHUTDOWN </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> firstTask </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)) {    </span><span style="color:#6A737D;">//只有当前线程池是正在运行状态，或是SHUTDOWN状态且firstTask为空，那么就继续</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t.</span><span style="color:#6F42C1;">isAlive</span><span style="color:#24292E;">()) </span><span style="color:#6A737D;">// 检查一下线程是否正在运行状态</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalThreadStateException</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//如果是那肯定是不能运行我们的任务的</span></span>
<span class="line"><span style="color:#24292E;">                    workers.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(w);    </span><span style="color:#6A737D;">//直接将新创建的Work丢进 workers 集合中</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> workers.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//看看当前workers的大小</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> largestPoolSize)   </span><span style="color:#6A737D;">//这里是记录线程池运行以来，历史上的最多线程数</span></span>
<span class="line"><span style="color:#24292E;">                        largestPoolSize </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s;</span></span>
<span class="line"><span style="color:#24292E;">                    workerAdded </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//工作线程已添加</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                mainLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//解锁</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (workerAdded) {</span></span>
<span class="line"><span style="color:#24292E;">                t.</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//启动线程</span></span>
<span class="line"><span style="color:#24292E;">                workerStarted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;  </span><span style="color:#6A737D;">//工作线程已启动</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;"> workerStarted)    </span><span style="color:#6A737D;">//如果线程在上面的启动过程中失败了</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">addWorkerFailed</span><span style="color:#24292E;">(w);    </span><span style="color:#6A737D;">//将w移出workers并将计数器-1，最后如果线程池是终止状态，会尝试加速终止线程池</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> workerStarted;   </span><span style="color:#6A737D;">//返回是否成功</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Worker类是如何实现的，它继承自AbstractQueuedSynchronizer，时隔两章，居然再次遇到AQS，那也就是说，它本身就是一把锁：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Worker</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractQueuedSynchronizer</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Runnable</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//用来干活的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Thread thread;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//要执行的第一个任务，构造时就确定了的</span></span>
<span class="line"><span style="color:#E1E4E8;">    Runnable firstTask;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//干活数量计数器，也就是这个线程完成了多少个任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> completedTasks;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">Worker</span><span style="color:#E1E4E8;">(Runnable </span><span style="color:#FFAB70;">firstTask</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">setState</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 执行Task之前不让中断，将AQS的state设定为-1</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.firstTask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> firstTask;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.thread </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getThreadFactory</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">newThread</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//通过预定义或是我们自定义的线程工厂创建线程</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">runWorker</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">//真正开始干活，包括当前活干完了又要等新的活来，就从这里开始，一会详细介绍</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   	</span><span style="color:#6A737D;">//0就是没加锁，1就是已加锁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isHeldExclusively</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getState</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    ...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Worker</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractQueuedSynchronizer</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Runnable</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//用来干活的线程</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Thread thread;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//要执行的第一个任务，构造时就确定了的</span></span>
<span class="line"><span style="color:#24292E;">    Runnable firstTask;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//干活数量计数器，也就是这个线程完成了多少个任务</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> completedTasks;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">Worker</span><span style="color:#24292E;">(Runnable </span><span style="color:#E36209;">firstTask</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">setState</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 执行Task之前不让中断，将AQS的state设定为-1</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.firstTask </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> firstTask;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.thread </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getThreadFactory</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">newThread</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//通过预定义或是我们自定义的线程工厂创建线程</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">run</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">runWorker</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">//真正开始干活，包括当前活干完了又要等新的活来，就从这里开始，一会详细介绍</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   	</span><span style="color:#6A737D;">//0就是没加锁，1就是已加锁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isHeldExclusively</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getState</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    ...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Worker到底是怎么在进行任务的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runWorker</span><span style="color:#E1E4E8;">(Worker w) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Thread wt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//获取当前线程</span></span>
<span class="line"><span style="color:#E1E4E8;">    Runnable task </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> w.firstTask;    </span><span style="color:#6A737D;">//取出要执行的任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    w.firstTask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//然后把Worker中的任务设定为null</span></span>
<span class="line"><span style="color:#E1E4E8;">    w.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 因为一开始为-1，这里是通过unlock操作将其修改回0，只有state大于等于0才能响应中断</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> completedAbruptly </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//只要任务不为null，或是任务为空但是可以从等待队列中取出任务不为空，那么就开始执行这个任务，注意这里是无限循环，也就是说如果当前没有任务了，那么会在getTask方法中卡住，因为要从阻塞队列中等着取任务</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (task </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (task </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getTask</span><span style="color:#E1E4E8;">()) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            w.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//对当前Worker加锁，这里其实并不是防其他线程，而是在shutdown时保护此任务的运行</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">//由于线程池在STOP状态及以上会禁止新线程加入并且中断正在进行的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((</span><span style="color:#B392F0;">runStateAtLeast</span><span style="color:#E1E4E8;">(ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(), STOP) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//只要线程池是STOP及以上的状态，那肯定是不能开始新任务的</span></span>
<span class="line"><span style="color:#E1E4E8;">                 (Thread.</span><span style="color:#B392F0;">interrupted</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">    					 </span><span style="color:#6A737D;">//线程是否已经被打上中断标记并且线程一定是STOP及以上</span></span>
<span class="line"><span style="color:#E1E4E8;">                  </span><span style="color:#B392F0;">runStateAtLeast</span><span style="color:#E1E4E8;">(ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(), STOP))) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">wt.</span><span style="color:#B392F0;">isInterrupted</span><span style="color:#E1E4E8;">())   </span><span style="color:#6A737D;">//再次确保线程被没有打上中断标记</span></span>
<span class="line"><span style="color:#E1E4E8;">                wt.</span><span style="color:#B392F0;">interrupt</span><span style="color:#E1E4E8;">();     </span><span style="color:#6A737D;">//打中断标记</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">beforeExecute</span><span style="color:#E1E4E8;">(wt, task);  </span><span style="color:#6A737D;">//开始之前的准备工作，这里暂时没有实现</span></span>
<span class="line"><span style="color:#E1E4E8;">                Throwable thrown </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    task.</span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//OK，开始执行任务</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (RuntimeException </span><span style="color:#FFAB70;">x</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    thrown </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> x; </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> x;</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Error </span><span style="color:#FFAB70;">x</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    thrown </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> x; </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> x;</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">x</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    thrown </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> x; </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(x);</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">afterExecute</span><span style="color:#E1E4E8;">(task, thrown);    </span><span style="color:#6A737D;">//执行之后的工作，也没实现</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                task </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;    </span><span style="color:#6A737D;">//任务已完成，不需要了</span></span>
<span class="line"><span style="color:#E1E4E8;">                w.completedTasks</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//任务完成数++</span></span>
<span class="line"><span style="color:#E1E4E8;">                w.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//解锁</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        completedAbruptly </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//如果能走到这一步，那说明上面的循环肯定是跳出了，也就是说这个Worker可以丢弃了</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//所以这里会直接将 Worker 从 workers 里删除掉</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">processWorkerExit</span><span style="color:#E1E4E8;">(w, completedAbruptly);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runWorker</span><span style="color:#24292E;">(Worker w) {</span></span>
<span class="line"><span style="color:#24292E;">    Thread wt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//获取当前线程</span></span>
<span class="line"><span style="color:#24292E;">    Runnable task </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> w.firstTask;    </span><span style="color:#6A737D;">//取出要执行的任务</span></span>
<span class="line"><span style="color:#24292E;">    w.firstTask </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//然后把Worker中的任务设定为null</span></span>
<span class="line"><span style="color:#24292E;">    w.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 因为一开始为-1，这里是通过unlock操作将其修改回0，只有state大于等于0才能响应中断</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> completedAbruptly </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//只要任务不为null，或是任务为空但是可以从等待队列中取出任务不为空，那么就开始执行这个任务，注意这里是无限循环，也就是说如果当前没有任务了，那么会在getTask方法中卡住，因为要从阻塞队列中等着取任务</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (task </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (task </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getTask</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            w.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//对当前Worker加锁，这里其实并不是防其他线程，而是在shutdown时保护此任务的运行</span></span>
<span class="line"><span style="color:#24292E;">            </span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">//由于线程池在STOP状态及以上会禁止新线程加入并且中断正在进行的线程</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((</span><span style="color:#6F42C1;">runStateAtLeast</span><span style="color:#24292E;">(ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(), STOP) </span><span style="color:#D73A49;">||</span><span style="color:#24292E;">   </span><span style="color:#6A737D;">//只要线程池是STOP及以上的状态，那肯定是不能开始新任务的</span></span>
<span class="line"><span style="color:#24292E;">                 (Thread.</span><span style="color:#6F42C1;">interrupted</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">    					 </span><span style="color:#6A737D;">//线程是否已经被打上中断标记并且线程一定是STOP及以上</span></span>
<span class="line"><span style="color:#24292E;">                  </span><span style="color:#6F42C1;">runStateAtLeast</span><span style="color:#24292E;">(ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(), STOP))) </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">wt.</span><span style="color:#6F42C1;">isInterrupted</span><span style="color:#24292E;">())   </span><span style="color:#6A737D;">//再次确保线程被没有打上中断标记</span></span>
<span class="line"><span style="color:#24292E;">                wt.</span><span style="color:#6F42C1;">interrupt</span><span style="color:#24292E;">();     </span><span style="color:#6A737D;">//打中断标记</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">beforeExecute</span><span style="color:#24292E;">(wt, task);  </span><span style="color:#6A737D;">//开始之前的准备工作，这里暂时没有实现</span></span>
<span class="line"><span style="color:#24292E;">                Throwable thrown </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    task.</span><span style="color:#6F42C1;">run</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//OK，开始执行任务</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (RuntimeException </span><span style="color:#E36209;">x</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    thrown </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x; </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Error </span><span style="color:#E36209;">x</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    thrown </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x; </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">x</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    thrown </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x; </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(x);</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">afterExecute</span><span style="color:#24292E;">(task, thrown);    </span><span style="color:#6A737D;">//执行之后的工作，也没实现</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                task </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;    </span><span style="color:#6A737D;">//任务已完成，不需要了</span></span>
<span class="line"><span style="color:#24292E;">                w.completedTasks</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//任务完成数++</span></span>
<span class="line"><span style="color:#24292E;">                w.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//解锁</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        completedAbruptly </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//如果能走到这一步，那说明上面的循环肯定是跳出了，也就是说这个Worker可以丢弃了</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//所以这里会直接将 Worker 从 workers 里删除掉</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">processWorkerExit</span><span style="color:#24292E;">(w, completedAbruptly);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>它是怎么从阻塞队列里面获取任务的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Runnable </span><span style="color:#B392F0;">getTask</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> timedOut </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// Did the last poll() time out?</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {    </span><span style="color:#6A737D;">//无限循环获取</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//获取ctl </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> rs </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runStateOf</span><span style="color:#E1E4E8;">(c);      </span><span style="color:#6A737D;">//解析线程池运行状态</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// Check if queue empty only if necessary.</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (rs </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> SHUTDOWN </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (rs </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> STOP </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> workQueue.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">())) {      </span><span style="color:#6A737D;">//判断是不是没有必要再执行等待队列中的任务了，也就是处于关闭线程池的状态了</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">decrementWorkerCount</span><span style="color:#E1E4E8;">();     </span><span style="color:#6A737D;">//直接减少一个工作线程数量</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;    </span><span style="color:#6A737D;">//返回null，这样上面的runWorker就直接结束了，下同</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> wc </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">workerCountOf</span><span style="color:#E1E4E8;">(c);   </span><span style="color:#6A737D;">//如果线程池运行正常，那就获取当前的工作线程数量</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// Are workers subject to culling?</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> timed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> allowCoreThreadTimeOut </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> wc </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> corePoolSize;   </span><span style="color:#6A737D;">//如果线程数大于核心线程数或是允许核心线程等待超时，那么就标记为可超时的</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//超时或maximumPoolSize在运行期间被修改了，并且线程数大于1或等待队列为空，那也是不能获取到任务的</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((wc </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> maximumPoolSize </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (timed </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> timedOut))</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (wc </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> workQueue.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">compareAndDecrementWorkerCount</span><span style="color:#E1E4E8;">(c))   </span><span style="color:#6A737D;">//如果CAS减少工作线程成功</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;    </span><span style="color:#6A737D;">//返回null</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//否则开下一轮循环</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            Runnable r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> timed </span><span style="color:#F97583;">?</span></span>
<span class="line"><span style="color:#E1E4E8;">                workQueue.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">(keepAliveTime, TimeUnit.NANOSECONDS) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//如果可超时，那么最多等到超时时间</span></span>
<span class="line"><span style="color:#E1E4E8;">                workQueue.</span><span style="color:#B392F0;">take</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//如果不可超时，那就一直等着拿任务</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (r </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)    </span><span style="color:#6A737D;">//如果成功拿到任务，ok，返回</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> r;</span></span>
<span class="line"><span style="color:#E1E4E8;">            timedOut </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//否则就是超时了，下一轮循环将直接返回null</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">retry</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            timedOut </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//开下一轮循环吧</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Runnable </span><span style="color:#6F42C1;">getTask</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> timedOut </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// Did the last poll() time out?</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {    </span><span style="color:#6A737D;">//无限循环获取</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//获取ctl </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> rs </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runStateOf</span><span style="color:#24292E;">(c);      </span><span style="color:#6A737D;">//解析线程池运行状态</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// Check if queue empty only if necessary.</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (rs </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> SHUTDOWN </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (rs </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> STOP </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> workQueue.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">())) {      </span><span style="color:#6A737D;">//判断是不是没有必要再执行等待队列中的任务了，也就是处于关闭线程池的状态了</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">decrementWorkerCount</span><span style="color:#24292E;">();     </span><span style="color:#6A737D;">//直接减少一个工作线程数量</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;    </span><span style="color:#6A737D;">//返回null，这样上面的runWorker就直接结束了，下同</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> wc </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">workerCountOf</span><span style="color:#24292E;">(c);   </span><span style="color:#6A737D;">//如果线程池运行正常，那就获取当前的工作线程数量</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// Are workers subject to culling?</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> timed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> allowCoreThreadTimeOut </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> wc </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> corePoolSize;   </span><span style="color:#6A737D;">//如果线程数大于核心线程数或是允许核心线程等待超时，那么就标记为可超时的</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//超时或maximumPoolSize在运行期间被修改了，并且线程数大于1或等待队列为空，那也是不能获取到任务的</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((wc </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> maximumPoolSize </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (timed </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> timedOut))</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (wc </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> workQueue.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">compareAndDecrementWorkerCount</span><span style="color:#24292E;">(c))   </span><span style="color:#6A737D;">//如果CAS减少工作线程成功</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;    </span><span style="color:#6A737D;">//返回null</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//否则开下一轮循环</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            Runnable r </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> timed </span><span style="color:#D73A49;">?</span></span>
<span class="line"><span style="color:#24292E;">                workQueue.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">(keepAliveTime, TimeUnit.NANOSECONDS) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;">   </span><span style="color:#6A737D;">//如果可超时，那么最多等到超时时间</span></span>
<span class="line"><span style="color:#24292E;">                workQueue.</span><span style="color:#6F42C1;">take</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//如果不可超时，那就一直等着拿任务</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (r </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)    </span><span style="color:#6A737D;">//如果成功拿到任务，ok，返回</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> r;</span></span>
<span class="line"><span style="color:#24292E;">            timedOut </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//否则就是超时了，下一轮循环将直接返回null</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">retry</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            timedOut </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//开下一轮循环吧</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>当线程池关闭时会做什么事情：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//普通的shutdown会继续将等待队列中的线程执行完成后再关闭线程池</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock mainLock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.mainLock;</span></span>
<span class="line"><span style="color:#E1E4E8;">    mainLock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//判断是否有权限终止</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">checkShutdownAccess</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//CAS将线程池运行状态改为SHUTDOWN状态，还算比较温柔，详细过程看下面</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">advanceRunState</span><span style="color:#E1E4E8;">(SHUTDOWN);</span></span>
<span class="line"><span style="color:#E1E4E8;">       	</span><span style="color:#6A737D;">//让闲着的线程（比如正在等新的任务）中断，但是并不会影响正在运行的线程，详细过程请看下面</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">interruptIdleWorkers</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">onShutdown</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">//给ScheduledThreadPoolExecutor提供的钩子方法，就是等ScheduledThreadPoolExecutor去实现的，当前类没有实现</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        mainLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">tryTerminate</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//最后尝试终止线程池</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//普通的shutdown会继续将等待队列中的线程执行完成后再关闭线程池</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock mainLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.mainLock;</span></span>
<span class="line"><span style="color:#24292E;">    mainLock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//判断是否有权限终止</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">checkShutdownAccess</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//CAS将线程池运行状态改为SHUTDOWN状态，还算比较温柔，详细过程看下面</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">advanceRunState</span><span style="color:#24292E;">(SHUTDOWN);</span></span>
<span class="line"><span style="color:#24292E;">       	</span><span style="color:#6A737D;">//让闲着的线程（比如正在等新的任务）中断，但是并不会影响正在运行的线程，详细过程请看下面</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">interruptIdleWorkers</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">onShutdown</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">//给ScheduledThreadPoolExecutor提供的钩子方法，就是等ScheduledThreadPoolExecutor去实现的，当前类没有实现</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        mainLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">tryTerminate</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//最后尝试终止线程池</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">advanceRunState</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> targetState) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//获取ctl</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">runStateAtLeast</span><span style="color:#E1E4E8;">(c, targetState) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//是否大于等于指定的状态</span></span>
<span class="line"><span style="color:#E1E4E8;">            ctl.</span><span style="color:#B392F0;">compareAndSet</span><span style="color:#E1E4E8;">(c, </span><span style="color:#B392F0;">ctlOf</span><span style="color:#E1E4E8;">(targetState, </span><span style="color:#B392F0;">workerCountOf</span><span style="color:#E1E4E8;">(c))))   </span><span style="color:#6A737D;">//CAS设置ctl的值</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//任意一个条件OK就可以结束了</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">advanceRunState</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> targetState) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//获取ctl</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">runStateAtLeast</span><span style="color:#24292E;">(c, targetState) </span><span style="color:#D73A49;">||</span><span style="color:#24292E;">    </span><span style="color:#6A737D;">//是否大于等于指定的状态</span></span>
<span class="line"><span style="color:#24292E;">            ctl.</span><span style="color:#6F42C1;">compareAndSet</span><span style="color:#24292E;">(c, </span><span style="color:#6F42C1;">ctlOf</span><span style="color:#24292E;">(targetState, </span><span style="color:#6F42C1;">workerCountOf</span><span style="color:#24292E;">(c))))   </span><span style="color:#6A737D;">//CAS设置ctl的值</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//任意一个条件OK就可以结束了</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">interruptIdleWorkers</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> onlyOne) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock mainLock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.mainLock;</span></span>
<span class="line"><span style="color:#E1E4E8;">    mainLock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Worker w </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> workers) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            Thread t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> w.thread;    </span><span style="color:#6A737D;">//拿到Worker中的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">isInterrupted</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> w.</span><span style="color:#B392F0;">tryLock</span><span style="color:#E1E4E8;">()) {   </span><span style="color:#6A737D;">//先判断一下线程是不是没有被中断然后尝试加锁，但是通过前面的runWorker()源代码我们得知，开始之后是让Worker加了锁的，所以如果线程还在执行任务，那么这里肯定会false</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    t.</span><span style="color:#B392F0;">interrupt</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//如果走到这里，那么说明线程肯定是一个闲着的线程，直接给中断吧</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (SecurityException </span><span style="color:#FFAB70;">ignore</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    w.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//解锁</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (onlyOne)   </span><span style="color:#6A737D;">//如果只针对一个Worker，那么就结束循环</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        mainLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">interruptIdleWorkers</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> onlyOne) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock mainLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.mainLock;</span></span>
<span class="line"><span style="color:#24292E;">    mainLock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Worker w </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> workers) {</span></span>
<span class="line"><span style="color:#24292E;">            Thread t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> w.thread;    </span><span style="color:#6A737D;">//拿到Worker中的线程</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">isInterrupted</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> w.</span><span style="color:#6F42C1;">tryLock</span><span style="color:#24292E;">()) {   </span><span style="color:#6A737D;">//先判断一下线程是不是没有被中断然后尝试加锁，但是通过前面的runWorker()源代码我们得知，开始之后是让Worker加了锁的，所以如果线程还在执行任务，那么这里肯定会false</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    t.</span><span style="color:#6F42C1;">interrupt</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//如果走到这里，那么说明线程肯定是一个闲着的线程，直接给中断吧</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (SecurityException </span><span style="color:#E36209;">ignore</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    w.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//解锁</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (onlyOne)   </span><span style="color:#6A737D;">//如果只针对一个Worker，那么就结束循环</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        mainLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>shutdownNow()</code>方法解析：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//shutdownNow开始后，不仅不允许新的任务到来，也不会再执行等待队列的线程，而且会终止正在执行的线程</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Runnable</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">shutdownNow</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;</span><span style="color:#F97583;">Runnable</span><span style="color:#E1E4E8;">&gt; tasks;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock mainLock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.mainLock;</span></span>
<span class="line"><span style="color:#E1E4E8;">    mainLock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">checkShutdownAccess</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//这里就是直接设定为STOP状态了，不再像shutdown那么温柔</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">advanceRunState</span><span style="color:#E1E4E8;">(STOP);</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//直接中断所有工作线程，详细过程看下面</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">interruptWorkers</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//取出仍处于阻塞队列中的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">        tasks </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">drainQueue</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        mainLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">tryTerminate</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> tasks;   </span><span style="color:#6A737D;">//最后返回还没开始的任务</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//shutdownNow开始后，不仅不允许新的任务到来，也不会再执行等待队列的线程，而且会终止正在执行的线程</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Runnable</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">shutdownNow</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;</span><span style="color:#D73A49;">Runnable</span><span style="color:#24292E;">&gt; tasks;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock mainLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.mainLock;</span></span>
<span class="line"><span style="color:#24292E;">    mainLock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">checkShutdownAccess</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//这里就是直接设定为STOP状态了，不再像shutdown那么温柔</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">advanceRunState</span><span style="color:#24292E;">(STOP);</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//直接中断所有工作线程，详细过程看下面</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">interruptWorkers</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//取出仍处于阻塞队列中的线程</span></span>
<span class="line"><span style="color:#24292E;">        tasks </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">drainQueue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        mainLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">tryTerminate</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> tasks;   </span><span style="color:#6A737D;">//最后返回还没开始的任务</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">interruptWorkers</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock mainLock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.mainLock;</span></span>
<span class="line"><span style="color:#E1E4E8;">    mainLock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Worker w </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> workers)   </span><span style="color:#6A737D;">//遍历所有Worker</span></span>
<span class="line"><span style="color:#E1E4E8;">            w.</span><span style="color:#B392F0;">interruptIfStarted</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//无差别对待，一律加中断标记</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        mainLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">interruptWorkers</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock mainLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.mainLock;</span></span>
<span class="line"><span style="color:#24292E;">    mainLock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Worker w </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> workers)   </span><span style="color:#6A737D;">//遍历所有Worker</span></span>
<span class="line"><span style="color:#24292E;">            w.</span><span style="color:#6F42C1;">interruptIfStarted</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//无差别对待，一律加中断标记</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        mainLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>tryTerminate()</code>终止掉一个线程池：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryTerminate</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;;) {     </span><span style="color:#6A737D;">//无限循环</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctl.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//上来先获取一下ctl值</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//只要是正在运行 或是 线程池基本上关闭了 或是 处于SHUTDOWN状态且工作队列不为空，那么这时还不能关闭线程池，返回</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isRunning</span><span style="color:#E1E4E8;">(c) </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">runStateAtLeast</span><span style="color:#E1E4E8;">(c, TIDYING) </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">            (</span><span style="color:#B392F0;">runStateOf</span><span style="color:#E1E4E8;">(c) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> SHUTDOWN </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;"> workQueue.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()))</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//走到这里，要么处于SHUTDOWN状态且等待队列为空或是STOP状态</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">workerCountOf</span><span style="color:#E1E4E8;">(c) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 如果工作线程数不是0，这里也会中断空闲状态下的线程</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">interruptIdleWorkers</span><span style="color:#E1E4E8;">(ONLY_ONE);   </span><span style="color:#6A737D;">//这里最多只中断一个空闲线程，然后返回</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">//走到这里，工作线程也为空了，可以终止线程池了</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ReentrantLock mainLock </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.mainLock;</span></span>
<span class="line"><span style="color:#E1E4E8;">        mainLock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ctl.</span><span style="color:#B392F0;">compareAndSet</span><span style="color:#E1E4E8;">(c, </span><span style="color:#B392F0;">ctlOf</span><span style="color:#E1E4E8;">(TIDYING, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">))) {   </span><span style="color:#6A737D;">//先CAS将状态设定为TIDYING表示基本终止，正在做最后的操作</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">terminated</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//终止，暂时没有实现</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    ctl.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">ctlOf</span><span style="color:#E1E4E8;">(TERMINATED, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">));   </span><span style="color:#6A737D;">//最后将状态设定为TERMINATED，线程池结束了它年轻的生命</span></span>
<span class="line"><span style="color:#E1E4E8;">                    termination.</span><span style="color:#B392F0;">signalAll</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//如果有线程调用了awaitTermination方法，会等待当前线程池终止，到这里差不多就可以唤醒了</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">//结束</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">          	</span><span style="color:#6A737D;">//注意如果CAS失败会直接进下一轮循环重新判断</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            mainLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// else retry on failed CAS</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryTerminate</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;;) {     </span><span style="color:#6A737D;">//无限循环</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctl.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//上来先获取一下ctl值</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//只要是正在运行 或是 线程池基本上关闭了 或是 处于SHUTDOWN状态且工作队列不为空，那么这时还不能关闭线程池，返回</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isRunning</span><span style="color:#24292E;">(c) </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">runStateAtLeast</span><span style="color:#24292E;">(c, TIDYING) </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">            (</span><span style="color:#6F42C1;">runStateOf</span><span style="color:#24292E;">(c) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> SHUTDOWN </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;"> workQueue.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()))</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//走到这里，要么处于SHUTDOWN状态且等待队列为空或是STOP状态</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">workerCountOf</span><span style="color:#24292E;">(c) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果工作线程数不是0，这里也会中断空闲状态下的线程</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">interruptIdleWorkers</span><span style="color:#24292E;">(ONLY_ONE);   </span><span style="color:#6A737D;">//这里最多只中断一个空闲线程，然后返回</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">//走到这里，工作线程也为空了，可以终止线程池了</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ReentrantLock mainLock </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.mainLock;</span></span>
<span class="line"><span style="color:#24292E;">        mainLock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ctl.</span><span style="color:#6F42C1;">compareAndSet</span><span style="color:#24292E;">(c, </span><span style="color:#6F42C1;">ctlOf</span><span style="color:#24292E;">(TIDYING, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">))) {   </span><span style="color:#6A737D;">//先CAS将状态设定为TIDYING表示基本终止，正在做最后的操作</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">terminated</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//终止，暂时没有实现</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    ctl.</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">ctlOf</span><span style="color:#24292E;">(TERMINATED, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">));   </span><span style="color:#6A737D;">//最后将状态设定为TERMINATED，线程池结束了它年轻的生命</span></span>
<span class="line"><span style="color:#24292E;">                    termination.</span><span style="color:#6F42C1;">signalAll</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//如果有线程调用了awaitTermination方法，会等待当前线程池终止，到这里差不多就可以唤醒了</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">//结束</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">          	</span><span style="color:#6A737D;">//注意如果CAS失败会直接进下一轮循环重新判断</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            mainLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// else retry on failed CAS</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="应用篇" tabindex="-1">应用篇 <a class="header-anchor" href="#应用篇" aria-label="Permalink to &quot;应用篇&quot;">​</a></h2><h3 id="如何创建线程" tabindex="-1">如何创建线程 <a class="header-anchor" href="#如何创建线程" aria-label="Permalink to &quot;如何创建线程&quot;">​</a></h3><p>Java中创建线程主要有以下这几种方式：</p><ul><li>定义<code>Thread</code>类的子类，并重写该类的<code>run</code>方法</li><li>定义<code>Runnable</code>接口的实现类，并重写该接口的<code>run()</code>方法</li><li>定义<code>Callable</code>接口的实现类，并重写该接口的<code>call()</code>方法，一般配合<code>Future</code>使用</li><li>线程池</li></ul><h3 id="手写一把锁" tabindex="-1">手写一把锁 <a class="header-anchor" href="#手写一把锁" aria-label="Permalink to &quot;手写一把锁&quot;">​</a></h3><p>要求：同一时间只能有一个线程持有锁，不要求可重入（无视反复加锁）</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * 自行实现一个最普通的独占锁</span></span>
<span class="line"><span style="color:#6A737D;">     * 要求：同一时间只能有一个线程持有锁，不要求可重入</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MyLock</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Lock</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">        /**</span></span>
<span class="line"><span style="color:#6A737D;">         * 设计思路：</span></span>
<span class="line"><span style="color:#6A737D;">         * 1. 锁被占用，那么exclusiveOwnerThread应该被记录，并且state = 1</span></span>
<span class="line"><span style="color:#6A737D;">         * 2. 锁没有被占用，那么exclusiveOwnerThread为null，并且state = 0</span></span>
<span class="line"><span style="color:#6A737D;">         */</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractQueuedSynchronizer</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">arg</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">isHeldExclusively</span><span style="color:#E1E4E8;">()) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;     </span><span style="color:#6A737D;">//无需可重入功能，如果是当前线程直接返回true</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">compareAndSetState</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, arg)){    </span><span style="color:#6A737D;">//CAS操作进行状态替换</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">setExclusiveOwnerThread</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">());    </span><span style="color:#6A737D;">//成功后设置当前的所有者线程</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryRelease</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">arg</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getState</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IllegalMonitorStateException</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//没加锁情况下是不能直接解锁的</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">isHeldExclusively</span><span style="color:#E1E4E8;">()){     </span><span style="color:#6A737D;">//只有持有锁的线程才能解锁</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">setExclusiveOwnerThread</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);    </span><span style="color:#6A737D;">//设置所有者线程为null</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#B392F0;">setState</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);    </span><span style="color:#6A737D;">//状态变为0</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isHeldExclusively</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getExclusiveOwnerThread</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> Condition </span><span style="color:#B392F0;">newCondition</span><span style="color:#E1E4E8;">(){</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ConditionObject</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//直接用现成的</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Sync sync </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sync</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            sync.</span><span style="color:#B392F0;">acquire</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lockInterruptibly</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">            sync.</span><span style="color:#B392F0;">acquireInterruptibly</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryLock</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> sync.</span><span style="color:#B392F0;">tryAcquire</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tryLock</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">time</span><span style="color:#E1E4E8;">, TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> sync.</span><span style="color:#B392F0;">tryAcquireNanos</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, unit.</span><span style="color:#B392F0;">toNanos</span><span style="color:#E1E4E8;">(time));</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            sync.</span><span style="color:#B392F0;">release</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Condition </span><span style="color:#B392F0;">newCondition</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> sync.</span><span style="color:#B392F0;">newCondition</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Main</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * 自行实现一个最普通的独占锁</span></span>
<span class="line"><span style="color:#6A737D;">     * 要求：同一时间只能有一个线程持有锁，不要求可重入</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MyLock</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Lock</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">        /**</span></span>
<span class="line"><span style="color:#6A737D;">         * 设计思路：</span></span>
<span class="line"><span style="color:#6A737D;">         * 1. 锁被占用，那么exclusiveOwnerThread应该被记录，并且state = 1</span></span>
<span class="line"><span style="color:#6A737D;">         * 2. 锁没有被占用，那么exclusiveOwnerThread为null，并且state = 0</span></span>
<span class="line"><span style="color:#6A737D;">         */</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractQueuedSynchronizer</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">arg</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">isHeldExclusively</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;     </span><span style="color:#6A737D;">//无需可重入功能，如果是当前线程直接返回true</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">compareAndSetState</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, arg)){    </span><span style="color:#6A737D;">//CAS操作进行状态替换</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">setExclusiveOwnerThread</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">());    </span><span style="color:#6A737D;">//成功后设置当前的所有者线程</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryRelease</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">arg</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getState</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IllegalMonitorStateException</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">//没加锁情况下是不能直接解锁的</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">isHeldExclusively</span><span style="color:#24292E;">()){     </span><span style="color:#6A737D;">//只有持有锁的线程才能解锁</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">setExclusiveOwnerThread</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);    </span><span style="color:#6A737D;">//设置所有者线程为null</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6F42C1;">setState</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);    </span><span style="color:#6A737D;">//状态变为0</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isHeldExclusively</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getExclusiveOwnerThread</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> Condition </span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ConditionObject</span><span style="color:#24292E;">();    </span><span style="color:#6A737D;">//直接用现成的</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Sync sync </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sync</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">            sync.</span><span style="color:#6F42C1;">acquire</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lockInterruptibly</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">            sync.</span><span style="color:#6F42C1;">acquireInterruptibly</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryLock</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> sync.</span><span style="color:#6F42C1;">tryAcquire</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tryLock</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">time</span><span style="color:#24292E;">, TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> sync.</span><span style="color:#6F42C1;">tryAcquireNanos</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, unit.</span><span style="color:#6F42C1;">toNanos</span><span style="color:#24292E;">(time));</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">            sync.</span><span style="color:#6F42C1;">release</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Condition </span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> sync.</span><span style="color:#6F42C1;">newCondition</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="生产者消费者模型" tabindex="-1">生产者消费者模型 <a class="header-anchor" href="#生产者消费者模型" aria-label="Permalink to &quot;生产者消费者模型&quot;">​</a></h3><h4 id="阻塞队列实现" tabindex="-1">阻塞队列实现 <a class="header-anchor" href="#阻塞队列实现" aria-label="Permalink to &quot;阻塞队列实现&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        BlockingQueue&lt;</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; queue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayBlockingQueue&lt;&gt;(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Runnable supplier </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    String name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    System.err.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">time</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;生产者 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">name</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 正在准备餐品...&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    System.err.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">time</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;生产者 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">name</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 已出餐！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    queue.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        };</span></span>
<span class="line"><span style="color:#E1E4E8;">        Runnable consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    String name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">time</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;消费者 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">name</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 正在等待出餐...&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    queue.</span><span style="color:#B392F0;">take</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">time</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;消费者 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">name</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 取到了餐品。&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    TimeUnit.SECONDS.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">time</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;消费者 &quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">name</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot; 已经将饭菜吃完了！&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        };</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(supplier, </span><span style="color:#9ECBFF;">&quot;Supplier-&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">i).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thread</span><span style="color:#E1E4E8;">(consumer, </span><span style="color:#9ECBFF;">&quot;Consumer-&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">i).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> String </span><span style="color:#B392F0;">time</span><span style="color:#E1E4E8;">(){</span></span>
<span class="line"><span style="color:#E1E4E8;">        SimpleDateFormat format </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SimpleDateFormat</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;HH:mm:ss&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;[&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">format.</span><span style="color:#B392F0;">format</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Date</span><span style="color:#E1E4E8;">()) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;] &quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Main</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">        BlockingQueue&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; queue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayBlockingQueue&lt;&gt;(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        Runnable supplier </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    String name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    System.err.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">time</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;生产者 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">name</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 正在准备餐品...&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                    TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                    System.err.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">time</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;生产者 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">name</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 已出餐！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                    queue.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        };</span></span>
<span class="line"><span style="color:#24292E;">        Runnable consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    String name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">time</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;消费者 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">name</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 正在等待出餐...&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                    queue.</span><span style="color:#6F42C1;">take</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">time</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;消费者 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">name</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 取到了餐品。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                    TimeUnit.SECONDS.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">time</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;消费者 &quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">name</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot; 已经将饭菜吃完了！&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        };</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(supplier, </span><span style="color:#032F62;">&quot;Supplier-&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">i).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thread</span><span style="color:#24292E;">(consumer, </span><span style="color:#032F62;">&quot;Consumer-&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">i).</span><span style="color:#6F42C1;">start</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> String </span><span style="color:#6F42C1;">time</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">        SimpleDateFormat format </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SimpleDateFormat</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;HH:mm:ss&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;[&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">format.</span><span style="color:#6F42C1;">format</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Date</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;] &quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="completablefuture应用" tabindex="-1">CompletableFuture应用 <a class="header-anchor" href="#completablefuture应用" aria-label="Permalink to &quot;CompletableFuture应用&quot;">​</a></h3><blockquote><p>初始化线程的4种方式：</p><p>继承Thread 实现Runnable接口 实现Callable接口 + FutureTask （可以拿到返回结果，可以处理异常） 线程池 方式1和方式2：主进程无法获取线程的运算结果。不适合当前场景</p><p>方式3：主进程可以获取线程的运算结果，并设置给itemVO，但是不利于控制服务器中的线程资源。可以导致服务器资源耗尽。</p><p>方式4：通过如下两种方式初始化线程池：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Executors.</span><span style="color:#B392F0;">newFiexedThreadPool</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">//或者</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadPoolExecutor</span><span style="color:#E1E4E8;">(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit unit, workQueue, threadFactory, handler);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Executors.</span><span style="color:#6F42C1;">newFiexedThreadPool</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">//或者</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadPoolExecutor</span><span style="color:#24292E;">(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit unit, workQueue, threadFactory, handler);</span></span></code></pre></div></blockquote><h6 id="创建异步对象" tabindex="-1">创建异步对象 <a class="header-anchor" href="#创建异步对象" aria-label="Permalink to &quot;创建异步对象&quot;">​</a></h6><blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runAsync</span><span style="color:#E1E4E8;">(Runnable runnable)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runAsync</span><span style="color:#E1E4E8;">(Runnable runnable, Executor executor)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(Supplier</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> supplier)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(Supplier</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> supplier, Executor executor)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runAsync</span><span style="color:#24292E;">(Runnable runnable)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runAsync</span><span style="color:#24292E;">(Runnable runnable, Executor executor)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(Supplier</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> supplier)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(Supplier</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> supplier, Executor executor)</span></span></code></pre></div><blockquote><p><strong>没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码</strong>。如果指定线程池，则使用指定的线程池运行。</p></blockquote><blockquote><ul><li>runAsync方法不支持返回值。</li><li>supplyAsync可以支持返回值。</li></ul></blockquote></blockquote><h6 id="计算完成时回调方法" tabindex="-1">计算完成时回调方法 <a class="header-anchor" href="#计算完成时回调方法" aria-label="Permalink to &quot;计算完成时回调方法&quot;">​</a></h6><blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">whenComplete</span><span style="color:#E1E4E8;">(BiConsumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> Throwable</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">whenCompleteAsync</span><span style="color:#E1E4E8;">(BiConsumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> Throwable</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">whenCompleteAsync</span><span style="color:#E1E4E8;">(BiConsumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> Throwable</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action, Executor executor);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">exceptionally</span><span style="color:#E1E4E8;">(Function</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Throwable,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">whenComplete</span><span style="color:#24292E;">(BiConsumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> Throwable</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">whenCompleteAsync</span><span style="color:#24292E;">(BiConsumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> Throwable</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">whenCompleteAsync</span><span style="color:#24292E;">(BiConsumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> Throwable</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action, Executor executor);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">exceptionally</span><span style="color:#24292E;">(Function</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Throwable,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn);</span></span></code></pre></div><blockquote><p>whenComplete可以处理正常和异常的计算结果，exceptionally处理异常情况。BiConsumer&lt;? super T,? super Throwable&gt;可以定义处理业务</p></blockquote><blockquote><p>whenComplete 和 whenCompleteAsync 的区别： whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。 whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。</p></blockquote><blockquote><p>方法不以Async结尾，Action使用相同的线程执行，而Async可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CompletableFutureDemo</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture future </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Supplier&lt;</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">          System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;</span><span style="color:#79B8FF;">\\t</span><span style="color:#9ECBFF;"> completableFuture&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">whenComplete</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> BiConsumer&lt;</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Throwable</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">accept</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">o</span><span style="color:#E1E4E8;">, Throwable </span><span style="color:#FFAB70;">throwable</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;-------o=&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> o.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">          System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;-------throwable=&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> throwable);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">exceptionally</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Function&lt;</span><span style="color:#F97583;">Throwable</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(Throwable </span><span style="color:#FFAB70;">throwable</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;throwable=&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> throwable);</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">6666</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(future.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CompletableFutureDemo</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture future </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Supplier&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">      @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">          System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;</span><span style="color:#005CC5;">\\t</span><span style="color:#032F62;"> completableFuture&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">whenComplete</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> BiConsumer&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Throwable</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">      @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">accept</span><span style="color:#24292E;">(Object </span><span style="color:#E36209;">o</span><span style="color:#24292E;">, Throwable </span><span style="color:#E36209;">throwable</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;-------o=&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> o.</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">          System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;-------throwable=&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> throwable);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">exceptionally</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Function&lt;</span><span style="color:#D73A49;">Throwable</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">      @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(Throwable </span><span style="color:#E36209;">throwable</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;throwable=&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> throwable);</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">6666</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(future.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></blockquote><h6 id="handle-方法" tabindex="-1">handle 方法 <a class="header-anchor" href="#handle-方法" aria-label="Permalink to &quot;handle 方法&quot;">​</a></h6><blockquote><p>handle 是执行<strong>任务完成时</strong>对结果的处理。 handle 是在任务完成后再执行，还可以处理异常的任务。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">handle</span><span style="color:#E1E4E8;">(BiFunction</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, Throwable, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">handleAsync</span><span style="color:#E1E4E8;">(BiFunction</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, Throwable, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">handleAsync</span><span style="color:#E1E4E8;">(BiFunction</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, Throwable, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn,Executor executor);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">handle</span><span style="color:#24292E;">(BiFunction</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, Throwable, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">handleAsync</span><span style="color:#24292E;">(BiFunction</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, Throwable, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">handleAsync</span><span style="color:#24292E;">(BiFunction</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, Throwable, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn,Executor executor);</span></span></code></pre></div></blockquote><h6 id="线程串行化方法" tabindex="-1">线程串行化方法 <a class="header-anchor" href="#线程串行化方法" aria-label="Permalink to &quot;线程串行化方法&quot;">​</a></h6><blockquote><p>thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任务的返回值。</p><p>thenAccept方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。</p><p>thenRun方法：只要上面的任务执行完成，就开始执行thenRun，只是处理完任务后，执行 thenRun的后续操作</p><p>带有Async默认是异步执行的。这里所谓的异步指的是不在当前线程内执行。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenApply</span><span style="color:#E1E4E8;">(Function</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenApplyAsync</span><span style="color:#E1E4E8;">(Function</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenApplyAsync</span><span style="color:#E1E4E8;">(Function</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn, Executor executor)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenAccept</span><span style="color:#E1E4E8;">(Consumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenAcceptAsync</span><span style="color:#E1E4E8;">(Consumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenAcceptAsync</span><span style="color:#E1E4E8;">(Consumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action,Executor executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenRun</span><span style="color:#E1E4E8;">(Runnable action);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenRunAsync</span><span style="color:#E1E4E8;">(Runnable action);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenRunAsync</span><span style="color:#E1E4E8;">(Runnable action,Executor executor);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenApply</span><span style="color:#24292E;">(Function</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenApplyAsync</span><span style="color:#24292E;">(Function</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenApplyAsync</span><span style="color:#24292E;">(Function</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn, Executor executor)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenAccept</span><span style="color:#24292E;">(Consumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenAcceptAsync</span><span style="color:#24292E;">(Consumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenAcceptAsync</span><span style="color:#24292E;">(Consumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action,Executor executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenRun</span><span style="color:#24292E;">(Runnable action);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenRunAsync</span><span style="color:#24292E;">(Runnable action);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenRunAsync</span><span style="color:#24292E;">(Runnable action,Executor executor);</span></span></code></pre></div><blockquote><p>Function&lt;? super T,? extends U&gt; T：上一个任务返回结果的类型 U：当前任务的返回值类型</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; future </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Supplier&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Integer </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;</span><span style="color:#79B8FF;">\\t</span><span style="color:#9ECBFF;"> completableFuture&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">//int i = 10 / 0;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">thenApply</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Function&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Integer </span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(Integer </span><span style="color:#FFAB70;">o</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;thenApply方法，上次返回结果：&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> o);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">  o </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">whenComplete</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> BiConsumer&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Throwable</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">accept</span><span style="color:#E1E4E8;">(Integer </span><span style="color:#FFAB70;">o</span><span style="color:#E1E4E8;">, Throwable </span><span style="color:#FFAB70;">throwable</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;-------o=&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> o);</span></span>
<span class="line"><span style="color:#E1E4E8;">      System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;-------throwable=&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> throwable);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">exceptionally</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Function&lt;</span><span style="color:#F97583;">Throwable</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Integer </span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(Throwable </span><span style="color:#FFAB70;">throwable</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;throwable=&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> throwable);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">6666</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">handle</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> BiFunction&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Throwable</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Integer </span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(Integer </span><span style="color:#FFAB70;">integer</span><span style="color:#E1E4E8;">, Throwable </span><span style="color:#FFAB70;">throwable</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;handle o=&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> integer);</span></span>
<span class="line"><span style="color:#E1E4E8;">      System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;handle throwable=&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> throwable);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">8888</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(future.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; future </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Supplier&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Integer </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;</span><span style="color:#005CC5;">\\t</span><span style="color:#032F62;"> completableFuture&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">//int i = 10 / 0;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">thenApply</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Function&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Integer </span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(Integer </span><span style="color:#E36209;">o</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;thenApply方法，上次返回结果：&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> o);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">  o </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">whenComplete</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> BiConsumer&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Throwable</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">accept</span><span style="color:#24292E;">(Integer </span><span style="color:#E36209;">o</span><span style="color:#24292E;">, Throwable </span><span style="color:#E36209;">throwable</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;-------o=&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> o);</span></span>
<span class="line"><span style="color:#24292E;">      System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;-------throwable=&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> throwable);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">exceptionally</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Function&lt;</span><span style="color:#D73A49;">Throwable</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Integer </span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(Throwable </span><span style="color:#E36209;">throwable</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;throwable=&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> throwable);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">6666</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">handle</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> BiFunction&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Throwable</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Integer </span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(Integer </span><span style="color:#E36209;">integer</span><span style="color:#24292E;">, Throwable </span><span style="color:#E36209;">throwable</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;handle o=&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> integer);</span></span>
<span class="line"><span style="color:#24292E;">      System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;handle throwable=&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> throwable);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">8888</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(future.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></blockquote><h6 id="两任务组合-都完成" tabindex="-1">两任务组合-都完成 <a class="header-anchor" href="#两任务组合-都完成" aria-label="Permalink to &quot;两任务组合-都完成&quot;">​</a></h6><blockquote><p>两个任务必须都完成，触发该任务。</p><p>thenCombine：组合两个future，获取两个future的返回结果，并返回当前任务的返回值</p><p>thenAcceptBoth：组合两个future，获取两个future任务的返回结果，然后处理任务，没有返回值。</p><p>runAfterBoth：组合两个future，不需要获取future的结果，只需两个future处理完任务后，处理该任务。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenCombine</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other,</span></span>
<span class="line"><span style="color:#E1E4E8;">BiFunction</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> U,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenCombineAsync</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other,</span></span>
<span class="line"><span style="color:#E1E4E8;">BiFunction</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> U,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenCombineAsync</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other,</span></span>
<span class="line"><span style="color:#E1E4E8;">BiFunction</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> U,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn, Executor executor);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenAcceptBoth</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other,</span></span>
<span class="line"><span style="color:#E1E4E8;">BiConsumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenAcceptBothAsync</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other,</span></span>
<span class="line"><span style="color:#E1E4E8;">BiConsumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenAcceptBothAsync</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other,</span></span>
<span class="line"><span style="color:#E1E4E8;">BiConsumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action, Executor executor);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runAfterBoth</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> other,Runnable action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runAfterBothAsync</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> other,Runnable action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runAfterBothAsync</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> other,Runnable action,Executor executor);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenCombine</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other,</span></span>
<span class="line"><span style="color:#24292E;">BiFunction</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> U,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenCombineAsync</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other,</span></span>
<span class="line"><span style="color:#24292E;">BiFunction</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> U,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenCombineAsync</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other,</span></span>
<span class="line"><span style="color:#24292E;">BiFunction</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> U,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn, Executor executor);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenAcceptBoth</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other,</span></span>
<span class="line"><span style="color:#24292E;">BiConsumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenAcceptBothAsync</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other,</span></span>
<span class="line"><span style="color:#24292E;">BiConsumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenAcceptBothAsync</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other,</span></span>
<span class="line"><span style="color:#24292E;">BiConsumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action, Executor executor);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runAfterBoth</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> other,Runnable action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runAfterBothAsync</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> other,Runnable action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runAfterBothAsync</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> other,Runnable action,Executor executor);</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture.</span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;hello&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">thenApplyAsync</span><span style="color:#E1E4E8;">(t </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; world!&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">thenCombineAsync</span><span style="color:#E1E4E8;">(CompletableFuture.</span><span style="color:#B392F0;">completedFuture</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot; CompletableFuture&quot;</span><span style="color:#E1E4E8;">), (t, u) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> u;</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">whenComplete</span><span style="color:#E1E4E8;">((t, u) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(t);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) {</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture.</span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">thenApplyAsync</span><span style="color:#24292E;">(t </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; world!&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">thenCombineAsync</span><span style="color:#24292E;">(CompletableFuture.</span><span style="color:#6F42C1;">completedFuture</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot; CompletableFuture&quot;</span><span style="color:#24292E;">), (t, u) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> u;</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">whenComplete</span><span style="color:#24292E;">((t, u) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(t);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></blockquote><h6 id="两任务组合-一个完成" tabindex="-1">两任务组合 - 一个完成 <a class="header-anchor" href="#两任务组合-一个完成" aria-label="Permalink to &quot;两任务组合 - 一个完成&quot;">​</a></h6><blockquote><p>当两个任务中，任意一个future任务完成的时候，执行任务。</p><p>applyToEither：两个任务有一个执行完成，获取它的返回值，处理任务并有新的返回值。</p><p>acceptEither：两个任务有一个执行完成，获取它的返回值，处理任务，没有新的返回值。</p><p>runAfterEither：两个任务有一个执行完成，不需要获取future的结果，处理任务，也没有返回值。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">applyToEither</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other, Function</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">applyToEitherAsync</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other, Function</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">applyToEitherAsync</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other, Function</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                        Executor executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">acceptEither</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other, Consumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">acceptEitherAsync</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other, Consumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">acceptEitherAsync</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other, </span></span>
<span class="line"><span style="color:#E1E4E8;">                                      Consumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action,Executor executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runAfterEither</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> other,Runnable action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runAfterEitherAsync</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> other,Runnable action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runAfterEitherAsync</span><span style="color:#E1E4E8;">(CompletionStage</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> other,Runnable action,Executor executor);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">applyToEither</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other, Function</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">applyToEitherAsync</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other, Function</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">applyToEitherAsync</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other, Function</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn,</span></span>
<span class="line"><span style="color:#24292E;">                                        Executor executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">acceptEither</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other, Consumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">acceptEitherAsync</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other, Consumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">acceptEitherAsync</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other, </span></span>
<span class="line"><span style="color:#24292E;">                                      Consumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action,Executor executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runAfterEither</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> other,Runnable action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runAfterEitherAsync</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> other,Runnable action);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runAfterEitherAsync</span><span style="color:#24292E;">(CompletionStage</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> other,Runnable action,Executor executor);</span></span></code></pre></div></blockquote><h6 id="多任务组合" tabindex="-1">多任务组合 <a class="header-anchor" href="#多任务组合" aria-label="Permalink to &quot;多任务组合&quot;">​</a></h6><blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">allOf</span><span style="color:#E1E4E8;">(CompletableFuture</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;">... cfs);</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Object</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">anyOf</span><span style="color:#E1E4E8;">(CompletableFuture</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;">... cfs);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">allOf</span><span style="color:#24292E;">(CompletableFuture</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;">... cfs);</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Object</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">anyOf</span><span style="color:#24292E;">(CompletableFuture</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;">... cfs);</span></span></code></pre></div><p>allOf：等待所有任务完成</p><p>anyOf：只要有一个任务完成</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">List&lt;</span><span style="color:#F97583;">CompletableFuture</span><span style="color:#E1E4E8;">&gt; futures </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Arrays.</span><span style="color:#B392F0;">asList</span><span style="color:#E1E4E8;">(CompletableFuture.</span><span style="color:#B392F0;">completedFuture</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;hello&quot;</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#E1E4E8;">                                              CompletableFuture.</span><span style="color:#B392F0;">completedFuture</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot; world!&quot;</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#E1E4E8;">                                              CompletableFuture.</span><span style="color:#B392F0;">completedFuture</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot; hello&quot;</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#E1E4E8;">                                              CompletableFuture.</span><span style="color:#B392F0;">completedFuture</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;java!&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; allCompleted </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">allOf</span><span style="color:#E1E4E8;">(futures.</span><span style="color:#B392F0;">toArray</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">CompletableFuture</span><span style="color:#E1E4E8;">[]{}));</span></span>
<span class="line"><span style="color:#E1E4E8;">allCompleted.</span><span style="color:#B392F0;">thenRun</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">futures.</span><span style="color:#B392F0;">stream</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(future </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">          System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;get future at:&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;">&quot;, result:&quot;</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">future.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException | ExecutionException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) {</span></span>
<span class="line"><span style="color:#24292E;">List&lt;</span><span style="color:#D73A49;">CompletableFuture</span><span style="color:#24292E;">&gt; futures </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Arrays.</span><span style="color:#6F42C1;">asList</span><span style="color:#24292E;">(CompletableFuture.</span><span style="color:#6F42C1;">completedFuture</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">                                              CompletableFuture.</span><span style="color:#6F42C1;">completedFuture</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot; world!&quot;</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">                                              CompletableFuture.</span><span style="color:#6F42C1;">completedFuture</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot; hello&quot;</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">                                              CompletableFuture.</span><span style="color:#6F42C1;">completedFuture</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;java!&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; allCompleted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">allOf</span><span style="color:#24292E;">(futures.</span><span style="color:#6F42C1;">toArray</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">CompletableFuture</span><span style="color:#24292E;">[]{}));</span></span>
<span class="line"><span style="color:#24292E;">allCompleted.</span><span style="color:#6F42C1;">thenRun</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">futures.</span><span style="color:#6F42C1;">stream</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(future </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">          System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;get future at:&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">+</span><span style="color:#032F62;">&quot;, result:&quot;</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">future.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">      } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException | ExecutionException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          e.</span><span style="color:#6F42C1;">printStackTrace</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></blockquote><h6 id="实例" tabindex="-1">实例 <a class="header-anchor" href="#实例" aria-label="Permalink to &quot;实例&quot;">​</a></h6><blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Service</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ItemServiceImpl</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ItemService</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> GmallPmsFeign pmsFeign;</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> GmallSmsFeign smsFeign;</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> GmallWmsFeign wmsFeign;</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> ThreadPoolExecutor threadPoolExecutor;</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> ItemVO </span><span style="color:#B392F0;">loadData</span><span style="color:#E1E4E8;">(Long </span><span style="color:#FFAB70;">skuId</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">ItemVO itemVO </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ItemVO</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 1. 获取sku的基本信息</span></span>
<span class="line"><span style="color:#6A737D;">// 后续获取sku的促销信息、spu的销售属性和spu详情信息（需要sku中的spuId）都需要skuInfoEntity</span></span>
<span class="line"><span style="color:#6A737D;">// supplyAsync有返回值</span></span>
<span class="line"><span style="color:#6A737D;">// runAsync无返回值</span></span>
<span class="line"><span style="color:#6A737D;">// 所以这里需要使用supplyAsync</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">SkuInfoEntity</span><span style="color:#E1E4E8;">&gt; skuFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      Resp&lt;</span><span style="color:#F97583;">SkuInfoEntity</span><span style="color:#E1E4E8;">&gt; skuInfoEntityResp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.pmsFeign.</span><span style="color:#B392F0;">querySkuById</span><span style="color:#E1E4E8;">(skuId);</span></span>
<span class="line"><span style="color:#E1E4E8;">      SkuInfoEntity skuInfoEntity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> skuInfoEntityResp.</span><span style="color:#B392F0;">getData</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (skuInfoEntity </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          BeanUtils.</span><span style="color:#B392F0;">copyProperties</span><span style="color:#E1E4E8;">(skuInfoEntity, itemVO);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> skuInfoEntity;</span></span>
<span class="line"><span style="color:#E1E4E8;">}, threadPoolExecutor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2. 获取sku的图片信息</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; skuImageFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">runAsync</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      Resp&lt;List&lt;</span><span style="color:#F97583;">SkuImagesEntity</span><span style="color:#E1E4E8;">&gt;&gt; listResp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.pmsFeign.</span><span style="color:#B392F0;">queryImagesBySkuId</span><span style="color:#E1E4E8;">(skuId);</span></span>
<span class="line"><span style="color:#E1E4E8;">      List&lt;</span><span style="color:#F97583;">SkuImagesEntity</span><span style="color:#E1E4E8;">&gt; images </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> listResp.</span><span style="color:#B392F0;">getData</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">CollectionUtils.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">(images)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; imageUrls </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> images.</span><span style="color:#B392F0;">stream</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(image </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> image.</span><span style="color:#B392F0;">getImgUrl</span><span style="color:#E1E4E8;">()).</span><span style="color:#B392F0;">collect</span><span style="color:#E1E4E8;">(Collectors.</span><span style="color:#B392F0;">toList</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">          itemVO.</span><span style="color:#B392F0;">setPics</span><span style="color:#E1E4E8;">(imageUrls);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">}, threadPoolExecutor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 3. 获取sku的促销信息 TODO</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 4. 获取spu的所有销售属性</span></span>
<span class="line"><span style="color:#6A737D;">// thenAcceptAsync：有参数，无返回</span></span>
<span class="line"><span style="color:#6A737D;">// thenApplyAsync: 有参数，有返回</span></span>
<span class="line"><span style="color:#6A737D;">// 后续spu详情也需要skuInfoEntity中的spuId，所以这里使用thenApplyAsync</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">SkuInfoEntity</span><span style="color:#E1E4E8;">&gt; spuFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> skuFuture.</span><span style="color:#B392F0;">thenApplyAsync</span><span style="color:#E1E4E8;">(skuInfoEntity </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      Resp&lt;List&lt;</span><span style="color:#F97583;">SkuSaleAttrValueEntity</span><span style="color:#E1E4E8;">&gt;&gt; skuSaleAttrValueResp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.pmsFeign.</span><span style="color:#B392F0;">querySkuSaleAttrValueBySpuId</span><span style="color:#E1E4E8;">(skuInfoEntity.</span><span style="color:#B392F0;">getSpuId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">      List&lt;</span><span style="color:#F97583;">SkuSaleAttrValueEntity</span><span style="color:#E1E4E8;">&gt; skuSaleAttrValueEntities </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> skuSaleAttrValueResp.</span><span style="color:#B392F0;">getData</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      itemVO.</span><span style="color:#B392F0;">setSaleAttrs</span><span style="color:#E1E4E8;">(skuSaleAttrValueEntities);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> skuInfoEntity;</span></span>
<span class="line"><span style="color:#E1E4E8;">}, threadPoolExecutor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 5. 获取规格参数组及组下的规格参数 TODO</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 6. spu详情 TODO</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; future </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">allOf</span><span style="color:#E1E4E8;">(skuFuture, skuImageFuture, spuFuture);</span></span>
<span class="line"><span style="color:#6A737D;">// 阻塞主进程，等待子进程全部执行完毕！</span></span>
<span class="line"><span style="color:#E1E4E8;">future.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> itemVO;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Service</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ItemServiceImpl</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ItemService</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> GmallPmsFeign pmsFeign;</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> GmallSmsFeign smsFeign;</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> GmallWmsFeign wmsFeign;</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> ThreadPoolExecutor threadPoolExecutor;</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> ItemVO </span><span style="color:#6F42C1;">loadData</span><span style="color:#24292E;">(Long </span><span style="color:#E36209;">skuId</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">ItemVO itemVO </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ItemVO</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 1. 获取sku的基本信息</span></span>
<span class="line"><span style="color:#6A737D;">// 后续获取sku的促销信息、spu的销售属性和spu详情信息（需要sku中的spuId）都需要skuInfoEntity</span></span>
<span class="line"><span style="color:#6A737D;">// supplyAsync有返回值</span></span>
<span class="line"><span style="color:#6A737D;">// runAsync无返回值</span></span>
<span class="line"><span style="color:#6A737D;">// 所以这里需要使用supplyAsync</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">SkuInfoEntity</span><span style="color:#24292E;">&gt; skuFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      Resp&lt;</span><span style="color:#D73A49;">SkuInfoEntity</span><span style="color:#24292E;">&gt; skuInfoEntityResp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.pmsFeign.</span><span style="color:#6F42C1;">querySkuById</span><span style="color:#24292E;">(skuId);</span></span>
<span class="line"><span style="color:#24292E;">      SkuInfoEntity skuInfoEntity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> skuInfoEntityResp.</span><span style="color:#6F42C1;">getData</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (skuInfoEntity </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          BeanUtils.</span><span style="color:#6F42C1;">copyProperties</span><span style="color:#24292E;">(skuInfoEntity, itemVO);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> skuInfoEntity;</span></span>
<span class="line"><span style="color:#24292E;">}, threadPoolExecutor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2. 获取sku的图片信息</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; skuImageFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">runAsync</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      Resp&lt;List&lt;</span><span style="color:#D73A49;">SkuImagesEntity</span><span style="color:#24292E;">&gt;&gt; listResp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.pmsFeign.</span><span style="color:#6F42C1;">queryImagesBySkuId</span><span style="color:#24292E;">(skuId);</span></span>
<span class="line"><span style="color:#24292E;">      List&lt;</span><span style="color:#D73A49;">SkuImagesEntity</span><span style="color:#24292E;">&gt; images </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> listResp.</span><span style="color:#6F42C1;">getData</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">CollectionUtils.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">(images)) {</span></span>
<span class="line"><span style="color:#24292E;">          List&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; imageUrls </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> images.</span><span style="color:#6F42C1;">stream</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">map</span><span style="color:#24292E;">(image </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> image.</span><span style="color:#6F42C1;">getImgUrl</span><span style="color:#24292E;">()).</span><span style="color:#6F42C1;">collect</span><span style="color:#24292E;">(Collectors.</span><span style="color:#6F42C1;">toList</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">          itemVO.</span><span style="color:#6F42C1;">setPics</span><span style="color:#24292E;">(imageUrls);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">}, threadPoolExecutor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 3. 获取sku的促销信息 TODO</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 4. 获取spu的所有销售属性</span></span>
<span class="line"><span style="color:#6A737D;">// thenAcceptAsync：有参数，无返回</span></span>
<span class="line"><span style="color:#6A737D;">// thenApplyAsync: 有参数，有返回</span></span>
<span class="line"><span style="color:#6A737D;">// 后续spu详情也需要skuInfoEntity中的spuId，所以这里使用thenApplyAsync</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">SkuInfoEntity</span><span style="color:#24292E;">&gt; spuFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> skuFuture.</span><span style="color:#6F42C1;">thenApplyAsync</span><span style="color:#24292E;">(skuInfoEntity </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      Resp&lt;List&lt;</span><span style="color:#D73A49;">SkuSaleAttrValueEntity</span><span style="color:#24292E;">&gt;&gt; skuSaleAttrValueResp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.pmsFeign.</span><span style="color:#6F42C1;">querySkuSaleAttrValueBySpuId</span><span style="color:#24292E;">(skuInfoEntity.</span><span style="color:#6F42C1;">getSpuId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">      List&lt;</span><span style="color:#D73A49;">SkuSaleAttrValueEntity</span><span style="color:#24292E;">&gt; skuSaleAttrValueEntities </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> skuSaleAttrValueResp.</span><span style="color:#6F42C1;">getData</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      itemVO.</span><span style="color:#6F42C1;">setSaleAttrs</span><span style="color:#24292E;">(skuSaleAttrValueEntities);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> skuInfoEntity;</span></span>
<span class="line"><span style="color:#24292E;">}, threadPoolExecutor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 5. 获取规格参数组及组下的规格参数 TODO</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 6. spu详情 TODO</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; future </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">allOf</span><span style="color:#24292E;">(skuFuture, skuImageFuture, spuFuture);</span></span>
<span class="line"><span style="color:#6A737D;">// 阻塞主进程，等待子进程全部执行完毕！</span></span>
<span class="line"><span style="color:#24292E;">future.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> itemVO;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// SkuInfoServiceImpl</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> SkuItemVo </span><span style="color:#B392F0;">item</span><span style="color:#E1E4E8;">(Long skuId) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#E1E4E8;">SkuItemVo skuItemVo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SkuItemVo</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">SkuInfoEntity</span><span style="color:#E1E4E8;">&gt; infoFutrue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//1 sku基本信息</span></span>
<span class="line"><span style="color:#E1E4E8;">SkuInfoEntity info </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getById</span><span style="color:#E1E4E8;">(skuId);</span></span>
<span class="line"><span style="color:#E1E4E8;">skuItemVo.</span><span style="color:#B392F0;">setInfo</span><span style="color:#E1E4E8;">(info);</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> info;</span></span>
<span class="line"><span style="color:#E1E4E8;">}, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; ImgageFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">runAsync</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//2 sku图片信息</span></span>
<span class="line"><span style="color:#E1E4E8;">List&lt;</span><span style="color:#F97583;">SkuImagesEntity</span><span style="color:#E1E4E8;">&gt; images </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> imagesService.</span><span style="color:#B392F0;">getImagesBySkuId</span><span style="color:#E1E4E8;">(skuId);</span></span>
<span class="line"><span style="color:#E1E4E8;">skuItemVo.</span><span style="color:#B392F0;">setImages</span><span style="color:#E1E4E8;">(images);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; saleAttrFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">infoFutrue.</span><span style="color:#B392F0;">thenAcceptAsync</span><span style="color:#E1E4E8;">(res </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//3 获取spu销售属性组合 list</span></span>
<span class="line"><span style="color:#E1E4E8;">List&lt;</span><span style="color:#F97583;">ItemSaleAttrVo</span><span style="color:#E1E4E8;">&gt; saleAttrVos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> skuSaleAttrValueService.</span><span style="color:#B392F0;">getSaleAttrsBuSpuId</span><span style="color:#E1E4E8;">(res.</span><span style="color:#B392F0;">getSpuId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">skuItemVo.</span><span style="color:#B392F0;">setSaleAttr</span><span style="color:#E1E4E8;">(saleAttrVos);</span></span>
<span class="line"><span style="color:#E1E4E8;">},executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; descFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> infoFutrue.</span><span style="color:#B392F0;">thenAcceptAsync</span><span style="color:#E1E4E8;">(res </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//4 获取spu介绍</span></span>
<span class="line"><span style="color:#E1E4E8;">SpuInfoDescEntity spuInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> spuInfoDescService.</span><span style="color:#B392F0;">getById</span><span style="color:#E1E4E8;">(res.</span><span style="color:#B392F0;">getSpuId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">skuItemVo.</span><span style="color:#B392F0;">setDesc</span><span style="color:#E1E4E8;">(spuInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">},executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; baseAttrFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> infoFutrue.</span><span style="color:#B392F0;">thenAcceptAsync</span><span style="color:#E1E4E8;">(res </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//5 获取spu规格参数信息</span></span>
<span class="line"><span style="color:#E1E4E8;">List&lt;</span><span style="color:#F97583;">SpuItemAttrGroup</span><span style="color:#E1E4E8;">&gt; attrGroups </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> attrGroupService.</span><span style="color:#B392F0;">getAttrGroupWithAttrsBySpuId</span><span style="color:#E1E4E8;">(res.</span><span style="color:#B392F0;">getSpuId</span><span style="color:#E1E4E8;">(), res.</span><span style="color:#B392F0;">getCatalogId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">skuItemVo.</span><span style="color:#B392F0;">setGroupAttrs</span><span style="color:#E1E4E8;">(attrGroups);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 6.查询当前sku是否参与秒杀优惠</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; secKillFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">runAsync</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">R skuSeckillInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> seckillFeignService.</span><span style="color:#B392F0;">getSkuSeckillInfo</span><span style="color:#E1E4E8;">(skuId);</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (skuSeckillInfo.</span><span style="color:#B392F0;">getCode</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      SeckillInfoVo seckillInfoVo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> skuSeckillInfo.</span><span style="color:#B392F0;">getData</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> TypeReference&lt;</span><span style="color:#F97583;">SeckillInfoVo</span><span style="color:#E1E4E8;">&gt;() {});</span></span>
<span class="line"><span style="color:#E1E4E8;">      skuItemVo.</span><span style="color:#B392F0;">setSeckillInfoVo</span><span style="color:#E1E4E8;">(seckillInfoVo);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 等待所有任务都完成再返回</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture.</span><span style="color:#B392F0;">allOf</span><span style="color:#E1E4E8;">(ImgageFuture,saleAttrFuture,descFuture,baseAttrFuture,secKillFuture).</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> skuItemVo;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// SkuInfoServiceImpl</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> SkuItemVo </span><span style="color:#6F42C1;">item</span><span style="color:#24292E;">(Long skuId) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="color:#24292E;">SkuItemVo skuItemVo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SkuItemVo</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">SkuInfoEntity</span><span style="color:#24292E;">&gt; infoFutrue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//1 sku基本信息</span></span>
<span class="line"><span style="color:#24292E;">SkuInfoEntity info </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getById</span><span style="color:#24292E;">(skuId);</span></span>
<span class="line"><span style="color:#24292E;">skuItemVo.</span><span style="color:#6F42C1;">setInfo</span><span style="color:#24292E;">(info);</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> info;</span></span>
<span class="line"><span style="color:#24292E;">}, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; ImgageFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">runAsync</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//2 sku图片信息</span></span>
<span class="line"><span style="color:#24292E;">List&lt;</span><span style="color:#D73A49;">SkuImagesEntity</span><span style="color:#24292E;">&gt; images </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> imagesService.</span><span style="color:#6F42C1;">getImagesBySkuId</span><span style="color:#24292E;">(skuId);</span></span>
<span class="line"><span style="color:#24292E;">skuItemVo.</span><span style="color:#6F42C1;">setImages</span><span style="color:#24292E;">(images);</span></span>
<span class="line"><span style="color:#24292E;">}, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; saleAttrFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">infoFutrue.</span><span style="color:#6F42C1;">thenAcceptAsync</span><span style="color:#24292E;">(res </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//3 获取spu销售属性组合 list</span></span>
<span class="line"><span style="color:#24292E;">List&lt;</span><span style="color:#D73A49;">ItemSaleAttrVo</span><span style="color:#24292E;">&gt; saleAttrVos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> skuSaleAttrValueService.</span><span style="color:#6F42C1;">getSaleAttrsBuSpuId</span><span style="color:#24292E;">(res.</span><span style="color:#6F42C1;">getSpuId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">skuItemVo.</span><span style="color:#6F42C1;">setSaleAttr</span><span style="color:#24292E;">(saleAttrVos);</span></span>
<span class="line"><span style="color:#24292E;">},executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; descFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> infoFutrue.</span><span style="color:#6F42C1;">thenAcceptAsync</span><span style="color:#24292E;">(res </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//4 获取spu介绍</span></span>
<span class="line"><span style="color:#24292E;">SpuInfoDescEntity spuInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> spuInfoDescService.</span><span style="color:#6F42C1;">getById</span><span style="color:#24292E;">(res.</span><span style="color:#6F42C1;">getSpuId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">skuItemVo.</span><span style="color:#6F42C1;">setDesc</span><span style="color:#24292E;">(spuInfo);</span></span>
<span class="line"><span style="color:#24292E;">},executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; baseAttrFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> infoFutrue.</span><span style="color:#6F42C1;">thenAcceptAsync</span><span style="color:#24292E;">(res </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">//5 获取spu规格参数信息</span></span>
<span class="line"><span style="color:#24292E;">List&lt;</span><span style="color:#D73A49;">SpuItemAttrGroup</span><span style="color:#24292E;">&gt; attrGroups </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> attrGroupService.</span><span style="color:#6F42C1;">getAttrGroupWithAttrsBySpuId</span><span style="color:#24292E;">(res.</span><span style="color:#6F42C1;">getSpuId</span><span style="color:#24292E;">(), res.</span><span style="color:#6F42C1;">getCatalogId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">skuItemVo.</span><span style="color:#6F42C1;">setGroupAttrs</span><span style="color:#24292E;">(attrGroups);</span></span>
<span class="line"><span style="color:#24292E;">}, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 6.查询当前sku是否参与秒杀优惠</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; secKillFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">runAsync</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">R skuSeckillInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> seckillFeignService.</span><span style="color:#6F42C1;">getSkuSeckillInfo</span><span style="color:#24292E;">(skuId);</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (skuSeckillInfo.</span><span style="color:#6F42C1;">getCode</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      SeckillInfoVo seckillInfoVo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> skuSeckillInfo.</span><span style="color:#6F42C1;">getData</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> TypeReference&lt;</span><span style="color:#D73A49;">SeckillInfoVo</span><span style="color:#24292E;">&gt;() {});</span></span>
<span class="line"><span style="color:#24292E;">      skuItemVo.</span><span style="color:#6F42C1;">setSeckillInfoVo</span><span style="color:#24292E;">(seckillInfoVo);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 等待所有任务都完成再返回</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture.</span><span style="color:#6F42C1;">allOf</span><span style="color:#24292E;">(ImgageFuture,saleAttrFuture,descFuture,baseAttrFuture,secKillFuture).</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> skuItemVo;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>线程池参数：</p><ul><li>20-50核心线程，200最大线程，1W长度等待队列</li></ul></blockquote>`,445),N=[I];function L(O,j,R,P,U,W){return n(),a("div",null,N)}const _=s(T,[["render",L]]);export{V as __pageData,_ as default};
