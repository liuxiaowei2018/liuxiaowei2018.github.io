import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.8048b864.js";const p="/assets/image-20220115210347900.e1ab1017.png",u=JSON.parse('{"title":"SpringCloudStream","description":"","frontmatter":{},"headers":[],"relativePath":"second/cloud/springCloudStream.md","filePath":"second/cloud/springCloudStream.md","lastUpdated":1682323688000}'),o={name:"second/cloud/springCloudStream.md"},e=l('<h1 id="springcloudstream" tabindex="-1">SpringCloudStream <a class="header-anchor" href="#springcloudstream" aria-label="Permalink to &quot;SpringCloudStream&quot;">​</a></h1><nav class="table-of-contents"><ul></ul></nav><p><img src="'+p+`" alt="image-20220115210347900"></p><p><a href="https://github.com/spring-cloud/spring-cloud-stream" target="_blank" rel="noreferrer">Spring Cloud Stream</a> 是一个用于构建基于<strong>消息</strong>的微服务应用框架，使用 <a href="https://www.oschina.net/p/spring+integration" target="_blank" rel="noreferrer">Spring Integration</a> 与 Broker 进行连接。</p><p>Spring Cloud Stream 提供了消息中间件的<strong>统一抽象</strong>，推出了 publish-subscribe、consumer groups、partition 这些统一的概念。</p><p>Spring Cloud Stream 内部有两个概念：<strong>Binder</strong> 和 <strong>Binding</strong>。</p><p>① <strong><a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/binder/Binder.java" target="_blank" rel="noreferrer">Binder</a></strong>，跟消息中间件集成的组件，用来创建对应的 Binding。各消息中间件都有自己的 Binder 具体实现。</p><ul><li>Kafka 实现了 <a href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka/blob/master/spring-cloud-stream-binder-kafka/src/main/java/org/springframework/cloud/stream/binder/kafka/KafkaMessageChannelBinder.java" target="_blank" rel="noreferrer">KafkaMessageChannelBinder</a></li><li>RabbitMQ 实现了 <a href="https://github.com/spring-cloud/spring-cloud-stream-binder-rabbit/blob/master/spring-cloud-stream-binder-rabbit/src/main/java/org/springframework/cloud/stream/binder/rabbit/RabbitMessageChannelBinder.java" target="_blank" rel="noreferrer">RabbitMessageChannelBinder</a></li><li>RocketMQ 实现了 <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-stream-binder-rocketmq/src/main/java/com/alibaba/cloud/stream/binder/rocketmq/RocketMQMessageChannelBinder.java" target="_blank" rel="noreferrer">RocketMQMessageChannelBinder</a></li></ul><p>② <strong><a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/binder/Binding.java" target="_blank" rel="noreferrer">Binding</a></strong>，包括 Input Binding 和 Output Binding。Binding 在消息中间件与应用程序提供的 Provider 和 Consumer 之间提供了一个桥梁，实现了开发者只需使用应用程序的 Provider 或 Consumer 生产或消费数据即可，屏蔽了开发者与底层消息中间件的接触。</p><h4 id="整合-rabbitmq" tabindex="-1">整合 RabbitMQ <a class="header-anchor" href="#整合-rabbitmq" aria-label="Permalink to &quot;整合 RabbitMQ&quot;">​</a></h4><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">&lt;!-- Spring Cloud Stream RabbitMQ --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">dependency</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt;org.springframework.cloud&lt;/</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt;spring-cloud-starter-stream-rabbit&lt;/</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">dependency</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">&lt;!-- Spring Cloud Stream RabbitMQ --&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">dependency</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">groupId</span><span style="color:#24292E;">&gt;org.springframework.cloud&lt;/</span><span style="color:#22863A;">groupId</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">artifactId</span><span style="color:#24292E;">&gt;spring-cloud-starter-stream-rabbit&lt;/</span><span style="color:#22863A;">artifactId</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">dependency</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>配置</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#85E89D;">spring</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#85E89D;">rabbitmq</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">host</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">127.0.0.1</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#85E89D;">cloud</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">stream</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#85E89D;">binders</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#85E89D;">defaultRabbit</span><span style="color:#E1E4E8;">: </span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#85E89D;">type</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">rabbit</span></span>
<span class="line"><span style="color:#6A737D;"># 服务的整合处理</span></span>
<span class="line"><span style="color:#85E89D;">bindings</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#6A737D;"># 这个名字是一个通道的名称,可以自由定义，不一定要和生产者的相同，但必须要与通道接口中定义的通道名称一致</span></span>
<span class="line"><span style="color:#85E89D;">XXX</span><span style="color:#E1E4E8;">: </span></span>
<span class="line"><span style="color:#6A737D;"># 表示要使用的Exchange名称定义，可自由定义，但必须与生产的一致，否则无法读取到生产者发送的消息</span></span>
<span class="line"><span style="color:#85E89D;">destination</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">XXX</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#6A737D;"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span></span>
<span class="line"><span style="color:#85E89D;">content-type</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">application/json</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#6A737D;"># 进行操作的分组，进行持久化通道，消费者挂掉后，通道依旧保持，等消费启动后可继续消费通道内的队列</span></span>
<span class="line"><span style="color:#85E89D;">group</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">XXX</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#22863A;">spring</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#22863A;">rabbitmq</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">host</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">127.0.0.1</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#22863A;">cloud</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">stream</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#22863A;">binders</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#22863A;">defaultRabbit</span><span style="color:#24292E;">: </span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#22863A;">type</span><span style="color:#24292E;">: </span><span style="color:#032F62;">rabbit</span></span>
<span class="line"><span style="color:#6A737D;"># 服务的整合处理</span></span>
<span class="line"><span style="color:#22863A;">bindings</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#6A737D;"># 这个名字是一个通道的名称,可以自由定义，不一定要和生产者的相同，但必须要与通道接口中定义的通道名称一致</span></span>
<span class="line"><span style="color:#22863A;">XXX</span><span style="color:#24292E;">: </span></span>
<span class="line"><span style="color:#6A737D;"># 表示要使用的Exchange名称定义，可自由定义，但必须与生产的一致，否则无法读取到生产者发送的消息</span></span>
<span class="line"><span style="color:#22863A;">destination</span><span style="color:#24292E;">: </span><span style="color:#032F62;">XXX</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#6A737D;"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span></span>
<span class="line"><span style="color:#22863A;">content-type</span><span style="color:#24292E;">: </span><span style="color:#032F62;">application/json</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#6A737D;"># 进行操作的分组，进行持久化通道，消费者挂掉后，通道依旧保持，等消费启动后可继续消费通道内的队列</span></span>
<span class="line"><span style="color:#22863A;">group</span><span style="color:#24292E;">: </span><span style="color:#032F62;">XXX</span></span></code></pre></div>`,13),r=[e];function t(c,i,E,d,y,g){return a(),n("div",null,r)}const m=s(o,[["render",t]]);export{u as __pageData,m as default};
