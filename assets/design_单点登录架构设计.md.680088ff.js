import{_ as a,c as o,o as s,N as e}from"./chunks/framework.0799945b.js";const t="/assets/image-20220411233744044.2dd19f42.png",n="/assets/image-20220411233815797.b7e4a6c0.png",l="/assets/395633d95898d3ab8ae6106c8ee3c4b0_1234x1102.a752e852.png",r="/assets/4e9f23d0d9c0f90f6c86f9e72732db8b_2290x738.aa9cfa48.png",c="/assets/6c8fea3d0d037a81b92946eb5e91353e_812x563.846bf21c.png",p="/assets/bd1e657768dc1708a644b9e3290cd6f0_718x535.7975035a.png",i="/assets/85ac799fc96adf31449bc4a1a4a40dd4_1732x248.403765e9.png",d="/assets/85ac799fc96adf31449bc4a1a4a40dd4_1732x248.403765e9.png",g="/assets/64e37ca80e6dfddad09c33af856ff981_1845x423.1382db3d.png",h="/assets/e79dacd7fd6709139369d3a883e2b321_906x826.4eeeaade.png",u="/assets/d9c5858daf543afab340d64bc2ea4aa3_1184x1313.57d39d0d.png",y="/assets/6ff622c2bceb8f9265ad668af24eeb4b_1168x143.9f361a4e.png",S=JSON.parse('{"title":"架构设计","description":"","frontmatter":{},"headers":[],"relativePath":"design/单点登录架构设计.md"}'),A={name:"design/单点登录架构设计.md"},b=e('<h1 id="架构设计" tabindex="-1">架构设计 <a class="header-anchor" href="#架构设计" aria-label="Permalink to &quot;架构设计&quot;">​</a></h1><h2 id="单点登录架构设计" tabindex="-1">单点登录架构设计 <a class="header-anchor" href="#单点登录架构设计" aria-label="Permalink to &quot;单点登录架构设计&quot;">​</a></h2><h3 id="原理篇" tabindex="-1">原理篇 <a class="header-anchor" href="#原理篇" aria-label="Permalink to &quot;原理篇&quot;">​</a></h3><p>SSO单点登录是基于共享<code>uaa授权中心</code>的<code>cookie</code>来实现的，大概流程如下：</p><ol><li>当<strong>系统1</strong>登录成功后</li><li><strong>uaa授权中心</strong>里面会保存了<strong>系统1</strong>中的登录信息建立全局会话，并把自己的cookie写到用户的浏览器中</li><li>当同一个浏览器访问<strong>系统2</strong>时，当跳转到<strong>uaa授权中心</strong>授权时会把浏览器中<code>uaa</code>的<code>cookie</code>也带过去</li><li><strong>uaa授权中心</strong>根据自己的<code>cookie</code>判断该浏览器的用户已经登录过，则自动登录完成<strong>单点登录</strong></li></ol><p><img src="'+t+'" alt="image-20220411233744044"></p><p><strong>架构图</strong></p><p><img src="'+n+'" alt="image-20220411233815797"></p><h4 id="oauth-2-0-四种授权模式" tabindex="-1">OAuth 2.0 四种授权模式 <a class="header-anchor" href="#oauth-2-0-四种授权模式" aria-label="Permalink to &quot;OAuth 2.0 四种授权模式&quot;">​</a></h4><ul><li><strong>Authorization Code:</strong> 用服务端应用之间，这种最安全也最复杂</li><li><strong>Implicit:</strong> 用在移动app或者web app(这些app是在用户的设备上的，如在手机上调起微信来进行认证授权)</li><li><strong>Resource Owner Password Credentials(password):</strong> 应用直接都是受信任的(都是由一家公司开发的)</li><li><strong>Client Credentials:</strong> 用在应用间API访问</li></ul><h4 id="单点时序图" tabindex="-1">单点时序图 <a class="header-anchor" href="#单点时序图" aria-label="Permalink to &quot;单点时序图&quot;">​</a></h4><p><img src="'+l+'" alt="img"></p><h4 id="单点登录的请求步骤" tabindex="-1">单点登录的请求步骤 <a class="header-anchor" href="#单点登录的请求步骤" aria-label="Permalink to &quot;单点登录的请求步骤&quot;">​</a></h4><p>下图是访问<code>sso-demo</code>的地址 <a href="http://127.0.0.1:8080/" target="_blank" rel="noreferrer">http://127.0.0.1:8080</a> 时<code>@EnableOAuth2Sso</code>注解与<code>UAA授权中心</code>通过<code>Oauth2授权码模式</code>交互完成单点登录的步骤</p><p><img src="'+r+'" alt="img"></p><h3 id="应用篇" tabindex="-1">应用篇 <a class="header-anchor" href="#应用篇" aria-label="Permalink to &quot;应用篇&quot;">​</a></h3><h4 id="基于spring-security实现" tabindex="-1">基于Spring Security实现 <a class="header-anchor" href="#基于spring-security实现" aria-label="Permalink to &quot;基于Spring Security实现&quot;">​</a></h4><p><img src="'+c+'" alt="img"></p><p>最简单的方式就是使用<code>Spring Security</code>的<code>@EnableOAuth2Sso注解</code>，该注解会自动添加一个认证过滤器，自动完成<code>授权码模式</code>的oauth2授权流程</p><blockquote><p>如果不是使用<code>Spring Security</code>框架或者不想用<code>授权码模式</code>怎么办？</p><p><img src="'+p+'" alt="img"></p><p><strong>security.oauth2.sso.login-path</strong>：设置回调地址(默认是/login)</p></blockquote><h5 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h5><h6 id="授权类型" tabindex="-1">授权类型 <a class="header-anchor" href="#授权类型" aria-label="Permalink to &quot;授权类型&quot;">​</a></h6><p><img src="'+i+'" alt="img"></p><p>应用的授权类型需要支持<code>授权码模式</code>参考上图#2位置，应用的<code>authorized_grant_types</code>字段需要支持授权码模式</p><h6 id="回调地址" tabindex="-1">回调地址 <a class="header-anchor" href="#回调地址" aria-label="Permalink to &quot;回调地址&quot;">​</a></h6><p><img src="'+d+'" alt="img"></p><p>回调地址必需与应用配置的地址一致，参考上图的#3位置，可以通过<code>security.oauth2.sso.login-path</code>配置指定回调地址，否则会出现一下错误</p><p><img src="'+g+'" alt="img"></p><h6 id="单点的系统间访问uaa的域名必需一致" tabindex="-1">单点的系统间访问uaa的域名必需一致 <a class="header-anchor" href="#单点的系统间访问uaa的域名必需一致" aria-label="Permalink to &quot;单点的系统间访问uaa的域名必需一致&quot;">​</a></h6><p>由于原理是共享<code>uaa授权中心</code>的<code>cookie</code>，首先需要使用同一个浏览器访问，并且不同系统跳转uaa时所使用的域名必需一致才能<code>共享cookie</code></p><blockquote><p>一个用域名访问uaa另一个用ip访问uaa不行 一个用<code>localhost</code>访问uaa另一个用<code>127.0.0.1</code>访问uaa也不行</p></blockquote><h4 id="前后端分离" tabindex="-1">前后端分离 <a class="header-anchor" href="#前后端分离" aria-label="Permalink to &quot;前后端分离&quot;">​</a></h4><blockquote><p><strong>前后端分离</strong>的核心概念是后端仅返回前端所需的数据，不再渲染HTML页面</p><p>前端HTML页面通过AJAX调用后端的RESTFUL API接口并使用JSON数据进行交互</p></blockquote><p><strong>跨域</strong>间的<strong>前后端分离</strong>项目也是基于共享统一授权服务(UAA)的<strong>cookie</strong>来实现<strong>单点登录</strong>的，但是与<strong>非前后分离</strong>不一样的是存在以下问题需要解决</p><ol><li>没有过滤器/拦截器，需要在前端判断登录状态</li><li>需要自己实现<strong>oauth2</strong>的<strong>授权码模式</strong>交互逻辑</li><li>需要解决安全性问题，<strong>oauth2</strong>的<strong>clientSecret</strong>参数放在前端不安全</li></ol><p>下面是<strong>前后端分离</strong>项目的三个角色(前端WEB工程、后端API工程、授权中心UAA)间进行<strong>登录</strong>/<strong>单点登录</strong>时的交互逻辑架构图</p><p><img src="'+h+'" alt="img"></p><blockquote><p>前端WEB工程有几个点需要注意：</p><ol><li><strong>红色线条</strong>为重定向跳转</li><li><strong>前端工程</strong>可通过是否存在 <code>access_token</code> 判断登录状态</li><li><strong>前端工程</strong>跳转<strong>UAA</strong>之前需记录用户访问的页面地址，方便登录完成后重定向回去</li></ol><p><strong>PS</strong>：为什么<strong>获取access_token</strong>需要请求后端API工程去完成，而不是前端WEB工程自己直接请求UAA呢？因为<strong>安全性问题</strong>！这一步需要传<strong>clientSecret</strong>参数，而通过后台来配置这个参数就不需要暴露给前端了。</p></blockquote><p><img src="'+u+'" alt="img"></p><p>当授权中心自定义登录页面的时候注意以下两点：</p><ol><li>为了能正确获取session，<strong>登录页面的访问地址</strong> 需与UAA服务保持一致，前后端分离可以使用nginx来统一地址。</li><li>由于登录成功之后UAA会自动根据client配置地址来重定向，所以登录请求不能使用ajax来提交，只能使用form表单提交。</li></ol><h3 id="扩展篇" tabindex="-1">扩展篇 <a class="header-anchor" href="#扩展篇" aria-label="Permalink to &quot;扩展篇&quot;">​</a></h3><h4 id="单点登出" tabindex="-1">单点登出 <a class="header-anchor" href="#单点登出" aria-label="Permalink to &quot;单点登出&quot;">​</a></h4><blockquote><p><strong>单点登出</strong> 意思是指多个系统在实现单点登录之后，当其中一个系统登出之后，其他系统也同时登出。</p></blockquote><p>在基于 <code>OAuth2.0</code> 的单点登录系统，在实现单点登出时通常存在以下 <strong>痛点</strong>：</p><ol><li>每个单点的系统所分配的 <code>access_token</code> 都不一样，某个系统登出只是注销当前系统的 token 而其他系统的 token 还是有效的。</li><li>某些系统在单点登录之后就自己维护用户状态了，不再使用该 token 去检验有效性了。</li></ol><h5 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h5><h6 id="废除用户token" tabindex="-1">废除用户token <a class="header-anchor" href="#废除用户token" aria-label="Permalink to &quot;废除用户token&quot;">​</a></h6><p>通过 Spring Security 的 <code>TokenStore</code> 接口的以下方法：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Collection&lt;OAuth2AccessToken&gt; findTokensByClientIdAndUserName(String clientId, String userName);</span></span></code></pre></div><p>该方法除了用户名之外还需要传入 <code>clientId</code> 参数，所以我们在登出成功之后，遍历所有的应用，通过上面的方法就可以把与该用户关联的所有 <code>access_token</code> 查询出来。</p><p>最后使用 Spring Security 的 <code>DefaultTokenServices</code> 的以下方法 <strong>废除</strong> token：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">public boolean revokeToken(String tokenValue)</span></span></code></pre></div><h6 id="登出通知" tabindex="-1">登出通知 <a class="header-anchor" href="#登出通知" aria-label="Permalink to &quot;登出通知&quot;">​</a></h6><ol><li>各个系统通过定时任务来定时检查 <code>access_token</code> 的有效性，如果发现 token 失效则删除本系统维护的用户状态。</li><li>某个系统登出时，由认证中心来统一通知其他系统，其他系统收到通知后各自删除本系统维护的用户状态。</li></ol><blockquote><p>两个思路本质上一个是 <strong>拉</strong> 一个是 <strong>推</strong></p><p>由于登出是一个低频的操作，为了这个而每个系统都定时去认证中心拉取token状态这样做是不太划算的，所以比较推荐第二个思路。</p></blockquote><p>关于统一通知，需要维护一个通知地址的清单，这个直接在 <code>OAuth2.0</code> 的应用管理表 <code>oauth_client_details</code> 里面维护是比较适合的。</p><p>需要新增字段，Spring Security 在表中预留了扩展字段 <code>additional_information</code> 我们直接在这里添加即可。</p><p><img src="'+y+`" alt="img"></p><p>additional_information 字段是一个JSON对象，如上图所示使用 <code>LOGOUT_NOTIFY_URL_LIST</code> 字段来维护地址清单，多个以 <code>,</code> 隔开。</p><h4 id="jks密钥生成" tabindex="-1">jks密钥生成 <a class="header-anchor" href="#jks密钥生成" aria-label="Permalink to &quot;jks密钥生成&quot;">​</a></h4><blockquote><p>生成jks私钥 keytool -genkey -alias ringnex -keyalg RSA -storetype PKCS12 -keysize 1024 -keystore ringnex.jks 生成公钥 keytool -list -rfc -keystore ringnex.jks -storepass ringnex | openssl x509 -inform pem -pubkey</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Test</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">test</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> jwtToken </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoiYWJjIiwidXNlcl9uYW1lIjoiYWRtaW4iLCJzY29wZSI6WyJhcHAiXSwiZXhwIjoxNTYzNjgyMTI4LCJhdXRob3JpdGllcyI6WyJBRE1JTiJdLCJqdGkiOiJlMDFlNGU0Yi1hZDVkLTRlMTQtODhiMC00OGQ4YzBjN2U5YjkiLCJjbGllbnRfaWQiOiJ3ZWJBcHAifQ.Qrh2aEoN4TL_WIQ9UpxDrW12aqqoVqxeY826sjbea2LB24RBNDYQl1J5vwXzMaQlG9AgjHRL4bTQihwBYYfdL-VuJXx0_l0xONbz9sHPq60a3gAhxOnekNS5-Qet5feTw7j4o2OwNlxo-xty5s8u2lsQY21zCe0tes_T4XeM76JTBpRbQUFGUU3EKxtUFi3Nk9AII4zerW1AbQNvLo4YW2Wvj___0lq5a-xNdCcHlJid8vKgzEF3v3wECOv6OjgL-fUN8VpUsYVt1-_QZp8opPAf-t3OVTtrVIWrJZ_vWV9d6DN5mynKtZ7_mDyMwo_5w3roAZ0ahoBKPKrtYQyEwQ</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">JsonNode</span><span style="color:#A6ACCD;"> claims </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> JwtUtils</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">decodeAndVerify</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">jwtToken</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//token内容</span></span>
<span class="line"><span style="color:#A6ACCD;">  System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">claims</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> isValid </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> JwtUtils</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">checkExp</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">claims</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//是否有效</span></span>
<span class="line"><span style="color:#A6ACCD;">  System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">isValid</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></blockquote><h5 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h5>`,63),k=[b];function _(m,D,C,f,F,q){return s(),o("div",null,k)}const P=a(A,[["render",_]]);export{S as __pageData,P as default};
