import{_ as e,c as a,o as i,N as r}from"./chunks/framework.0799945b.js";const t="/assets/640.5d529f7a.webp",l="/assets/640-16397125997272.392eb719.webp",o="/assets/640-16397126133914.68976135.webp",s="/assets/640-16397126371816.ce88ade6.webp",f=JSON.parse('{"title":"K8s","description":"","frontmatter":{},"headers":[],"relativePath":"study/container/k8s.md"}'),n={name:"study/container/k8s.md"},c=r('<h1 id="k8s" tabindex="-1">K8s <a class="header-anchor" href="#k8s" aria-label="Permalink to &quot;K8s&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#简介">简介</a></li><li><a href="#minikube">Minikube</a></li><li><a href="#kubernetes核心概念">Kubernetes核心概念</a><ul><li><a href="#node">Node</a></li><li><a href="#deployment">Deployment</a></li><li><a href="#pod">Pod</a></li><li><a href="#service">Service</a></li></ul></li><li><a href="#k8s安装">k8s安装</a></li><li><a href="#docker安装">Docker安装</a></li></ul></nav><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>Kubernetes用于自动部署，扩展和管理容器化应用程序的开源系统。它将组成应用程序的容器组合成逻辑单元，以便于管理和服务发现。</p><p>Kubernetes具有如下特性：</p><ul><li>服务发现与负载均衡：无需修改你的应用程序即可使用陌生的服务发现机制。</li><li>存储编排：自动挂载所选存储系统，包括本地存储。</li><li>Secret和配置管理：部署更新Secrets和应用程序的配置时不必重新构建容器镜像，且不必将软件堆栈配置中的秘密信息暴露出来。</li><li>批量执行：除了服务之外，Kubernetes还可以管理你的批处理和CI工作负载，在期望时替换掉失效的容器。</li><li>水平扩缩：使用一个简单的命令、一个UI或基于CPU使用情况自动对应用程序进行扩缩。</li><li>自动化上线和回滚：Kubernetes会分步骤地将针对应用或其配置的更改上线，同时监视应用程序运行状况以确保你不会同时终止所有实例。</li><li>自动装箱：根据资源需求和其他约束自动放置容器，同时避免影响可用性。</li><li>自我修复：重新启动失败的容器，在节点死亡时替换并重新调度容器，杀死不响应用户定义的健康检查的容器。</li></ul><h2 id="minikube" tabindex="-1">Minikube <a class="header-anchor" href="#minikube" aria-label="Permalink to &quot;Minikube&quot;">​</a></h2><p>Minikube是一种轻量级的Kubernetes实现，可在本地计算机上创建VM并部署仅包含一个节点的简单集群，Minikube可用于Linux、MacOS和Windows系统。Minikube CLI提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h2 id="kubernetes核心概念" tabindex="-1">Kubernetes核心概念 <a class="header-anchor" href="#kubernetes核心概念" aria-label="Permalink to &quot;Kubernetes核心概念&quot;">​</a></h2><h3 id="node" tabindex="-1">Node <a class="header-anchor" href="#node" aria-label="Permalink to &quot;Node&quot;">​</a></h3><p>Kubernetes集群是指Kubernetes协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。</p><p>一个Kubernetes集群包含两种类型的资源：</p><ul><li>Master：负责管理整个集群。协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</li><li>Node：用于托管正在运行的应用。可以是一个虚拟机或者物理机，它在Kubernetes集群中充当工作机器的角色，每个Node都有Kubelet，它管理Node而且是Node与Master通信的代理，Node还具有用于处理容器操作的工具，例如Docker或rkt。</li></ul><p><img src="'+t+'" alt="图片"></p><h3 id="deployment" tabindex="-1">Deployment <a class="header-anchor" href="#deployment" aria-label="Permalink to &quot;Deployment&quot;">​</a></h3><p>Deployment负责创建和更新应用程序的实例。创建Deployment后，Kubernetes Master 将应用程序实例调度到集群中的各个节点上。如果托管实例的节点关闭或被删除，Deployment控制器会将该实例替换为群集中另一个节点上的实例。这提供了一种自我修复机制来解决机器故障维护问题。</p><p>可以使用Kubernetes命令行界面Kubectl创建和管理Deployment。Kubectl使用Kubernetes API与集群进行交互。</p><p><img src="'+l+'" alt="图片"></p><h3 id="pod" tabindex="-1">Pod <a class="header-anchor" href="#pod" aria-label="Permalink to &quot;Pod&quot;">​</a></h3><p>Pod相当于<code>逻辑主机</code>的概念，负责托管应用实例。包括一个或多个应用程序容器（如 Docker），以及这些容器的一些共享资源（共享存储、网络、运行信息等）。</p><p><img src="'+o+'" alt="图片"></p><h3 id="service" tabindex="-1">Service <a class="header-anchor" href="#service" aria-label="Permalink to &quot;Service&quot;">​</a></h3><p>Service是一个抽象层，它定义了一组Pod的逻辑集，并为这些Pod支持外部流量暴露、负载平衡和服务发现。</p><p>尽管每个Pod 都有一个唯一的IP地址，但是如果没有Service，这些IP不会暴露在群集外部。Service允许您的应用程序接收流量。Service也可以用在ServiceSpec标记type的方式暴露，type类型如下：</p><ul><li>ClusterIP（默认）：在集群的内部IP上公开Service。这种类型使得Service只能从集群内访问。</li><li>NodePort：使用NAT在集群中每个选定Node的相同端口上公开Service。使用<code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>从集群外部访问Service。是ClusterIP的超集。</li><li>LoadBalancer：在当前云中创建一个外部负载均衡器(如果支持的话)，并为Service分配一个固定的外部IP。是NodePort的超集。</li><li>ExternalName：通过返回带有该名称的CNAME记录，使用任意名称（由spec中的externalName指定）公开Service。不使用代理。</li></ul><p><img src="'+s+'" alt="图片"></p><h2 id="k8s安装" tabindex="-1">k8s安装 <a class="header-anchor" href="#k8s安装" aria-label="Permalink to &quot;k8s安装&quot;">​</a></h2><h2 id="docker安装" tabindex="-1">Docker安装 <a class="header-anchor" href="#docker安装" aria-label="Permalink to &quot;Docker安装&quot;">​</a></h2>',28),d=[c];function u(h,p,b,k,m,_){return i(),a("div",null,d)}const S=e(n,[["render",u]]);export{f as __pageData,S as default};
