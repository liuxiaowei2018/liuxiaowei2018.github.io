import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.8048b864.js";const h=JSON.parse('{"title":"Pulsar","description":"","frontmatter":{},"headers":[],"relativePath":"中间件/消息中间件/pulsar.md","filePath":"中间件/消息中间件/pulsar.md","lastUpdated":1718873649000}'),o={name:"中间件/消息中间件/pulsar.md"},e=l(`<h1 id="pulsar" tabindex="-1">Pulsar <a class="header-anchor" href="#pulsar" aria-label="Permalink to &quot;Pulsar&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#组件">组件</a></li><li><a href="#架构">架构</a></li><li><a href="#核心概念">核心概念</a></li></ul></nav><h3 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-label="Permalink to &quot;组件&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301653462.png" alt="image-20230629144107222"></p><p>在一个Pulsar集群中：</p><p>单个Pulsar集群由以下三部分组成：</p><ul><li><code>Broker</code>：无状态服务层，负责接收和传递消息，集群负载均衡等工作，Broker 不会持久化保存元数据，因此可以快速的上、下线。</li><li><code>BookKeeper</code>：有状态持久层，由一组名为 Bookie 的存储节点组成，持久化地存储消息。</li><li><code>zookeeper</code>集群，用来处理Pulsar集群之间的协调任务，并存储broker和bookie的元数据。</li></ul><p>与传统的消息系统相比，Apache Pulsar 在架构设计上采用了计算与存储分离的模式，Pub/Sub 相关的计算逻辑在 Broker 上完成，数据存储在 Apache BookKeeper 的 Bookie 节点上。</p><h4 id="brokers" tabindex="-1">Brokers <a class="header-anchor" href="#brokers" aria-label="Permalink to &quot;Brokers&quot;">​</a></h4><p>Pulsar的broker是一个<strong>无状态组件</strong>, 主要由两个组件组成:</p><ul><li>一个HTTP服务器 <code>service discovery</code>，提供REST API用于管理任务和生产者、消费者的主题查找。生产者连接到代理以发布消息，消费者连接到代理以消费消息。</li><li>一个调度程序 <code>dispatcher</code>，它是一个基于自定义二进制协议的异步TCP服务器，用于所有数据传输。</li></ul><p>消息通常从<code>Managed Ledger</code>缓存中读取，除非读取的数据超过缓存大小，则从BookKeeper那里读取<code>Entries</code>(Entry是BookKeeper中的一条记录)</p><p>为了支持全局Topic异地复制，Broker会控制Replicators追踪本地发布的Entries，并把这些Entries用Java客户端重新发布到其他区域.</p><h4 id="zookeeper" tabindex="-1">Zookeeper <a class="header-anchor" href="#zookeeper" aria-label="Permalink to &quot;Zookeeper&quot;">​</a></h4><p>Pulsar使用<code>Apache ZooKeeper</code>来进行元数据存储、集群配置和协调。元数据包括主题元数据、模式（schema）、代理负载数据等。Pulsar元数据存储可以部署在单独的ZooKeeper集群上，也可以部署在现有的ZooKeeper集群上。</p><p>Pulsar还支持其他元数据后端服务，包括etcd和RocksDB（仅适用于独立部署的Pulsar）。</p><p>在一个Pulsar实例中：</p><ul><li>配置存储: 存储租户，命名域和其他需要全局一致的配置项</li><li>每个集群有自己独立的ZooKeeper保存集群内部配置和协调信息，例如归属信息、broker负载报告、BookKeeper ledger信息</li></ul><h4 id="bookeeper" tabindex="-1">Bookeeper <a class="header-anchor" href="#bookeeper" aria-label="Permalink to &quot;Bookeeper&quot;">​</a></h4><p>Pulsar使用一个名为Apache BookKeeper的系统来进行持久消息存储。BookKeeper是一个<strong>分布式的预写日志</strong>（Write-Ahead Log，WAL）系统，为Pulsar提供了一些重要的优势：</p><ul><li>独立的分布式日志文件，称为账本（<code>ledgers</code>）。可以随着时间的推移为主题创建多个账本。</li><li>非常高效的<strong>有序存储</strong>，在各种系统故障的情况下，可以处理<code>entry</code>（条目）数据复制。</li><li>读取一致性。</li><li>均匀分配I/O。</li><li><strong>水平可扩展性</strong>。通过向集群添加更多的书记（bookie），可以立即增加容量。</li><li>Bookies被设计成可以承载数千的并发读写的ledgers，且读写IO分离。 使用多个磁盘设备(一个用于日志，另一个用于一般存储))，这样Bookies<strong>可以将读操作的影响和对于写操作的延迟分隔开</strong>。</li><li>除了消息数据，游标（Cursors）也被持久地存储在BookKeeper中。游标是消费者的订阅位置。BookKeeper使得Pulsar能够以可扩展的方式存储消费者的位置。</li></ul><h5 id="ledgers" tabindex="-1">ledgers <a class="header-anchor" href="#ledgers" aria-label="Permalink to &quot;ledgers&quot;">​</a></h5><p>账本（Ledger）是一种只追加的数据结构，单进程写入，分配给多个BookKeeper存储节点（也称为bookie）。<code>Ledger entries</code>被复制到多个bookie上。Ledger本身具有非常简单的语义：</p><ul><li>Pulsar代理可以创建Ledger，向账本追加entry，并关闭账本。</li><li>在Ledger关闭后（无论是显式关闭还是因写入进程崩溃），只能以只读模式打开Ledger。</li><li>当ledger中的Entry不再有用的时候，可以将整个账本从系统中删除（跨所有bookie）。</li></ul><h5 id="managed-ledgers" tabindex="-1">Managed ledgers <a class="header-anchor" href="#managed-ledgers" aria-label="Permalink to &quot;Managed ledgers&quot;">​</a></h5><p>由于BookKeeper ledgers 提供了统一的日志抽象，因此在ledgers之上开发了一个名为<code>managed ledger</code>的库，它代表单个主题的存储层。一个managed ledger代表了一个消息流的抽象，其中包含一个单一的写入者在流的末尾追加消息，以及多个消费者游标，每个游标都有其关联的位置。</p><p>在内部，单个managed ledger使用多个ledgers来存储数据。有两个原因使用多个账本：</p><ul><li>在发生故障后，一个ledger将无法继续写入，需要创建一个新的ledger。</li><li>当所有的游标都消费完ledger中的消息时，可以删除ledger。这允许定期对ledger进行切换。</li></ul><h5 id="journal-storage" tabindex="-1">Journal storage <a class="header-anchor" href="#journal-storage" aria-label="Permalink to &quot;Journal storage&quot;">​</a></h5><p>在BookKeeper中，<code>journal</code>文件包含了BookKeeper的事务日志。在对ledger进行更新之前，bookie需要确保描述该更新的事务被写入持久（非易失性）存储中。一旦bookie启动或者旧的日志文件达到了日志文件大小阈值（通过<code>journalMaxSizeMB</code>参数进行配置），就会创建一个新的<code>journal</code>文件。</p><h4 id="pulsar-proxy" tabindex="-1">Pulsar Proxy <a class="header-anchor" href="#pulsar-proxy" aria-label="Permalink to &quot;Pulsar Proxy&quot;">​</a></h4><p>Pulsar客户端和Pulsar集群交互的一种方式就是直连Pulsar brokers。有时这种直连既不可行也不可取，因为客户端并不知道broker的地址</p><p>Pulsar proxy为所有的broker提供了一个网关, 如果选择运行了Pulsar Proxy，所有的客户都会通过这个代理而不是直接与brokers通信</p><h3 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to &quot;架构&quot;">​</a></h3><h4 id="分片存储" tabindex="-1">分片存储 <a class="header-anchor" href="#分片存储" aria-label="Permalink to &quot;分片存储&quot;">​</a></h4><p>除了存储、计算解耦分离的设计之外，Apache Pulsar 在存储设计上也不同于传统 MQ 的分区数据本地存储的模式，采用的是分片存储的模式，存储粒度比分区更细化、存储负载更均衡。Apache Pulsar 中的每个 Topic 分区本质上都是存储在 Apache BookKeeper 中的分布式日志。Topic 可以有多个分区，分区数据持久化时，分区是逻辑上的概念，实际存储的单位是分片（Segment）的，如图，一个分区 Topic1-Part2 的数据由多个 Segment 组成， 每个 Segment 作为 Apache BookKeeper 中的一个 Ledger，均匀分布并存储在 Apache BookKeeper 群集中的多个 Bookie 节点中， 每个 Segment 具有 3 个副本。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301653622.png" alt="image-20230629145051542"></p><p>它与传统的紧耦合分区架构而言，将带来一个很大的优势就是，超高的<strong>可扩展性</strong>以及<strong>故障容错性</strong>。</p><h4 id="高可用及横向拓展" tabindex="-1">高可用及横向拓展 <a class="header-anchor" href="#高可用及横向拓展" aria-label="Permalink to &quot;高可用及横向拓展&quot;">​</a></h4><p>消息服务层和持久存储层是分开的，因此 Apache Pulsar 可以独立地扩展存储层和服务层。</p><h5 id="可扩展性" tabindex="-1">可扩展性 <a class="header-anchor" href="#可扩展性" aria-label="Permalink to &quot;可扩展性&quot;">​</a></h5><h6 id="broker-扩展" tabindex="-1">Broker 扩展 <a class="header-anchor" href="#broker-扩展" aria-label="Permalink to &quot;Broker 扩展&quot;">​</a></h6><p>在 Pulsar 中 Broker 是<strong>无状态</strong>的，可以通过增加节点的方式实现快速扩容。当需要支持更多的消费者或生产者时，可以简单地添加更多的 Broker 节点来满足业务需求。Pulsar 支持自动的分区负载均衡，在 Broker 节点的资源使用率达到阈值时，会将负载迁移到负载较低的 Broker 节点，这个过程中分区也将在多个 Broker 节点中做平衡迁移，一些分区的<strong>所有权</strong>会转移到新的 Broker 节点。</p><h6 id="bookie-扩展" tabindex="-1">Bookie 扩展 <a class="header-anchor" href="#bookie-扩展" aria-label="Permalink to &quot;Bookie 扩展&quot;">​</a></h6><p>存储层的扩容，通过增加 Bookie 节点来实现。通过资源感知和数据放置策略，流量将自动切换到新的 Bookie 节点中，整个过程不会涉及到不必要的数据搬迁，即不需要将旧数据从现有存储节点重新复制到新存储节点。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301653974.png" alt="image-20230629145312761"></p><p>如图所示，起始状态有四个存储节点，Bookie1, Bookie2, Bookie3, Bookie4，以 Topic1-Part2 为例，当这个分区的最新的存储分片是 SegmentX 时，对存储层扩容，添加了新的 Bookie 节点，BookieX,BookieY，那么在存储分片滚动之后，新生成的存储分片， SegmentX+1,SegmentX+2，会优先选择新的 Bookie 节点（BookieX,BookieY）来保存数据。</p><h5 id="容错性" tabindex="-1">容错性 <a class="header-anchor" href="#容错性" aria-label="Permalink to &quot;容错性&quot;">​</a></h5><p>得益于计算与存储分离以及分片存储的设计，Pulsar 可以实现独立、灵活的容错。</p><h6 id="broker-容错" tabindex="-1">Broker 容错 <a class="header-anchor" href="#broker-容错" aria-label="Permalink to &quot;Broker 容错&quot;">​</a></h6><p>当 Broker 节点失败时， 以图为例，当存储分片滚动到 SegmentX 时，Broker2 节点失败，此时生产者和消费者向其他的 Broker 发起请求，这个过程会触发分区的所有权转移，即将 Broker2 拥有的分区 Topic1-Part2 的所有权转移到其他的 Broker (Broker3)。在 Apache Pulsar 中数据存储和数据服务分离，所以新 Broker 接管分区的所有权时，它不需要复制 Partiton 的数据。新的分区 Owner（Broker3）会产生一个新的分片 SegmentX+1, 如果有新数据到来，会存储在新的分片 Segment x+1 上，不会影响分区的可用性。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301654902.png" alt="image-20230629145443509"></p><h6 id="bookie-容错" tabindex="-1">Bookie 容错 <a class="header-anchor" href="#bookie-容错" aria-label="Permalink to &quot;Bookie 容错&quot;">​</a></h6><p>当 Bookie 节点失败时，如图所示， 假设 Bookie 2 上的 Segment 4 损坏。Apache BookKeeper Auditor 会检测到这个错误并进行复制修复。Apache BookKeeper 中的副本修复是 Segment 级别的多对多快速修复，BookKeeper 可以从 Bookie 3 和 Bookie 4 读取 Segment 4 中的消息，并在 Bookie 1 处修复 Segment 4。如果是 Bookie 节点故障，这个 Bookie 节点上所有的 Segment 会按照上述方式复制到其他的 Bookie 节点。所有的副本修复都在后台进行，对 Broker 和应用透明，Broker 会产生新的 Segment 来处理写入请求，不会影响分区的可用性。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301653413.png" alt="image-20230629145514287"></p><p>分片存储解决了分区容量受单节点存储空间限制的问题，当容量不够时，可以通过扩容 Bookie 节点的方式支撑更多的分区数据，也解决了分区数据倾斜问题，数据可以均匀的分配在 Bookie 节点上。Broker 和 Bookie 灵活的容错以及无缝的扩容能力让 Apache Pulsar 具备非常高的可用性。</p><h4 id="读写分离" tabindex="-1">读写分离 <a class="header-anchor" href="#读写分离" aria-label="Permalink to &quot;读写分离&quot;">​</a></h4><p>Pulsar 另外一个有吸引力的特性是提供了读写分离的能力，读写分离保证了在有大量滞后消费（磁盘 IO 会增加）时，不会影响服务的正常运行，尤其是不会影响到数据的写入。读写分离的能力由 Apache BookKeeper 提供，简单说一下 Bookie 存储涉及到的概念：</p><ul><li>Journals：Journal 文件包含了 BookKeeper 事务日志，在 Ledger 更新之前，Journal 保证描述更新的事务写入到 Non-volatile 的存储介质上。</li><li>Entry logs：Entry 日志文件管理写入的 Entry，来自不同 ledger 的 entry 会被聚合然后顺序写入。</li><li>Index files：每个 Ledger 都有一个对应的索引文件，记录数据在 Entry 日志文件中的 Offset 信息。</li></ul><p>Entry 的读写入过程如图七所示，数据的写入流程：</p><ul><li>数据首先会写入 Journal，写入 Journal 的数据会实时落到磁盘。</li><li>然后，数据写入到 Memtable ，Memtable 是读写缓存。</li><li>写入 Memtable 之后，对写入请求进行响应。</li><li>Memtable 写满之后，会 Flush 到 Entry Logger 和 Index cache，Entry Logger 中保存了数据，Index cache 保存了数据的索引信息，然后由后台线程将 Entry Logger 和 Index cache 数据落到磁盘。</li></ul><p>数据的读取流程：</p><ul><li>如果是 Tailing read 请求，直接从 Memtable 中读取 Entry。</li><li>如果是 Catch-up read（滞后消费）请求，先读取 Index 信息，然后索引从 Entry Logger 文件读取 Entry。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301654647.png" alt="image-20230629145555987"></p><p>一般在进行 Bookie 的配置时，会将 Journal 和 Ledger 存储磁盘进行隔离，减少 Ledger 对于 Journal 写入的影响，并且推荐 Journal 使用性能较好的 SSD 磁盘，读写分离主要体现在：</p><ul><li>写入 Entry 时，Journal 中的数据需要实时写到磁盘，Ledger 的数据不需要实时落盘，通过后台线程批量落盘，因此写入的性能主要受到 Journal 磁盘的影响。</li><li>读取 Entry 时，首先从 Memtable 读取，命中则返回；如果不命中，再从 Ledger 磁盘中读取，所以对于 Catch-up read 的场景，读取数据会影响 Ledger 磁盘的 IO，对 Journal 磁盘没有影响，也就不会影响到数据的写入。</li></ul><p>所以，数据写入是主要是受 Journal 磁盘的负载影响，不会受 Ledger 磁盘的影响。另外，Segment 存储的多个副本都可以提供读取服务，相比于主从副本的设计，Apache Pulsar 可以提供更好的数据读取能力。通过以上分析，Apache Pulsar 使用 Apache BookKeeper 作为数据存储，可以带来下列的收益：</p><ul><li>支持将多个 Ledger 的数据写入到同一个 Entry logger 文件，可以避免分区膨胀带来的性能下降问题。</li><li>支持读写分离，可以在滞后消费场景导致磁盘 IO 上升时，保证数据写入的不受影响。</li><li>支持全副本读取，可以充分利用存储副本的数据读取能力。</li></ul><h3 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h3><p>pulsar建立在发布-订阅模式(通常缩写为发布-订阅)之上。在这种模式中，<code>producers</code>向<code>topics</code>发布消息,<code>consumers</code>订阅这些主题，处理传入的消息，并在处理完成时向broke发送<code>acknowledgments</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301654318.png" alt="image-20230629145821154"></p><p>创建订阅后，即使客户断开连接，Pulsar也会保留所有消息。只有当<code>consumer</code>确认所有这些消息都已成功处理时，才会丢弃保留的消息。</p><p>如果消息的消费失败，并且希望再次消费此消息，则可以启用消息重发机制，请求broker重新发送此消息。</p><h4 id="消息-message" tabindex="-1">消息 message <a class="header-anchor" href="#消息-message" aria-label="Permalink to &quot;消息 message&quot;">​</a></h4><h5 id="生产者" tabindex="-1">生产者 <a class="header-anchor" href="#生产者" aria-label="Permalink to &quot;生产者&quot;">​</a></h5><h6 id="send-modes" tabindex="-1">Send modes <a class="header-anchor" href="#send-modes" aria-label="Permalink to &quot;Send modes&quot;">​</a></h6><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>Sync send</td><td>生产者在发送每条消息后等待来自broker的确认。如果没有收到确认，则生产者将发送操作视为失败。</td></tr><tr><td>Async send</td><td>生产者将消息放入阻塞队列并立即返回。客户端在后台将消息发送到broker。如果队列已满(您可以配置最大大小)，则在调用API时，生产者将被阻塞或立即失败，这取决于传递给生产者的参数。</td></tr></tbody></table><h6 id="access-mode" tabindex="-1">Access mode <a class="header-anchor" href="#access-mode" aria-label="Permalink to &quot;Access mode&quot;">​</a></h6><table><thead><tr><th>访问模式</th><th>描述</th></tr></thead><tbody><tr><td>Shared</td><td>多个生产者可以在一个主题上发布。这是默认设置。</td></tr><tr><td>Exclusive</td><td>一个主题只能由一个生产者发表。如果已经有一个生产者连接，其他生产者试图发布这个主题立即得到错误。</td></tr><tr><td>WaitForExclusive</td><td>如果已经连接了一个生产者，那么生产者的创建将挂起(而不是超时)，直到生产者获得独占访问权限。</td></tr></tbody></table><p>一旦应用程序成功地创建了具有<code>Exclusive</code>或<code>WaitForExclusive</code>访问模式的生产者，该应用程序的实例就保证是该主题的唯一写入者。任何试图生成关于此主题的消息的其他生产者要么立即得到错误，要么必须等到获得独占访问权。</p><h6 id="deliverafter-deliverat" tabindex="-1">deliverAfter &amp; deliverAt <a class="header-anchor" href="#deliverafter-deliverat" aria-label="Permalink to &quot;deliverAfter &amp; deliverAt&quot;">​</a></h6><p>在 Pulsar 中使用延迟消息，可以精确指定延迟投递的时间，有 <code>deliverAfter</code> 和 <code>deliverAt</code> 两种方式。其中 <code>deliverAt</code> 可以指定具体的时间戳；<code>deliverAfter</code> 可以指定在当前多长时间后执行。两种方式的本质是一样的，Client 会计算出时间戳送到 Broker。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// deliverAfter发送</span></span>
<span class="line"><span style="color:#E1E4E8;">producer.</span><span style="color:#B392F0;">newMessage</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">deliverAfter</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3L</span><span style="color:#E1E4E8;">, TimeUnit.Minute).</span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Hello Pulsar!&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// deliverAfter发送</span></span>
<span class="line"><span style="color:#24292E;">producer.</span><span style="color:#6F42C1;">newMessage</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">deliverAfter</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3L</span><span style="color:#24292E;">, TimeUnit.Minute).</span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Hello Pulsar!&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">();</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//deliverAt发送</span></span>
<span class="line"><span style="color:#E1E4E8;">producer.</span><span style="color:#B392F0;">newMessage</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">deliverAt</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1670574629343L</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Hello Pulsar!&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//deliverAt发送</span></span>
<span class="line"><span style="color:#24292E;">producer.</span><span style="color:#6F42C1;">newMessage</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">deliverAt</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1670574629343L</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Hello Pulsar!&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">();</span></span></code></pre></div><h6 id="消息压缩" tabindex="-1">消息压缩 <a class="header-anchor" href="#消息压缩" aria-label="Permalink to &quot;消息压缩&quot;">​</a></h6><p>消息压缩是优化信息传输的手段之一，我们通常看见一些大型文件都会是以一个压缩包的形式提供下载，在我们消息队列中我们也可以用这种思想，我们将一个batch的消息，比如有1000条可能有1M的传输大小，但是经过压缩之后可能就只会有几十kb，增加了我们和broker的传输效率，但是与之同时我们的cpu也带来了损耗。Pulsar客户端支持多种压缩类型，如 lz4、zlib、zstd、snappy 等。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">client.</span><span style="color:#B392F0;">newProducer</span><span style="color:#E1E4E8;">() </span></span>
<span class="line"><span style="color:#E1E4E8;">    .</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(“test</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">topic”) </span></span>
<span class="line"><span style="color:#E1E4E8;">    .</span><span style="color:#B392F0;">compressionType</span><span style="color:#E1E4E8;">(CompressionType.LZ4) </span></span>
<span class="line"><span style="color:#E1E4E8;">    .</span><span style="color:#B392F0;">create</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">client.</span><span style="color:#6F42C1;">newProducer</span><span style="color:#24292E;">() </span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(“test</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">topic”) </span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#6F42C1;">compressionType</span><span style="color:#24292E;">(CompressionType.LZ4) </span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">();</span></span></code></pre></div><h5 id="消费者" tabindex="-1">消费者 <a class="header-anchor" href="#消费者" aria-label="Permalink to &quot;消费者&quot;">​</a></h5><h6 id="消息确认-acknowledgement" tabindex="-1">消息确认 Acknowledgement <a class="header-anchor" href="#消息确认-acknowledgement" aria-label="Permalink to &quot;消息确认 Acknowledgement&quot;">​</a></h6><table><thead><tr><th>模式</th><th>模式</th></tr></thead><tbody><tr><td>acknowledge individually</td><td>消息立即确认，消费者消费后每一条消息都会给broker发送一个确认请求</td></tr><tr><td>acknowledged cumulatively</td><td>消息累计确认，消费者仅提交最后一条消息，流中的所有消息直到(并包括)所提供的消息都不会重新投递给该消费者。</td></tr></tbody></table><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 立即提交api</span></span>
<span class="line"><span style="color:#E1E4E8;">consumer.</span><span style="color:#B392F0;">acknowledge</span><span style="color:#E1E4E8;">(msg);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 立即提交api</span></span>
<span class="line"><span style="color:#24292E;">consumer.</span><span style="color:#6F42C1;">acknowledge</span><span style="color:#24292E;">(msg);</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 累计提交api</span></span>
<span class="line"><span style="color:#E1E4E8;">consumer.</span><span style="color:#B392F0;">acknowledgeCumulative</span><span style="color:#E1E4E8;">(msg);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 累计提交api</span></span>
<span class="line"><span style="color:#24292E;">consumer.</span><span style="color:#6F42C1;">acknowledgeCumulative</span><span style="color:#24292E;">(msg);</span></span></code></pre></div><p>如果是<code>Shared</code>订阅类型，消息确认只能使用<code>acknowledge individually</code>。因为<code>Shared</code>模式所有消费者共享一条数据。</p><h6 id="消息重试" tabindex="-1">消息重试 <a class="header-anchor" href="#消息重试" aria-label="Permalink to &quot;消息重试&quot;">​</a></h6><p><strong>Negative acknowledgement</strong></p><p>消息否定机制可以在consumer未成功使用消息时，向broker发送<code>nack</code>，从而将消息重新投递给consumer。</p><p>和<code>Acknowledgement</code>一样，消息是立即确认还是累计确认，取决于订阅类型。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(topic)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;sub-negative-ack&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionInitialPosition</span><span style="color:#E1E4E8;">(SubscriptionInitialPosition.Earliest)</span></span>
<span class="line"><span style="color:#E1E4E8;">    			</span><span style="color:#6A737D;">// the default value is 1 min</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">negativeAckRedeliveryDelay</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS) </span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">Message&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> consumer.</span><span style="color:#B392F0;">receive</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 发送消息否认</span></span>
<span class="line"><span style="color:#E1E4E8;">consumer.</span><span style="color:#B392F0;">negativeAcknowledge</span><span style="color:#E1E4E8;">(message);</span></span>
<span class="line"><span style="color:#E1E4E8;">message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> consumer.</span><span style="color:#B392F0;">receive</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 发送消息确认</span></span>
<span class="line"><span style="color:#E1E4E8;">consumer.</span><span style="color:#B392F0;">acknowledge</span><span style="color:#E1E4E8;">(message);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(topic)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;sub-negative-ack&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionInitialPosition</span><span style="color:#24292E;">(SubscriptionInitialPosition.Earliest)</span></span>
<span class="line"><span style="color:#24292E;">    			</span><span style="color:#6A737D;">// the default value is 1 min</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">negativeAckRedeliveryDelay</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, TimeUnit.SECONDS) </span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">Message&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; message </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> consumer.</span><span style="color:#6F42C1;">receive</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 发送消息否认</span></span>
<span class="line"><span style="color:#24292E;">consumer.</span><span style="color:#6F42C1;">negativeAcknowledge</span><span style="color:#24292E;">(message);</span></span>
<span class="line"><span style="color:#24292E;">message </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> consumer.</span><span style="color:#6F42C1;">receive</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 发送消息确认</span></span>
<span class="line"><span style="color:#24292E;">consumer.</span><span style="color:#6F42C1;">acknowledge</span><span style="color:#24292E;">(message);</span></span></code></pre></div><p>redelivery backoff 可以设置重试的时间间隔策略，指定最大和最小时间，在这段时间内通过计算因子计算每次间隔时间：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(topic)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;sub-negative-ack&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">subscriptionInitialPosition</span><span style="color:#E1E4E8;">(SubscriptionInitialPosition.Earliest)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">negativeAckRedeliveryBackoff</span><span style="color:#E1E4E8;">(MultiplierRedeliveryBackoff.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">//最小1s</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">minDelayMs</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">//最大60s</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">maxDelayMs</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">60</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">//计算因子 1s 2s 4s 6s 8s 16s …… 60s</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">multiplier</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(topic)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;sub-negative-ack&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">subscriptionInitialPosition</span><span style="color:#24292E;">(SubscriptionInitialPosition.Earliest)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">negativeAckRedeliveryBackoff</span><span style="color:#24292E;">(MultiplierRedeliveryBackoff.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">//最小1s</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">minDelayMs</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">//最大60s</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">maxDelayMs</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">60</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">//计算因子 1s 2s 4s 6s 8s 16s …… 60s</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">multiplier</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span></code></pre></div><table><thead><tr><th>Redelivery count</th><th>Redelivery delay</th></tr></thead><tbody><tr><td>1</td><td>1 seconds</td></tr><tr><td>2</td><td>2 seconds</td></tr><tr><td>3</td><td>4 seconds</td></tr><tr><td>4</td><td>8 seconds</td></tr><tr><td>5</td><td>16 seconds</td></tr><tr><td>6</td><td>32 seconds</td></tr><tr><td>7</td><td>60 seconds</td></tr><tr><td>8</td><td>60 seconds</td></tr></tbody></table><p>只有在<code>Shared</code>和<code>Key_Shared</code>订阅类型中，消费者可以逐个否定消息, <code>Exclusive</code> 和 <code>Failover</code> 消费者只确认他们收到的最后一条消息。</p><blockquote><p>如果是对消息有序性有要求，在否定消息后，顺序无法得到保证</p></blockquote><p><strong>Acknowledgement timeout</strong></p><p>如果指定了ack超时时间，且未提交确认消息，客户端会向<code>broker</code>发送重新发送未确认消息的请求，与<code>Negative acknowledgement</code> 相比，不建议使用。因为很难去设置超时时间。</p><p>当消息处理时间超出超时时间时，会发起不必要的消息重试。</p><p>如果想使用nack，需要保证在<code>acknowledgment timeout</code>前将消息进行提交,不对<code>ack timeout</code>进行设置即可</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(topic)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">ackTimeout</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS) </span><span style="color:#6A737D;">// 默认值为0</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">ackTimeoutTickTime</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS) </span><span style="color:#6A737D;">//每s检查一次</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;sub&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionInitialPosition</span><span style="color:#E1E4E8;">(SubscriptionInitialPosition.Earliest)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">Message&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> consumer.</span><span style="color:#B392F0;">receive</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 等待至少2s</span></span>
<span class="line"><span style="color:#E1E4E8;">message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> consumer.</span><span style="color:#B392F0;">receive</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">consumer.</span><span style="color:#B392F0;">acknowledge</span><span style="color:#E1E4E8;">(message);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(topic)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">ackTimeout</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, TimeUnit.SECONDS) </span><span style="color:#6A737D;">// 默认值为0</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">ackTimeoutTickTime</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, TimeUnit.SECONDS) </span><span style="color:#6A737D;">//每s检查一次</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;sub&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionInitialPosition</span><span style="color:#24292E;">(SubscriptionInitialPosition.Earliest)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">Message&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; message </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> consumer.</span><span style="color:#6F42C1;">receive</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 等待至少2s</span></span>
<span class="line"><span style="color:#24292E;">message </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> consumer.</span><span style="color:#6F42C1;">receive</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">consumer.</span><span style="color:#6F42C1;">acknowledge</span><span style="color:#24292E;">(message);</span></span></code></pre></div><p><strong>Retry letter topic</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301654310.png" alt="image-20230629150956515"></p><p><code>Retry letter topic</code>允许您存储未能使用的消息，并在以后重试使用它们。使用此方法，您可以自定义重新传递消息的间隔。原始主题上的消费者也会自动订阅重试信件主题。一旦达到最大重试次数，未使用的消息将被移动到死信主题以进行手动处理。</p><p>目前在<code>Shared</code>和<code>Key_Shared</code>订阅类型下才能使用</p><p>使用 <code>Retry letter topic</code> 与 <code>delayed message delivery</code> 两者都旨在稍后使用消息，区别在于<code>Retry letter topic</code> 用于故障处理，确保关键数据不会丢失，而<code>delayed message delivery</code> 是以指定的延迟时间传递消息。</p><p>与<code>nack</code>相比，<code>Retry letter topic</code>更适合于需要大量重试且重试间隔可配置的消息。因为<code>Retry letter topic</code>中的消息被持久化到BookKeeper，而由于<code>nack</code>需要重试的消息被缓存到客户端。</p><p>缺省情况下，禁用自动重试功能。您可以将<code>enableRetry</code>设置为true，在consumer上启用自动重试。使用以下API来消费来自<code>Retry letter topic</code>的消息。当达到<code>maxRedeliverCount</code>的值时，未使用的消息将被移动到<code>Dead letter topic</code></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">(Schema.BYTES)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-topic&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-subscription&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionType</span><span style="color:#E1E4E8;">(SubscriptionType.Shared)</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">//开启重试</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">enableRetry</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">deadLetterPolicy</span><span style="color:#E1E4E8;">(DeadLetterPolicy.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">//最大重试次数，超过发送到死信队列</span></span>
<span class="line"><span style="color:#E1E4E8;">                        .</span><span style="color:#B392F0;">maxRedeliverCount</span><span style="color:#E1E4E8;">(maxRedeliveryCount)</span></span>
<span class="line"><span style="color:#E1E4E8;">                        .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">(Schema.BYTES)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-topic&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-subscription&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionType</span><span style="color:#24292E;">(SubscriptionType.Shared)</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">//开启重试</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">enableRetry</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">deadLetterPolicy</span><span style="color:#24292E;">(DeadLetterPolicy.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">//最大重试次数，超过发送到死信队列</span></span>
<span class="line"><span style="color:#24292E;">                        .</span><span style="color:#6F42C1;">maxRedeliverCount</span><span style="color:#24292E;">(maxRedeliveryCount)</span></span>
<span class="line"><span style="color:#24292E;">                        .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span></code></pre></div><p><code>retryLetterTopic</code> 用来设置重试队列的topic名称，如果不设置默认为：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">topicname</span><span style="color:#E1E4E8;">&gt;RETRY&lt;</span><span style="color:#85E89D;">subscriptionname</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">topicname</span><span style="color:#24292E;">&gt;RETRY&lt;</span><span style="color:#22863A;">subscriptionname</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>使用以下API将消息存储在重试队列中。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">consumer.</span><span style="color:#B392F0;">reconsumeLater</span><span style="color:#E1E4E8;">(msg, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">consumer.</span><span style="color:#6F42C1;">reconsumeLater</span><span style="color:#24292E;">(msg, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, TimeUnit.SECONDS);</span></span></code></pre></div><h5 id="死信队列-dead-letter-topic" tabindex="-1">死信队列 Dead letter topic <a class="header-anchor" href="#死信队列-dead-letter-topic" aria-label="Permalink to &quot;死信队列 Dead letter topic&quot;">​</a></h5><p><code>Dead letter topic</code>服务于消息的重新发送，它由<code>acknowledgement timeout </code>、<code>negative acknowledgement</code>、<code>retry letter topic</code>触发,消费失败的消息</p><p>目前在<code>Shared</code>和<code>Key_Shared</code>订阅类型下才能使用。如果设置了<code>maxRedeliverCount</code> 会默认开启死信队列的投递。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">(Schema.BYTES)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-topic&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-subscription&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionType</span><span style="color:#E1E4E8;">(SubscriptionType.Shared)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">deadLetterPolicy</span><span style="color:#E1E4E8;">(DeadLetterPolicy.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                      .</span><span style="color:#B392F0;">maxRedeliverCount</span><span style="color:#E1E4E8;">(maxRedeliveryCount)</span></span>
<span class="line"><span style="color:#E1E4E8;">                      .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">(Schema.BYTES)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-topic&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-subscription&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionType</span><span style="color:#24292E;">(SubscriptionType.Shared)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">deadLetterPolicy</span><span style="color:#24292E;">(DeadLetterPolicy.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                      .</span><span style="color:#6F42C1;">maxRedeliverCount</span><span style="color:#24292E;">(maxRedeliveryCount)</span></span>
<span class="line"><span style="color:#24292E;">                      .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span></code></pre></div><p>如果不设置名称，系统默认为</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">topicname</span><span style="color:#E1E4E8;">&gt;DLQ&lt;</span><span style="color:#85E89D;">subscriptionname</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">topicname</span><span style="color:#24292E;">&gt;DLQ&lt;</span><span style="color:#22863A;">subscriptionname</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>默认情况下，在DLQ主题创建期间没有订阅。如果不及时订阅DLQ主题，可能会丢失消息。要为DLQ自动创建初始订阅，可以指定<code>initialSubscriptionName</code>参数。如果设置了这个参数，需要保证<code>broker</code>侧的配置<code>allowAutoSubscriptionCreation</code>是开启的，才能有效创建DLQ生成器。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">(Schema.BYTES)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-topic&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-subscription&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscriptionType</span><span style="color:#E1E4E8;">(SubscriptionType.Shared)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">deadLetterPolicy</span><span style="color:#E1E4E8;">(DeadLetterPolicy.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                      .</span><span style="color:#B392F0;">maxRedeliverCount</span><span style="color:#E1E4E8;">(maxRedeliveryCount)</span></span>
<span class="line"><span style="color:#E1E4E8;">                      .</span><span style="color:#B392F0;">deadLetterTopic</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-dead-letter-topic-name&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                      .</span><span style="color:#B392F0;">initialSubscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;init-sub&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                      .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">(Schema.BYTES)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-topic&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-subscription&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscriptionType</span><span style="color:#24292E;">(SubscriptionType.Shared)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">deadLetterPolicy</span><span style="color:#24292E;">(DeadLetterPolicy.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                      .</span><span style="color:#6F42C1;">maxRedeliverCount</span><span style="color:#24292E;">(maxRedeliveryCount)</span></span>
<span class="line"><span style="color:#24292E;">                      .</span><span style="color:#6F42C1;">deadLetterTopic</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-dead-letter-topic-name&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                      .</span><span style="color:#6F42C1;">initialSubscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;init-sub&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">                      .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span></code></pre></div><h5 id="消息延迟投递" tabindex="-1">消息延迟投递 <a class="header-anchor" href="#消息延迟投递" aria-label="Permalink to &quot;消息延迟投递&quot;">​</a></h5><p>延迟消息传递使您可以稍后使用消息。在这种机制中，消息存储在<code>BookKeeper</code>中。在消息发布到broker之后，<code>DelayedDeliveryTracker</code>在内存中维护时间索引(time -&gt; messageId)。一旦指定的延迟结束，该消息将被传递给使用者。</p><p>延迟消息传递仅适用于<code>Shared</code>类型。在<code>Exclusive</code>和<code>Failover</code>类型中，延迟消息将立即分派。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301654454.png" alt="image-20230629151618435"></p><p>broker保存消息而不进行任何检查。当<code>consumer</code>消费时，如果消息被设置为延迟，则该消息将被添加到<code>DelayedDeliveryTracker</code>。subscription从<code>DelayedDeliveryTracker</code>检查并获取超时的消息。</p><h5 id="事务消息" tabindex="-1">事务消息 <a class="header-anchor" href="#事务消息" aria-label="Permalink to &quot;事务消息&quot;">​</a></h5><p><code>Pulsar 事务消息的适用场景为一次事务中需要发送多个消息的情况，保证多个消息之间的事务约束，即多条消息要么都发送成功，要么都发送失败，而不是保证本地事务的执行和发送消息的事务约束</code></p><p>这里以一个资金流转场景举例，分账系统收到订单系统发送的一条信息A，然后进行自己的逻辑处理后，需要往余额系统投递两条信息B、C</p><p>这里的ack A、send B、send C，三个动作即构成一个事务</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//在初始化pulsarClient的时候需要开启enableTransaction</span></span>
<span class="line"><span style="color:#E1E4E8;">PulsarClient pulsarClient </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> PulsarClient.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">serviceUrl</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;pulsar://localhost:6650&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">//开启事务支持</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">enableTransaction</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//收到消息A</span></span>
<span class="line"><span style="color:#E1E4E8;">message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> consumer.</span><span style="color:#B392F0;">receive</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS);</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#6A737D;">//自己的各种业务逻辑.....</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#6A737D;">//开启一个事务</span></span>
<span class="line"><span style="color:#E1E4E8;">Transaction transaction </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newTransaction</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                    .</span><span style="color:#B392F0;">withTransactionTimeout</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">, TimeUnit.MINUTES)</span></span>
<span class="line"><span style="color:#E1E4E8;">                    .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">//发送消息B</span></span>
<span class="line"><span style="color:#E1E4E8;">producer.</span><span style="color:#B392F0;">newMessage</span><span style="color:#E1E4E8;">(transaction).</span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;B&quot;</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getBytes</span><span style="color:#E1E4E8;">()).</span><span style="color:#B392F0;">sendAsync</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#6A737D;">//发送消息C</span></span>
<span class="line"><span style="color:#E1E4E8;">producer.</span><span style="color:#B392F0;">newMessage</span><span style="color:#E1E4E8;">(transaction).</span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;C&quot;</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getBytes</span><span style="color:#E1E4E8;">()).</span><span style="color:#B392F0;">sendAsync</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#6A737D;">//ack消息A</span></span>
<span class="line"><span style="color:#E1E4E8;">consumer.</span><span style="color:#B392F0;">acknowledgeAsync</span><span style="color:#E1E4E8;">(message.</span><span style="color:#B392F0;">getMessageId</span><span style="color:#E1E4E8;">(), transaction);</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#6A737D;">//提交事务</span></span>
<span class="line"><span style="color:#E1E4E8;">transaction.</span><span style="color:#B392F0;">commit</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">//或者回滚事务</span></span>
<span class="line"><span style="color:#E1E4E8;">transaction.</span><span style="color:#B392F0;">abort</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//在初始化pulsarClient的时候需要开启enableTransaction</span></span>
<span class="line"><span style="color:#24292E;">PulsarClient pulsarClient </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> PulsarClient.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">serviceUrl</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;pulsar://localhost:6650&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//开启事务支持</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">enableTransaction</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//收到消息A</span></span>
<span class="line"><span style="color:#24292E;">message </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> consumer.</span><span style="color:#6F42C1;">receive</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">, TimeUnit.SECONDS);</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#6A737D;">//自己的各种业务逻辑.....</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#6A737D;">//开启一个事务</span></span>
<span class="line"><span style="color:#24292E;">Transaction transaction </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newTransaction</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                    .</span><span style="color:#6F42C1;">withTransactionTimeout</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">, TimeUnit.MINUTES)</span></span>
<span class="line"><span style="color:#24292E;">                    .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">//发送消息B</span></span>
<span class="line"><span style="color:#24292E;">producer.</span><span style="color:#6F42C1;">newMessage</span><span style="color:#24292E;">(transaction).</span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;B&quot;</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">getBytes</span><span style="color:#24292E;">()).</span><span style="color:#6F42C1;">sendAsync</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#6A737D;">//发送消息C</span></span>
<span class="line"><span style="color:#24292E;">producer.</span><span style="color:#6F42C1;">newMessage</span><span style="color:#24292E;">(transaction).</span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;C&quot;</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">getBytes</span><span style="color:#24292E;">()).</span><span style="color:#6F42C1;">sendAsync</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#6A737D;">//ack消息A</span></span>
<span class="line"><span style="color:#24292E;">consumer.</span><span style="color:#6F42C1;">acknowledgeAsync</span><span style="color:#24292E;">(message.</span><span style="color:#6F42C1;">getMessageId</span><span style="color:#24292E;">(), transaction);</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#6A737D;">//提交事务</span></span>
<span class="line"><span style="color:#24292E;">transaction.</span><span style="color:#6F42C1;">commit</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">//或者回滚事务</span></span>
<span class="line"><span style="color:#24292E;">transaction.</span><span style="color:#6F42C1;">abort</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span></code></pre></div><h4 id="主题-topic" tabindex="-1">主题 topic <a class="header-anchor" href="#主题-topic" aria-label="Permalink to &quot;主题 topic&quot;">​</a></h4><h5 id="命名规则" tabindex="-1">命名规则 <a class="header-anchor" href="#命名规则" aria-label="Permalink to &quot;命名规则&quot;">​</a></h5><p>与其他pub-sub系统一样，pulsar中的主题被命名为通道，用于将消息从生产者传输到消费者。topic的定义应遵循以下结构：</p><blockquote><p>{persistent|non-persistent}😕/tenant/namespace/topic</p></blockquote><table><thead><tr><th>Topic name component</th><th>Description</th></tr></thead><tbody><tr><td><code>persistent</code> / <code>non-persistent</code></td><td>Pulsar支持两种类型的的<strong>topic</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpulsar.apache.org%2Fdocs%2F2.10.x%2Fconcepts-architecture-overview%2F%23persistent-storage" target="_blank" rel="noreferrer">persistent</a> and <a href="https://link.juejin.cn?target=https%3A%2F%2Fpulsar.apache.org%2Fdocs%2F2.10.x%2Fconcepts-messaging%2F%23non-persistent-topics" target="_blank" rel="noreferrer">non-persistent</a>.默认是持久化的，表示所有消息都持久化在磁盘上，而未非持久化的主题不会存储在磁盘上</td></tr><tr><td><code>tenant</code></td><td>实例内的主题租户。租户对于Pulsar中的多租户至关重要，并且分布在集群中。</td></tr><tr><td><code>namespace</code></td><td>管理主题的单元，类似于分组机制，大多数主题都配置在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpulsar.apache.org%2Fdocs%2F2.10.x%2Fconcepts-messaging%2F%23namespaces" target="_blank" rel="noreferrer">namespace</a> 上. 每一个租户可以有多个 <strong>namespaces</strong>.</td></tr><tr><td><code>topic</code></td><td>名字组成的最后的一部分，它在pulsar中没有特殊的含义</td></tr></tbody></table><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">PulsarClient client </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> PulsarClient.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">serviceUrl</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;pulsar://localhost:6650&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 指定非持久化topic</span></span>
<span class="line"><span style="color:#E1E4E8;">String npTopic </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;non-persistent://public/default/my-topic&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">String subscriptionName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;my-subscription-name&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> client.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(npTopic)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(subscriptionName)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">PulsarClient client </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> PulsarClient.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">serviceUrl</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;pulsar://localhost:6650&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 指定非持久化topic</span></span>
<span class="line"><span style="color:#24292E;">String npTopic </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;non-persistent://public/default/my-topic&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">String subscriptionName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;my-subscription-name&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> client.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(npTopic)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(subscriptionName)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span></code></pre></div><h5 id="multi-topic" tabindex="-1">Multi-topic <a class="header-anchor" href="#multi-topic" aria-label="Permalink to &quot;Multi-topic&quot;">​</a></h5><p>当消费者订阅一个pulsar主题时，默认情况下它会订阅一个特定的主题，例如<code>persistent://public/default/my-topic</code>。然而，从1.23.0版本开始，pulsar可以同时订阅多个主题。可以用两种方式定义主题列表:</p><ul><li>基于正则表达式(regex)，例如persistent://public/default/finance-.*</li><li>通过显式定义主题列表</li></ul><blockquote><p>当通过regex订阅多个主题时，所有主题必须在相同的名称空间中。</p></blockquote><p>当生产者向单个主题发送消息时，所有消息都保证以相同的顺序从该主题读取。然而，这些保证并不适用于<code>Multi-topic</code>。因此，当生产者向多个主题发送消息时，从这些主题读取消息的顺序不能保证相同。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 订阅所有 namespace 下所有topic</span></span>
<span class="line"><span style="color:#E1E4E8;">Pattern allTopicsInNamespace </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Pattern.</span><span style="color:#B392F0;">compile</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;persistent://public/default/.*&quot;</span><span style="color:#E1E4E8;">);  </span></span>
<span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; allTopicsConsumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">()  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">topicsPattern</span><span style="color:#E1E4E8;">(allTopicsInNamespace)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;subscription-1&quot;</span><span style="color:#E1E4E8;">)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">// 订阅某个 namespace 下所有topic</span></span>
<span class="line"><span style="color:#E1E4E8;">Pattern someTopicsInNamespace </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Pattern.</span><span style="color:#B392F0;">compile</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;persistent://public/default/foo.*&quot;</span><span style="color:#E1E4E8;">);  </span></span>
<span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; someTopicsConsumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">()  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">topicsPattern</span><span style="color:#E1E4E8;">(someTopicsInNamespace)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;subscription-1&quot;</span><span style="color:#E1E4E8;">)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 订阅所有 namespace 下所有topic</span></span>
<span class="line"><span style="color:#24292E;">Pattern allTopicsInNamespace </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Pattern.</span><span style="color:#6F42C1;">compile</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;persistent://public/default/.*&quot;</span><span style="color:#24292E;">);  </span></span>
<span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; allTopicsConsumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">()  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">topicsPattern</span><span style="color:#24292E;">(allTopicsInNamespace)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;subscription-1&quot;</span><span style="color:#24292E;">)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();  </span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#6A737D;">// 订阅某个 namespace 下所有topic</span></span>
<span class="line"><span style="color:#24292E;">Pattern someTopicsInNamespace </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Pattern.</span><span style="color:#6F42C1;">compile</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;persistent://public/default/foo.*&quot;</span><span style="color:#24292E;">);  </span></span>
<span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; someTopicsConsumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">()  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">topicsPattern</span><span style="color:#24292E;">(someTopicsInNamespace)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;subscription-1&quot;</span><span style="color:#24292E;">)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span></code></pre></div><h5 id="partitioned-topics" tabindex="-1">Partitioned topics <a class="header-anchor" href="#partitioned-topics" aria-label="Permalink to &quot;Partitioned topics&quot;">​</a></h5><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301654606.png" alt="image-20230629152228911"></p><p>如图所示，topic1中有5个分区（p0-p4），他们分布在3个broker上，因为<code>partition</code>比broker多，所以两个broker一次处理2个partition，另一个代理只处理一个partition。</p><p>这个topic的消息将广播给2个消费者，路由模式决定每条消息应该发布到哪个分区，而订阅类型决定哪些消息发送给哪个消费者，在大多数情况下，可以分别决定路由和订阅模式。通常，吞吐量问题应该使用分区/路由决策，而订阅类型的决策取决于应用程序具体的使用场景。</p><h6 id="routing-modes-路由模式" tabindex="-1">Routing modes 路由模式 <a class="header-anchor" href="#routing-modes-路由模式" aria-label="Permalink to &quot;Routing modes 路由模式&quot;">​</a></h6><table><thead><tr><th>Mode</th><th>Description</th></tr></thead><tbody><tr><td><code>RoundRobinPartition</code></td><td>如果没有提供key，生产者将以<code>轮询</code>方式跨所有分区发布消息，以实现最大吞吐量。请注意，轮循不是针对单个消息进行的，而是将其设置为相同的批处理延迟边界，以确保批处理有效。如果在消息上指定了一个键，则分区生产者将对该键进行散列，并将消息分配给特定的分区。这是默认模式。</td></tr><tr><td><code>SinglePartition</code></td><td>如果没有提供key，生产者将<code>随机选择</code>一个分区，并将所有消息发布到该分区中。如果在消息上指定了一个键，则分区生产者将对该键进行散列，并将消息分配给特定的分区。</td></tr><tr><td><code>CustomPartition</code></td><td>使用将被调用的自定义消息路由器实现来确定特定消息的分区。用户可以使用实例创建自定义路由模式使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpulsar.apache.org%2Fdocs%2F3.0.x%2Fclient-libraries-java%2F" target="_blank" rel="noreferrer">Java client</a> 并实现 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpulsar.apache.org%2Fapi%2Fclient%2F3.0.x%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FMessageRouter" target="_blank" rel="noreferrer">MessageRouter</a> 接口。</td></tr></tbody></table><p>如果消息附加了一个键，当使用SinglePartition或RoundRobinPartition模式时，消息将根据ProducerBuilder中<code>HashingScheme</code>指定的散列方案路由到相应的分区。</p><table><thead><tr><th>Ordering guarantee</th><th>Description</th><th>Routing Mode and Key</th></tr></thead><tbody><tr><td>Per-key-partition</td><td>具有相同键的所有消息将按顺序排列并放置在同一分区中.</td><td>使用<code>SinglePartition</code>或<code>RoundRobinPartition</code>模式，Key由每条消息提供。</td></tr><tr><td>Per-producer</td><td>来自同一生产者的所有消息都是有序的。</td><td>使用<code>SinglePartition</code>模式，不为每条消息提供Key。</td></tr></tbody></table><blockquote><p>HashingScheme是一个枚举，它表示在为特定消息选择分区时可用的标准散列函数集。 有两种类型的标准哈希函数可用:JavaStringHash和Murmur3_32Hash。生产者的默认哈希函数是JavaStringHash。请注意，当生产者可以来自不同的多语言客户端时，JavaStringHash是没有用的，在这种情况下，建议使用Murmur3_32Hash。</p></blockquote><h4 id="订阅者-subscriptions" tabindex="-1">订阅者 Subscriptions <a class="header-anchor" href="#订阅者-subscriptions" aria-label="Permalink to &quot;订阅者 Subscriptions&quot;">​</a></h4><h5 id="订阅类型" tabindex="-1">订阅类型 <a class="header-anchor" href="#订阅类型" aria-label="Permalink to &quot;订阅类型&quot;">​</a></h5><p>pulsar中有四种订阅类型:<code>exclusive</code>、<code>shared</code>、<code>failover</code>和<code>key_shared</code>。这些类型如下图所示。</p><p>根据消息传递的顺序性和实时性可以将消息模型分为两类：</p><ul><li><strong>queuing</strong> 模型主要是采用无序或者共享的方式来消费消息。</li><li><strong>streaming</strong> 模型要求消息的消费严格排序或独占消息消费</li></ul><h5 id="订阅模式" tabindex="-1">订阅模式 <a class="header-anchor" href="#订阅模式" aria-label="Permalink to &quot;订阅模式&quot;">​</a></h5><table><thead><tr><th>Subscription mode</th><th>Description</th><th>Note</th></tr></thead><tbody><tr><td><code>Durable</code></td><td>cursor是持久的，它保留消息并持久保存当前位置。如果代理从故障中重新启动，它可以从持久存储(BookKeeper)中恢复cursor，这样就可以从上次消费的位置继续消费消息。</td><td><code>Durable</code> 是<strong>默认的</strong>订阅模式。</td></tr><tr><td><code>NonDurable</code></td><td>cursor是非持久的。一旦代理停止，cursor将丢失，并且永远无法恢复，因此消息不能从最后消费的位置继续消费。</td><td>Reader的订阅模式本质上是<code>NonDurable</code>的，它不阻止主题中的数据被删除。Reader的订阅模式<strong>无法更改</strong>。</td></tr></tbody></table><blockquote><p>可以使用java client api 进行设置</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">()  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-topic&quot;</span><span style="color:#E1E4E8;">)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-sub&quot;</span><span style="color:#E1E4E8;">)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscriptionMode</span><span style="color:#E1E4E8;">(SubscriptionMode.Durable)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">Consumer&lt;</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[]&gt; consumer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pulsarClient.</span><span style="color:#B392F0;">newConsumer</span><span style="color:#E1E4E8;">()  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-topic&quot;</span><span style="color:#E1E4E8;">)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscriptionName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;my-sub&quot;</span><span style="color:#E1E4E8;">)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscriptionMode</span><span style="color:#E1E4E8;">(SubscriptionMode.NonDurable)  </span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span>
<span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">()  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-topic&quot;</span><span style="color:#24292E;">)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-sub&quot;</span><span style="color:#24292E;">)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscriptionMode</span><span style="color:#24292E;">(SubscriptionMode.Durable)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">Consumer&lt;</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[]&gt; consumer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pulsarClient.</span><span style="color:#6F42C1;">newConsumer</span><span style="color:#24292E;">()  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-topic&quot;</span><span style="color:#24292E;">)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscriptionName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;my-sub&quot;</span><span style="color:#24292E;">)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscriptionMode</span><span style="color:#24292E;">(SubscriptionMode.NonDurable)  </span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">();</span></span></code></pre></div>`,168),p=[e];function t(r,c,i,E,y,d){return a(),n("div",null,p)}const g=s(o,[["render",t]]);export{h as __pageData,g as default};
