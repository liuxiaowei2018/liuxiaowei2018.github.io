import{_ as a,o as t,c as e,Q as l}from"./chunks/framework.8048b864.js";const m=JSON.parse('{"title":"如何排查生产问题？","description":"","frontmatter":{},"headers":[],"relativePath":"生产事件/如何排查生产问题.md","filePath":"生产事件/如何排查生产问题.md","lastUpdated":1718961457000}'),o={name:"生产事件/如何排查生产问题.md"},i=l('<h1 id="如何排查生产问题" tabindex="-1">如何排查生产问题？ <a class="header-anchor" href="#如何排查生产问题" aria-label="Permalink to &quot;如何排查生产问题？&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#排查工具">排查工具</a><ul><li><a href="#jdk-工具">JDK 工具</a></li><li><a href="#arthas">Arthas</a></li><li><a href="#mat">MAT</a></li></ul></li><li><a href="#参考文档">参考文档</a></li></ul></nav><h2 id="排查工具" tabindex="-1">排查工具 <a class="header-anchor" href="#排查工具" aria-label="Permalink to &quot;排查工具&quot;">​</a></h2><h3 id="jdk-工具" tabindex="-1">JDK 工具 <a class="header-anchor" href="#jdk-工具" aria-label="Permalink to &quot;JDK 工具&quot;">​</a></h3><blockquote><p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/" target="_blank" rel="noreferrer">https://docs.oracle.com/javase/8/docs/technotes/tools/</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405292205209.png" alt="image-20220328171810444"></p><h4 id="jvisualvm" tabindex="-1">jvisualvm <a class="header-anchor" href="#jvisualvm" aria-label="Permalink to &quot;jvisualvm&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405292205631.png" alt="图片"></p><blockquote><p>继续观察监视面板可以看到，JVM 的 GC 活动基本是 10 秒发生一次，堆内存在 250MB 到 900MB 之间波动，活动线程数是 22。我们可以在监视面板看到 JVM 的基本情况，也可以直接在这里进行手动 GC 和堆 Dump 操作：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405292205951.png" alt="图片"></p><blockquote><p>jconsole如果希望看到各个内存区的 GC 曲线图，可以使用 jconsole 观察。jconsole 也是一个综合性图形界面监控工具，比 jvisualvm 更方便的一点是，可以用曲线的形式监控各种数据，包括 MBean 中的属性值：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405292205311.png" alt="图片"></p><h4 id="jstat" tabindex="-1">jstat <a class="header-anchor" href="#jstat" aria-label="Permalink to &quot;jstat&quot;">​</a></h4><blockquote><p>jstat 工具允许以固定的监控频次输出 JVM 的各种监控指标</p><p>比如使用 -gcutil 输出 GC 和内存占用汇总信息，每隔 5 秒输出一次，输出 100 次</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">jstat -gcutil 6 5000 100</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">jstat -gcutil 6 5000 100</span></span></code></pre></div></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405292205863.png" alt="image-20230619171154690"></p><blockquote><p>参数：</p><ul><li>S0 Survivor0 区占用百分比</li><li>S1 Survivor1 区占用百分比</li><li>E Eden 区占用百分比</li><li>O 老年代占用百分比</li><li>M 元数据区占用百分比</li><li>CCS 压缩使用百分比</li><li>YGC 年轻代回收次数</li><li>YGCT 年轻代回收耗时（单位秒）</li><li>FGC 老年代回收次数</li><li>FGCT 老年代回收耗时（单位秒）</li><li>GCT 垃圾回收消耗总时间（单位秒）</li></ul></blockquote><h5 id="jstat排查线上内存泄漏" tabindex="-1">jstat排查线上内存泄漏 <a class="header-anchor" href="#jstat排查线上内存泄漏" aria-label="Permalink to &quot;jstat排查线上内存泄漏&quot;">​</a></h5><p>1.<code>TOP FREE DF</code> 命令</p><p>2.<code>jstat -gc pid [interval]</code> 命令 查看 java 进程的 GC 状态,排查FGC值</p><p>jstat [-options] pid interval</p><ul><li><p>-class 查看类加载信息</p></li><li><p>-compile 编译统计信息</p></li><li><p>-gc 垃圾回收信息</p></li><li><p>-gcXXX 各区域 GC 的详细信息 如 -gcold</p></li></ul><p>3.使用 <code>jstack pid &gt; jstack.log</code> 保存线程栈现场，使用 <code>jmap -dump:format=b,file=heap.log pid</code> 保存堆现场</p><p>4.分析栈 <code>grep &#39;java.lang.Thread.State&#39; jstack.log | wc -l</code> 查看线程数</p><p>5.下载堆 dump 文件 <code>gzip</code> 设置推荐使用 6~7下载压缩文件,将文件后缀改为 <code>.hprof</code>,使用 MAT 分析 jvm heap,选择 <code>memory leak suspect</code></p><h4 id="jstack" tabindex="-1">jstack <a class="header-anchor" href="#jstack" aria-label="Permalink to &quot;jstack&quot;">​</a></h4><blockquote><p>通过命令行工具 jstack，实现抓取线程栈的操作</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">jstack pid</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">jstack pid</span></span></code></pre></div></blockquote><h5 id="jstack排查线上cpu100" tabindex="-1">jstack排查线上cpu100% <a class="header-anchor" href="#jstack排查线上cpu100" aria-label="Permalink to &quot;jstack排查线上cpu100%&quot;">​</a></h5><ol><li>top命令找到最耗cpu的进程</li><li>top -Hp 进程id 找到最耗cpu的线程</li><li>jstack pid 查看线程堆栈</li><li>定位代码</li></ol><h3 id="arthas" tabindex="-1">Arthas <a class="header-anchor" href="#arthas" aria-label="Permalink to &quot;Arthas&quot;">​</a></h3><blockquote><p>官方文档：<a href="https://arthas.aliyun.com/doc/commands.html" target="_blank" rel="noreferrer">https://arthas.aliyun.com/doc/commands.html</a></p><p><strong>arthas idea plugin</strong>：<a href="https://www.yuque.com/docs/share/fa77c7b4-c016-4de6-9fa3-58ef25a97948" target="_blank" rel="noreferrer">https://www.yuque.com/docs/share/fa77c7b4-c016-4de6-9fa3-58ef25a97948</a></p></blockquote><p>1.提供性能看板，包括线程、cpu、内存等信息，并且会定时的刷新。</p><p>2.根据各种条件查看线程快照。找出cpu占用率最高的n个线程</p><p>3.输出jvm的各种信息，如gc算法、jdk版本、ClassPath等</p><p>4.遇到问题无法在线上 debug，热部署加日志直接替换</p><p>5.查看某个类的静态属性，也可以通过ognl语法执行一些语句</p><p>6.查看已加载的类的详细信息，这个类从哪个jar包加载的，查看类的方法的信息</p><p>7.dump 类的字节码到指定目录</p><p>8.直接反编译指定的类</p><p>9.快速定位应用的热点，生成火焰图</p><p>10.可以监控到JVM的实时运行状态</p><table><thead><tr><th>命令</th><th>示例</th><th>作用</th></tr></thead><tbody><tr><td>dashboard</td><td></td><td>用于整体展示进程所有线程、内存、GC 等情况</td></tr><tr><td>thread -n</td><td>thread -n 8</td><td>查看最繁忙的8个线程在执行的线程栈</td></tr><tr><td>jad</td><td>jad com.open.Application</td><td>反编译 Application.class</td></tr><tr><td>watch</td><td>watch com.open.order.HighCPUApplication doTask &#39;{params}&#39; &#39;#cost&gt;100&#39; -x 2</td><td>监控耗时超过 100 毫秒的 doTask 方法的入参，并且输出入参，展开 2 层入参参数</td></tr><tr><td>ArthasHotSwap</td><td></td><td>热部署</td></tr></tbody></table><h3 id="mat" tabindex="-1">MAT <a class="header-anchor" href="#mat" aria-label="Permalink to &quot;MAT&quot;">​</a></h3><blockquote><p>官方文档：<a href="https://www.eclipse.org/mat/" target="_blank" rel="noreferrer">https://www.eclipse.org/mat/</a></p></blockquote><blockquote><p>排查 OOM 问题、分析程序堆内存使用情况，分析堆转储（包含了堆现场全貌和线程栈信息）。</p></blockquote><ol><li>通过支配树功能或直方图功能查看消耗内存最大的类型，来分析内存泄露的大概原因；</li><li>查看那些消耗内存最大的类型、详细的对象明细列表，以及它们的引用链，来定位内存泄露的具体点；</li><li>配合查看对象属性的功能，可以脱离源码看到对象的各种属性的值和依赖关系，帮助我们理清程序逻辑和参数；</li><li>辅助使用查看线程栈来看 OOM 问题是否和过多线程有关，甚至可以在线程栈看到 OOM 最后一刻出现异常的线程。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405292206167.png" alt="image-20220727115946296"></p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405292206317.png" alt="image-20220727120007646"></p><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><p><a href="https://juejin.cn/post/7226740776226078775" target="_blank" rel="noreferrer">使用MAT定位OOM异常代码</a></p><p><a href="https://juejin.cn/post/7291931708920512527" target="_blank" rel="noreferrer">工作六年，我学会了用 Arthas 来辅助我的日常工作</a></p><p><a href="https://juejin.cn/post/7259320326898876477" target="_blank" rel="noreferrer">通过 Arthas Trace 命令将接口性能优化十倍</a></p><p><a href="https://juejin.cn/post/7193589542278922295" target="_blank" rel="noreferrer">Arthas 日常记录</a></p>',52),r=[i];function s(p,c,d,n,h,u){return t(),e("div",null,r)}const k=a(o,[["render",s]]);export{m as __pageData,k as default};
