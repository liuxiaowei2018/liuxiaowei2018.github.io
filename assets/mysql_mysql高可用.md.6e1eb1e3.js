import{_ as s,o as a,c as l,Q as e}from"./chunks/framework.8048b864.js";const g=JSON.parse('{"title":"MySQL-高可用","description":"","frontmatter":{},"headers":[],"relativePath":"mysql/mysql高可用.md","filePath":"mysql/mysql高可用.md","lastUpdated":1719224116000}'),n={name:"mysql/mysql高可用.md"},p=e(`<h1 id="mysql-高可用" tabindex="-1">MySQL-高可用 <a class="header-anchor" href="#mysql-高可用" aria-label="Permalink to &quot;MySQL-高可用&quot;">​</a></h1><h3 id="_1、分库分表" tabindex="-1">1、分库分表 <a class="header-anchor" href="#_1、分库分表" aria-label="Permalink to &quot;1、分库分表&quot;">​</a></h3><blockquote><p>分库分表包括分库和分表两个部分，通常包括：垂直分库、水平分库、垂直分表、水平分表四种方式。</p></blockquote><h4 id="垂直分表" tabindex="-1">垂直分表 <a class="header-anchor" href="#垂直分表" aria-label="Permalink to &quot;垂直分表&quot;">​</a></h4><blockquote><p>定义：将一个表按照字段分成多表，每个表存储其中一部分字段。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">它带来的提升是：</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">.为了避免IO争抢并减少锁表的几率</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">.充分发挥热门数据的操作效率</span></span>
<span class="line"><span style="color:#E1E4E8;">一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的商品描述。所以，当表数据量很大时，可以将表按字段切开，将热门字段、冷门字段分开放置在不同库中，这些库可以放在不同的存储设备上，避免IO争抢。垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">通常我们按以下原则进行垂直拆分:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">. 把不常用的字段单独放在一张表;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">. 把text，blob等大字段拆分出来放在附表中;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">. 经常组合查询的列放在一张表中;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">它带来的提升是：</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">.为了避免IO争抢并减少锁表的几率</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">.充分发挥热门数据的操作效率</span></span>
<span class="line"><span style="color:#24292E;">一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的商品描述。所以，当表数据量很大时，可以将表按字段切开，将热门字段、冷门字段分开放置在不同库中，这些库可以放在不同的存储设备上，避免IO争抢。垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">通常我们按以下原则进行垂直拆分:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">. 把不常用的字段单独放在一张表;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">. 把text，blob等大字段拆分出来放在附表中;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">. 经常组合查询的列放在一张表中;</span></span></code></pre></div></blockquote><h4 id="垂直分库" tabindex="-1">垂直分库 <a class="header-anchor" href="#垂直分库" aria-label="Permalink to &quot;垂直分库&quot;">​</a></h4><blockquote><p>定义：垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">它带来的提升是：</span></span>
<span class="line"><span style="color:#E1E4E8;">解决业务层面的耦合，业务清晰</span></span>
<span class="line"><span style="color:#E1E4E8;">能对不同业务的数据进行分级管理、维护、监控、扩展等</span></span>
<span class="line"><span style="color:#E1E4E8;">高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈</span></span>
<span class="line"><span style="color:#E1E4E8;">垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">它带来的提升是：</span></span>
<span class="line"><span style="color:#24292E;">解决业务层面的耦合，业务清晰</span></span>
<span class="line"><span style="color:#24292E;">能对不同业务的数据进行分级管理、维护、监控、扩展等</span></span>
<span class="line"><span style="color:#24292E;">高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈</span></span>
<span class="line"><span style="color:#24292E;">垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题</span></span></code></pre></div></blockquote><h4 id="水平分库" tabindex="-1">水平分库 <a class="header-anchor" href="#水平分库" aria-label="Permalink to &quot;水平分库&quot;">​</a></h4><blockquote><p>定义：水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">它带来的提升是：</span></span>
<span class="line"><span style="color:#E1E4E8;">解决了单库大数据，高并发的性能瓶颈</span></span>
<span class="line"><span style="color:#E1E4E8;">提高了系统的稳定性及可用性</span></span>
<span class="line"><span style="color:#E1E4E8;">当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平分库了，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但由于同一个表被分配在不同的数据库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">它带来的提升是：</span></span>
<span class="line"><span style="color:#24292E;">解决了单库大数据，高并发的性能瓶颈</span></span>
<span class="line"><span style="color:#24292E;">提高了系统的稳定性及可用性</span></span>
<span class="line"><span style="color:#24292E;">当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平分库了，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但由于同一个表被分配在不同的数据库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度</span></span></code></pre></div></blockquote><h4 id="水平分表" tabindex="-1">水平分表 <a class="header-anchor" href="#水平分表" aria-label="Permalink to &quot;水平分表&quot;">​</a></h4><blockquote><p>定义：水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">它带来的提升是：</span></span>
<span class="line"><span style="color:#E1E4E8;">优化单一表数据量过大而产生的性能问题</span></span>
<span class="line"><span style="color:#E1E4E8;">避免IO争抢并减少锁表的几率库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，使得单个表的数据量变小，提高检索性能。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">它带来的提升是：</span></span>
<span class="line"><span style="color:#24292E;">优化单一表数据量过大而产生的性能问题</span></span>
<span class="line"><span style="color:#24292E;">避免IO争抢并减少锁表的几率库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，使得单个表的数据量变小，提高检索性能。</span></span></code></pre></div></blockquote><h4 id="sharding-策略" tabindex="-1">Sharding 策略 <a class="header-anchor" href="#sharding-策略" aria-label="Permalink to &quot;Sharding 策略&quot;">​</a></h4><ul><li>哈希取模：hash(key)%N</li><li>范围：可以是 ID 范围也可以是时间范围</li><li>映射表：使用单独的一个数据库来存储映射关系</li></ul><h4 id="分库分表带来的问题" tabindex="-1">分库分表带来的问题 <a class="header-anchor" href="#分库分表带来的问题" aria-label="Permalink to &quot;分库分表带来的问题&quot;">​</a></h4><blockquote><p>事务一致性问题 - 分布式事务解决方案</p><p>跨节点关联查询 - 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><p>跨节点分页、排序函数</p><p>主键避重 - 单独设计全局主键，避免跨库主键重复问题</p><ul><li>使用全局唯一 ID （GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器（如 Twitter 的 Snowflake 算法）</li></ul><p>公共表</p></blockquote><h3 id="_2、主从复制" tabindex="-1">2、主从复制 <a class="header-anchor" href="#_2、主从复制" aria-label="Permalink to &quot;2、主从复制&quot;">​</a></h3><blockquote><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。</p></blockquote><h4 id="主从复制原理" tabindex="-1">主从复制原理 <a class="header-anchor" href="#主从复制原理" aria-label="Permalink to &quot;主从复制原理&quot;">​</a></h4><blockquote><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li>I/O 线程 ：负责从主服务器上读取- 二进制日志，并写入从服务器的中继日志（Relay log）。</li><li>SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627087.png" alt="image-20220319124728758"></p><ul><li>sql主库在事务提交时会把数据变更作为事件记录在二进制日志Binlog中；</li><li>主库推送二进制日志文件Binlog中的事件到从库的中继日志Relay Log中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；</li><li>sql通过三个线程来完成主从库间的数据复制，其中Binlog Dump线程跑在主库上，I/O线程和SQL线程跑着从库上；</li><li>当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I/O线程，I/O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用，如下图所示。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627022.png" alt="image-20220319130219491"></p></blockquote><h4 id="实例搭建" tabindex="-1">实例搭建 <a class="header-anchor" href="#实例搭建" aria-label="Permalink to &quot;实例搭建&quot;">​</a></h4><h5 id="主实例搭建" tabindex="-1">主实例搭建 <a class="header-anchor" href="#主实例搭建" aria-label="Permalink to &quot;主实例搭建&quot;">​</a></h5><ul><li>运行sql主实例：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker run -p 3307:3306 --name sql-master \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-master/log:/var/log/sql \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-master/data:/var/lib/sql \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-master/conf:/etc/sql \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-e sql_ROOT_PASSWORD=root  \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-d sql:5.7</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker run -p 3307:3306 --name sql-master \\</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-master/log:/var/log/sql \\</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-master/data:/var/lib/sql \\</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-master/conf:/etc/sql \\</span></span>
<span class="line"><span style="color:#24292e;">-e sql_ROOT_PASSWORD=root  \\</span></span>
<span class="line"><span style="color:#24292e;">-d sql:5.7</span></span></code></pre></div><ul><li>在sql的配置文件夹<code>/mydata/sql-master/conf</code>中创建一个配置文件<code>my.cnf</code>：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">touch my.cnf</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">touch my.cnf</span></span></code></pre></div><ul><li>修改配置文件my.cnf，配置信息如下：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">[sqld]</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#e1e4e8;">server_id=101</span></span>
<span class="line"><span style="color:#e1e4e8;">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog-ignore-db=sql</span></span>
<span class="line"><span style="color:#e1e4e8;">## 开启二进制日志功能</span></span>
<span class="line"><span style="color:#e1e4e8;">log-bin=mall-sql-bin</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog_cache_size=1M</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog_format=mixed</span></span>
<span class="line"><span style="color:#e1e4e8;">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span>
<span class="line"><span style="color:#e1e4e8;">expire_logs_days=7</span></span>
<span class="line"><span style="color:#e1e4e8;">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span>
<span class="line"><span style="color:#e1e4e8;">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#e1e4e8;">slave_skip_errors=1062</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">[sqld]</span></span>
<span class="line"><span style="color:#24292e;">## 设置server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#24292e;">server_id=101</span></span>
<span class="line"><span style="color:#24292e;">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#24292e;">binlog-ignore-db=sql</span></span>
<span class="line"><span style="color:#24292e;">## 开启二进制日志功能</span></span>
<span class="line"><span style="color:#24292e;">log-bin=mall-sql-bin</span></span>
<span class="line"><span style="color:#24292e;">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#24292e;">binlog_cache_size=1M</span></span>
<span class="line"><span style="color:#24292e;">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#24292e;">binlog_format=mixed</span></span>
<span class="line"><span style="color:#24292e;">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span>
<span class="line"><span style="color:#24292e;">expire_logs_days=7</span></span>
<span class="line"><span style="color:#24292e;">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span>
<span class="line"><span style="color:#24292e;">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#24292e;">slave_skip_errors=1062</span></span></code></pre></div><ul><li>修改完配置后重启实例：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker restart sql-master</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker restart sql-master</span></span></code></pre></div><ul><li>进入<code>sql-master</code>容器中：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker exec -it sql-master /bin/bash</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker exec -it sql-master /bin/bash</span></span></code></pre></div><ul><li>在容器中使用sql的登录命令连接到客户端：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql -uroot -proot</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql -uroot -proot</span></span></code></pre></div><ul><li>创建数据同步用户：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span></span>
<span class="line"><span style="color:#e1e4e8;">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;slave&#39;@&#39;%&#39;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span></span>
<span class="line"><span style="color:#24292e;">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;slave&#39;@&#39;%&#39;;</span></span></code></pre></div><h5 id="从实例搭建" tabindex="-1">从实例搭建 <a class="header-anchor" href="#从实例搭建" aria-label="Permalink to &quot;从实例搭建&quot;">​</a></h5><ul><li>运行sql从实例：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker run -p 3308:3306 --name sql-slave \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-slave/log:/var/log/sql \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-slave/data:/var/lib/sql \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-v /mydata/sql-slave/conf:/etc/sql \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-e sql_ROOT_PASSWORD=root  \\</span></span>
<span class="line"><span style="color:#e1e4e8;">-d sql:5.7</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker run -p 3308:3306 --name sql-slave \\</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-slave/log:/var/log/sql \\</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-slave/data:/var/lib/sql \\</span></span>
<span class="line"><span style="color:#24292e;">-v /mydata/sql-slave/conf:/etc/sql \\</span></span>
<span class="line"><span style="color:#24292e;">-e sql_ROOT_PASSWORD=root  \\</span></span>
<span class="line"><span style="color:#24292e;">-d sql:5.7</span></span></code></pre></div><ul><li>在sql的配置文件夹<code>/mydata/sql-slave/conf</code>中创建一个配置文件<code>my.cnf</code>：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">touch my.cnf</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">touch my.cnf</span></span></code></pre></div><ul><li>修改配置文件my.cnf：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">[sqld]</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#e1e4e8;">server_id=102</span></span>
<span class="line"><span style="color:#e1e4e8;">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog-ignore-db=sql</span></span>
<span class="line"><span style="color:#e1e4e8;">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span>
<span class="line"><span style="color:#e1e4e8;">log-bin=mall-sql-slave1-bin</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog_cache_size=1M</span></span>
<span class="line"><span style="color:#e1e4e8;">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#e1e4e8;">binlog_format=mixed</span></span>
<span class="line"><span style="color:#e1e4e8;">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span>
<span class="line"><span style="color:#e1e4e8;">expire_logs_days=7</span></span>
<span class="line"><span style="color:#e1e4e8;">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span>
<span class="line"><span style="color:#e1e4e8;">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#e1e4e8;">slave_skip_errors=1062</span></span>
<span class="line"><span style="color:#e1e4e8;">## relay_log配置中继日志</span></span>
<span class="line"><span style="color:#e1e4e8;">relay_log=mall-sql-relay-bin</span></span>
<span class="line"><span style="color:#e1e4e8;">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span>
<span class="line"><span style="color:#e1e4e8;">log_slave_updates=1</span></span>
<span class="line"><span style="color:#e1e4e8;">## slave设置为只读（具有super权限的用户除外）</span></span>
<span class="line"><span style="color:#e1e4e8;">read_only=1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">[sqld]</span></span>
<span class="line"><span style="color:#24292e;">## 设置server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#24292e;">server_id=102</span></span>
<span class="line"><span style="color:#24292e;">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#24292e;">binlog-ignore-db=sql</span></span>
<span class="line"><span style="color:#24292e;">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span>
<span class="line"><span style="color:#24292e;">log-bin=mall-sql-slave1-bin</span></span>
<span class="line"><span style="color:#24292e;">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#24292e;">binlog_cache_size=1M</span></span>
<span class="line"><span style="color:#24292e;">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#24292e;">binlog_format=mixed</span></span>
<span class="line"><span style="color:#24292e;">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span>
<span class="line"><span style="color:#24292e;">expire_logs_days=7</span></span>
<span class="line"><span style="color:#24292e;">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span>
<span class="line"><span style="color:#24292e;">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#24292e;">slave_skip_errors=1062</span></span>
<span class="line"><span style="color:#24292e;">## relay_log配置中继日志</span></span>
<span class="line"><span style="color:#24292e;">relay_log=mall-sql-relay-bin</span></span>
<span class="line"><span style="color:#24292e;">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span>
<span class="line"><span style="color:#24292e;">log_slave_updates=1</span></span>
<span class="line"><span style="color:#24292e;">## slave设置为只读（具有super权限的用户除外）</span></span>
<span class="line"><span style="color:#24292e;">read_only=1</span></span></code></pre></div><ul><li>修改完配置后重启实例：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker restart sql-slave</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker restart sql-slave</span></span></code></pre></div><h5 id="主从连接" tabindex="-1">主从连接 <a class="header-anchor" href="#主从连接" aria-label="Permalink to &quot;主从连接&quot;">​</a></h5><ul><li>连接到主数据库的sql客户端，查看主数据库状态：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">show master status;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">show master status;</span></span></code></pre></div><ul><li>主数据库状态显示如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627221.png" alt="图片"></p><ul><li>进入<code>sql-slave</code>容器中：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker exec -it sql-slave /bin/bash</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker exec -it sql-slave /bin/bash</span></span></code></pre></div><ul><li>在容器中使用sql的登录命令连接到客户端：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sql -uroot -proot</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sql -uroot -proot</span></span></code></pre></div><ul><li>在从数据库中配置主从复制：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">change master to master_host=&#39;192.168.6.132&#39;, master_user=&#39;slave&#39;, master_password=&#39;123456&#39;, master_port=3307, master_log_file=&#39;mall-sql-bin.000001&#39;, master_log_pos=617, master_connect_retry=30;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">change master to master_host=&#39;192.168.6.132&#39;, master_user=&#39;slave&#39;, master_password=&#39;123456&#39;, master_port=3307, master_log_file=&#39;mall-sql-bin.000001&#39;, master_log_pos=617, master_connect_retry=30;</span></span></code></pre></div><ul><li><p>主从复制命令参数说明：</p></li><li><ul><li>master_host：主数据库的IP地址；</li><li>master_port：主数据库的运行端口；</li><li>master_user：在主数据库创建的用于同步数据的用户账号；</li><li>master_password：在主数据库创建的用于同步数据的用户密码；</li><li>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</li><li>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</li><li>master_connect_retry：连接失败重试的时间间隔，单位为秒。</li></ul></li><li><p>查看主从同步状态：</p></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">show slave status \\G;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">show slave status \\G;</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627909.jpeg" alt="图片"></p><ul><li>开启主从同步：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">start slave;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">start slave;</span></span></code></pre></div><ul><li>查看从数据库状态发现已经同步：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627581.png" alt="图片"></p><h5 id="主从复制测试" tabindex="-1">主从复制测试 <a class="header-anchor" href="#主从复制测试" aria-label="Permalink to &quot;主从复制测试&quot;">​</a></h5><blockquote><p>主从复制的测试方法有很多，可以在主实例中创建一个数据库，看看从实例中是否有该数据库，如果有，表示主从复制已经搭建成功。</p></blockquote><h3 id="_3、读写分离" tabindex="-1">3、读写分离 <a class="header-anchor" href="#_3、读写分离" aria-label="Permalink to &quot;3、读写分离&quot;">​</a></h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627486.png" alt="image-20220319124748987"></p>`,70),o=[p];function c(t,i,r,d,y,h){return a(),l("div",null,o)}const v=s(n,[["render",c]]);export{g as __pageData,v as default};
