import{_ as e,c as t,o as l,a as o}from"./app.467f35a9.js";const A=JSON.parse('{"title":"AsyncTool","description":"","frontmatter":{},"headers":[{"level":2,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[]}],"relativePath":"study/util/AsyncTool.md"}'),n={name:"study/util/AsyncTool.md"},a=o('<h1 id="asynctool" tabindex="-1">AsyncTool <a class="header-anchor" href="#asynctool" aria-hidden="true">#</a></h1><p><code>AsyncTool框架</code>是一款<strong>多线程并行、串行、阻塞、依赖、回调的并行框架</strong>。</p><h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-hidden="true">#</a></h2><p>1.解决任意的<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;spm=1001.2101.3001.7020" target="_blank" rel="noreferrer">多线程</a>并行、串行、阻塞、依赖、回调。可以任意组合各线程的执行顺序，并且带有全链路执行结果回调。是多线程编排一站式解决方案。</p><p>2.单机不支持分布式编排。</p><p><img src="https://img-blog.csdnimg.cn/d5f7f734baa74c05aa1213968bdfe8af.png#pic_center" alt="在这里插入图片描述"></p><ol><li>串行：A、B、C串行执行，可用的实现方式为：CompletableFuture.thenApply()、thenAccept() 和 thenRun() 都可以实现。</li><li>并行：A、B、C全并行执行，可用的实现方式为：CompletableFuture.allOf()</li><li>阻塞 - 先串行后并行：A执行完毕，B、C全并行执行。可用的实现方式为：CompletableFuture.runAsync()，阻塞get获取结果，再调用CompletableFuture.allOf()</li><li>阻塞 -先并行后串行：B、C全并行执行，执行完毕后，A执行。可用的实现方式为：CompletableFuture.allOf(futures…).then()</li></ol><p><strong>（2）执行顺序的强依赖和若依赖</strong>：如上图中的第④种场景，A依赖于B和C。分以下三种情况</p><ol><li>B、C全部执行完毕之后，才能执行A。可用的实现方式为：CompletableFuture.allOf(futures…).then()；或者runAfterBoth</li><li>B、C任意一个执行完后，就执行A。可用的实现方式为：CompletableFuture里有个anyOf(futures…).then()；或者runAfterEither</li><li>指定B或者C执行完后，就执行A。CompletableFuture不支持。</li></ol><p><strong>（3）并发场景可能存在的需求-每个执行结果的回调</strong></p><p>CompleteableFuture大家都用过，里面有supply、then、combine、allOf等等方法，都可以用来接收一个任务，最终将多个任务汇总成一个结果。</p><p>但有一个问题，你supply一个任务后，<strong>这个任务就黑盒了</strong>。如果你编排了很多个任务，每一个任务的执行情况，执行到哪一步了，每一步的执行结果情况，我们是不知道的。只能等它最终执行完毕后，最后汇总结果。</p><p>一个并行框架，它最好是对每一步的执行都能监控。每一步的执行结果，无论成功与失败，它应该有个<strong>回调</strong>，才算完整。拥有回调的任务，可以监控任务的执行状况，如果执行失败、超时，可以记录异常信息或者处理个性化的<strong>默认值</strong>。</p><p>CompleteableFuture中也有一些回调方法，例如：thenAccept()，whenComplete()，handle()，exceptionally()等，这些方法也能支持任务的回调，但是前提是任务执行了，才能完成回调。在某些场景中，有些任务单元是可能被SKIP跳过不执行的，不执行的任务也应该有回调。</p>',14),r=[a];function s(p,c,i,u,h,d){return l(),t("div",null,r)}const f=e(n,[["render",s]]);export{A as __pageData,f as default};
