import{_ as l,c as e,o,a as n,b as s,d as a}from"./app.467f35a9.js";const D=JSON.parse('{"title":"Sharding-JDBC","description":"","frontmatter":{},"headers":[{"level":2,"title":"分片规则配置","slug":"分片规则配置","link":"#分片规则配置","children":[]},{"level":2,"title":"流程分析","slug":"流程分析","link":"#流程分析","children":[]},{"level":2,"title":"执行原理","slug":"执行原理","link":"#执行原理","children":[]},{"level":2,"title":"SQL解析","slug":"sql解析","link":"#sql解析","children":[]},{"level":2,"title":"配置文件","slug":"配置文件","link":"#配置文件","children":[]}],"relativePath":"study/middleware/ShardingJdbc.md"}'),t={name:"study/middleware/ShardingJdbc.md"},p=n(`<h1 id="sharding-jdbc" tabindex="-1">Sharding-JDBC <a class="header-anchor" href="#sharding-jdbc" aria-hidden="true">#</a></h1><blockquote><p>pom.xml</p><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">org.apache.shardingsphere</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">groupId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">sharding‐jdbc‐spring‐boot‐starter</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">artifactId</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">version</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">4.1.1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">version</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">dependency</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div></blockquote><h2 id="分片规则配置" tabindex="-1">分片规则配置 <a class="header-anchor" href="#分片规则配置" aria-hidden="true">#</a></h2>`,3),r=s("blockquote",null,[s("blockquote",null,[s("div",{class:"language-json"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"json"),s("pre",{class:"shiki material-palenight"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{color:"#A6ACCD"}},"分片规则配置是sharding-jdbc进行对分库分表操作的重要依据，配置内容包括：数据源、主键生成策略、分片策略等")]),a(`
`),s("span",{class:"line"})])])])]),s("blockquote",null,[s("div",{class:"language-yaml"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"yaml"),s("pre",{class:"shiki material-palenight"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{color:"#F07178"}},"server"),s("span",{style:{color:"#89DDFF"}},":")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#F07178"}},"port"),s("span",{style:{color:"#89DDFF"}},":"),s("span",{style:{color:"#A6ACCD"}}," "),s("span",{style:{color:"#F78C6C"}},"15656")]),a(`
`),s("span",{class:"line"})])])])]),s("blockquote",null,[s("p",null,"spring: main: allow-bean-definition-overriding: true application: name: test-service datasource: druid: url: jdbc:mysql://81.68.218.181:3306/test?useUnicode=true&characterEncoding=UTF-8&useSSL=true&serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver username: root password: lxw123456")]),s("blockquote",{order_id:"","%":"",2:"","+":"",1:""},[s("p",null,"shardingsphere: datasource: names: m1 m1: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://81.68.218.181:3306/shardingjdbc_order_db?useUnicode=true&characterEncoding=UTF-8&useSSL=true&serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver username: root password: lxw123456 initial‐size: 5 #初始物理连接数 min‐idle: 5 #最小连接池数量 max‐active: 20 #最大连接池数量 max‐wait: 60000 #获取连接时最大等待时间，单位毫秒 min‐evictable‐idle‐time‐millis: 300000 #连接保持空闲而不被驱逐的最小时间 validation‐query: SELECT 1 FROM DUAL #用来检测连接是否有效的sql test‐while‐idle: true #申请连接的时候检测 pool‐prepared‐statements: false #是否缓存PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 connection‐properties: druid.stat.mergeSql:true;druid.stat.slowSqlMillis:5000 #打开sql合并和慢sql记录 sharding: tables: # 指定t_order表的数据分布情况，配置数据节点 t_order: actual‐data‐nodes: m1.t_order_$->{1..2} key‐generator: # 指定t_order表的主键生成策略为SNOWFLAKE column: order_id type: SNOWFLAKE table‐strategy: # 指定t_order表的分片策略，分片策略包括分片键和分片算法 inline: sharding‐column: order_id algorithm‐expression: t_order_$->")]),s("blockquote",null,[s("p",null,"logging: level: root: info")]),s("blockquote",null,[s("p",null,"mybatis-plus: mapper-locations: classpath:/mapper/*Mapper.xml")]),s("blockquote",null,[s("div",{class:"language-json"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"json"),s("pre",{class:"shiki material-palenight"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{color:"#A6ACCD"}},"#  "),s("span",{style:{color:"#F78C6C"}},"1"),s("span",{style:{color:"#A6ACCD"}},".首先定义数据源m"),s("span",{style:{color:"#F78C6C"}},"1"),s("span",{style:{color:"#A6ACCD"}},"，并对m"),s("span",{style:{color:"#F78C6C"}},"1"),s("span",{style:{color:"#A6ACCD"}},"进行实际的参数配置。")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#A6ACCD"}},"#  "),s("span",{style:{color:"#F78C6C"}},"2"),s("span",{style:{color:"#A6ACCD"}},".指定t_order表的数据分布情况，他分布在m"),s("span",{style:{color:"#F78C6C"}},"1"),s("span",{style:{color:"#A6ACCD"}},".t_order_"),s("span",{style:{color:"#F78C6C"}},"1"),s("span",{style:{color:"#A6ACCD"}},"，m"),s("span",{style:{color:"#F78C6C"}},"1"),s("span",{style:{color:"#A6ACCD"}},".t_order_"),s("span",{style:{color:"#F78C6C"}},"2")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#A6ACCD"}},"#  "),s("span",{style:{color:"#F78C6C"}},"3"),s("span",{style:{color:"#A6ACCD"}},".指定t_order表的主键生成策略为SNOWFLAKE，SNOWFLAKE是一种分布式自增算法，保证id全局唯一")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#A6ACCD"}},"#  "),s("span",{style:{color:"#F78C6C"}},"4"),s("span",{style:{color:"#A6ACCD"}},".定义t_order分片策略，order_id为偶数的数据落在t_order_"),s("span",{style:{color:"#F78C6C"}},"1"),s("span",{style:{color:"#A6ACCD"}},"，为奇数的落在t_order_"),s("span",{style:{color:"#F78C6C"}},"2"),s("span",{style:{color:"#A6ACCD"}},"，分表策略的表达式为 t_order_$->"),s("span",{style:{color:"#89DDFF"}},"{"),s("span",{style:{color:"#A6ACCD"}},"order_id % 2 + 1"),s("span",{style:{color:"#89DDFF"}},"}")]),a(`
`),s("span",{class:"line"})])])])])],-1),c=n(`<h2 id="流程分析" tabindex="-1">流程分析 <a class="header-anchor" href="#流程分析" aria-hidden="true">#</a></h2><blockquote><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">通过日志分析，Sharding-JDBC在拿到用户要执行的sql之后干了哪些事儿：</span></span>
<span class="line"><span style="color:#A6ACCD;">（</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">）解析sql，获取片键值，在本例中是order_id</span></span>
<span class="line"><span style="color:#A6ACCD;">（</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">）Sharding-JDBC通过规则配置 t_order_$-&gt;</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">order_id % 2 + 1</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">，</span></span>
<span class="line"><span style="color:#A6ACCD;">	当order_id为偶数时，应该往t_order_</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">表插数据，为奇数时，往t_order_</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">插数据。</span></span>
<span class="line"><span style="color:#A6ACCD;">（</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">）于是Sharding-JDBC根据order_id的值改写sql语句，改写后的SQL语句是真实所要执行的SQL语句。</span></span>
<span class="line"><span style="color:#A6ACCD;">（</span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">）执行改写后的真实sql语句</span></span>
<span class="line"><span style="color:#A6ACCD;">（</span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">）将所有真正执行sql的结果进行汇总合并，返回。</span></span>
<span class="line"></span></code></pre></div></blockquote><h2 id="执行原理" tabindex="-1">执行原理 <a class="header-anchor" href="#执行原理" aria-hidden="true">#</a></h2><blockquote><h5 id="逻辑表-水平拆分的数据表的总称。" tabindex="-1">逻辑表: 水平拆分的数据表的总称。 <a class="header-anchor" href="#逻辑表-水平拆分的数据表的总称。" aria-hidden="true">#</a></h5><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">例：订单数据表根据主键尾数拆分为</span><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;">张表，分别是 t_order_</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> 、 t_order_</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> 到t_order_</span><span style="color:#F78C6C;">9</span><span style="color:#A6ACCD;"> ，他们的逻辑表名为 t_order</span></span>
<span class="line"></span></code></pre></div><h5 id="真实表-在分片的数据库中真实存在的物理表" tabindex="-1">真实表: 在分片的数据库中真实存在的物理表 <a class="header-anchor" href="#真实表-在分片的数据库中真实存在的物理表" aria-hidden="true">#</a></h5><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">例：上个示例中的 t_order_</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> 到 t_order_</span><span style="color:#F78C6C;">9</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"></span></code></pre></div><h5 id="数据节点" tabindex="-1">数据节点 <a class="header-anchor" href="#数据节点" aria-hidden="true">#</a></h5><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">数据分片的最小物理单元。由数据源名称和数据表组成，例： ds_</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">.t_order_</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"></span></code></pre></div><h5 id="绑定表" tabindex="-1">绑定表 <a class="header-anchor" href="#绑定表" aria-hidden="true">#</a></h5><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">指分片规则一致的主表和子表。</span></span>
<span class="line"></span></code></pre></div><p>...</p></blockquote><h2 id="sql解析" tabindex="-1">SQL解析 <a class="header-anchor" href="#sql解析" aria-hidden="true">#</a></h2><blockquote><p>当Sharding-JDBC接受到一条SQL语句时，会陆续执行 SQL解析 =&gt; 查询优化 =&gt; SQL路由 =&gt; SQL改写 =&gt; SQL执行=&gt; 结果归并 ，最终返回执行结果</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">SQL解析过程分为词法解析和语法解析。 词法解析器用于将SQL拆解为不可再分的原子符号，称为Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将SQL转换为抽象语法树</span></span>
<span class="line"></span></code></pre></div><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">供分片使用的解析上下文包含查询选择项（Select Items）、表信息（Table）、分片条件（Sharding Condition）、</span></span>
<span class="line"><span style="color:#A6ACCD;">自增主键信息（Auto increment Primary Key）、排序信息（Order By）、分组信息（Group By）以及分页信息（Limit、Rownum、Top）</span></span>
<span class="line"></span></code></pre></div><p>...</p></blockquote><h2 id="配置文件" tabindex="-1">配置文件 <a class="header-anchor" href="#配置文件" aria-hidden="true">#</a></h2><blockquote><div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">#  shardingsphere:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#    datasource:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#      names: m1</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#      m1:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        type: com.alibaba.druid.pool.DruidDataSource</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        url: jdbc:mysql://81.68.218.181:3306/shardingjdbc_order_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        driver-class-name: com.mysql.cj.jdbc.Driver</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        username: root</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        password: lxw123456</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        initial‐size: 5 #初始物理连接数</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        min‐idle: 5 #最小连接池数量</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        max‐active: 20 #最大连接池数量</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        max‐wait: 60000 #获取连接时最大等待时间，单位毫秒</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        min‐evictable‐idle‐time‐millis: 300000 #连接保持空闲而不被驱逐的最小时间</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        validation‐query: SELECT 1 FROM DUAL #用来检测连接是否有效的sql</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        test‐while‐idle: true #申请连接的时候检测</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        pool‐prepared‐statements: false #是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        connection‐properties: druid.stat.mergeSql:true;druid.stat.slowSqlMillis:5000 #打开sql合并和慢sql记录</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#    sharding:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#      tables: # 指定t_order表的数据分布情况，配置数据节点</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#        t_order:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#          actual‐data‐nodes: m1.t_order_$-&gt;{1..2}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#          key‐generator:  # 指定t_order表的主键生成策略为SNOWFLAKE</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#            column: order_id</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#            type: SNOWFLAKE</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#          table‐strategy: # 指定t_order表的分片策略，分片策略包括分片键和分片算法</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#            inline:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#              sharding‐column: order_id</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#              algorithm‐expression: t_order_$-&gt;{order_id % 2 + 1}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#  1.首先定义数据源m1，并对m1进行实际的参数配置。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#  2.指定t_order表的数据分布情况，他分布在m1.t_order_1，m1.t_order_2</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#  3.指定t_order表的主键生成策略为SNOWFLAKE，SNOWFLAKE是一种分布式自增算法，保证id全局唯一</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#  4.定义t_order分片策略，order_id为偶数的数据落在t_order_1，为奇数的落在t_order_2，分表策略的表达式为 t_order_$-&gt;{order_id % 2 + 1}</span></span>
<span class="line"></span></code></pre></div></blockquote>`,8),i=[p,r,c];function d(y,C,u,h,_,A){return o(),e("div",null,i)}const m=l(t,[["render",d]]);export{D as __pageData,m as default};
