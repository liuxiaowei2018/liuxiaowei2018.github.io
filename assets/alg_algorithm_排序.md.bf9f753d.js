import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.8048b864.js";const p="/assets/image-20231019140356120.d6ba67b1.png",o="/assets/image-20231019140403938.20cf625c.png",e="/assets/image-20231019140556600.9c575ed6.png",t="/assets/image-20221206130817831.a93c5f16.png",c="/assets/image-20231019141135800.2f54561e.png",r="/assets/image-20221206130915912.16f11fcc.png",E="/assets/image-20221206130933255.9490a1c6.png",y="/assets/image-20221206130941831.f13e911c.png",i="/assets/image-20221206130639622.37a6cb73.png",F="/assets/image-20221206131020730.8b39dc9a.png",A="/assets/image-20221206131051430.6efb9d41.png",D="/assets/image-20231019173848062.18c9a6a4.png",B=JSON.parse('{"title":"排序算法","description":"","frontmatter":{},"headers":[],"relativePath":"alg/algorithm/排序.md","filePath":"alg/algorithm/排序.md","lastUpdated":1697788437000}'),d={name:"alg/algorithm/排序.md"},m=l('<h1 id="排序算法" tabindex="-1">排序算法 <a class="header-anchor" href="#排序算法" aria-label="Permalink to &quot;排序算法&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#_1、冒泡排序">1、冒泡排序</a><ul><li><a href="#算法流程">算法流程</a></li><li><a href="#冒泡优化">冒泡优化</a></li></ul></li><li><a href="#_2、选择排序">2、选择排序</a></li><li><a href="#_3、插入排序">3、插入排序</a></li><li><a href="#_4、归并排序">4、归并排序</a></li><li><a href="#_5、快速排序">5、快速排序</a></li><li><a href="#_6、堆排序">6、堆排序</a></li><li><a href="#_7、桶排序">7、桶排序</a></li><li><a href="#_8、计数排序">8、计数排序</a></li><li><a href="#时间复杂度对比">时间复杂度对比</a></li></ul></nav><h2 id="_1、冒泡排序" tabindex="-1">1、冒泡排序 <a class="header-anchor" href="#_1、冒泡排序" aria-label="Permalink to &quot;1、冒泡排序&quot;">​</a></h2><p>冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 &gt; 右元素”就交换它俩。遍历完成后，最大的元素会被移动到数组的最右端。</p><p><img src="'+p+'" alt="image-20231019140356120"></p><p><img src="'+o+'" alt="image-20231019140403938"></p><h3 id="算法流程" tabindex="-1">算法流程 <a class="header-anchor" href="#算法流程" aria-label="Permalink to &quot;算法流程&quot;">​</a></h3><p>设数组的长度为 (n) ，冒泡排序的步骤如图所示。</p><ol><li>首先，对 (n) 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong>，</li><li>接下来，对剩余 (n - 1) 个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong>。</li><li>以此类推，经过 (n - 1) 轮“冒泡”后，<strong>前 (n - 1) 大的元素都被交换至正确位置</strong>。</li><li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li></ol><p><img src="'+e+`" alt="image-20231019140556600"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 冒泡排序 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">bubbleSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 外循环：未排序区间为 [0, i]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> i; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nums[j] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> nums[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 交换 nums[j] 与 nums[j + 1]</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[j];</span></span>
<span class="line"><span style="color:#E1E4E8;">                nums[j] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">                nums[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 冒泡排序 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">bubbleSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 外循环：未排序区间为 [0, i]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> i; j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nums[j] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> nums[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 交换 nums[j] 与 nums[j + 1]</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> tmp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[j];</span></span>
<span class="line"><span style="color:#24292E;">                nums[j] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">                nums[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tmp;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="冒泡优化" tabindex="-1">冒泡优化 <a class="header-anchor" href="#冒泡优化" aria-label="Permalink to &quot;冒泡优化&quot;">​</a></h3><p>如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 <code>flag</code> 来监测这种情况，一旦出现就立即返回。</p><p>经过优化，冒泡排序的最差和平均时间复杂度仍为 (O(n^2)) ；但当输入数组完全有序时，可达到最佳时间复杂度 (O(n)) 。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 冒泡排序（标志优化） */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">bubbleSortWithFlag</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 外循环：未排序区间为 [0, i]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> flag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 初始化标志位</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> i; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nums[j] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> nums[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 交换 nums[j] 与 nums[j + 1]</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[j];</span></span>
<span class="line"><span style="color:#E1E4E8;">                nums[j] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">                nums[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp;</span></span>
<span class="line"><span style="color:#E1E4E8;">                flag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 记录交换元素</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">flag)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 此轮冒泡未交换任何元素，直接跳出</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 冒泡排序（标志优化） */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">bubbleSortWithFlag</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 外循环：未排序区间为 [0, i]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> flag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 初始化标志位</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> i; j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nums[j] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> nums[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 交换 nums[j] 与 nums[j + 1]</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> tmp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[j];</span></span>
<span class="line"><span style="color:#24292E;">                nums[j] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">                nums[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tmp;</span></span>
<span class="line"><span style="color:#24292E;">                flag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 记录交换元素</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">flag)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 此轮冒泡未交换任何元素，直接跳出</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_2、选择排序" tabindex="-1">2、选择排序 <a class="header-anchor" href="#_2、选择排序" aria-label="Permalink to &quot;2、选择排序&quot;">​</a></h2><p>「选择排序 selection sort」的工作原理非常直接：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</p><p>设数组的长度为 (n) ，选择排序的算法流程如图 11-2 所示。</p><ol><li>初始状态下，所有元素未排序，即未排序（索引）区间为 ([0, n-1]) 。</li><li>选取区间 ([0, n-1]) 中的最小元素，将其与索引 (0) 处元素交换。完成后，数组前 1 个元素已排序。</li><li>选取区间 ([1, n-1]) 中的最小元素，将其与索引 (1) 处元素交换。完成后，数组前 2 个元素已排序。</li><li>以此类推。经过 (n - 1) 轮选择与交换后，数组前 (n - 1) 个元素已排序。</li><li>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。</li></ol><p><img src="`+t+`" alt="image-20221206130817831"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 选择排序 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">selectionSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 外循环：未排序区间为 [i, n-1]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 内循环：找到未排序区间内的最小元素</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nums[j] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> nums[k])</span></span>
<span class="line"><span style="color:#E1E4E8;">                k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> j; </span><span style="color:#6A737D;">// 记录最小元素的索引</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将该最小元素与未排序区间的首个元素交换</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">        nums[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[k];</span></span>
<span class="line"><span style="color:#E1E4E8;">        nums[k] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> temp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 选择排序 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">selectionSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 外循环：未排序区间为 [i, n-1]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 内循环：找到未排序区间内的最小元素</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> n; j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nums[j] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> nums[k])</span></span>
<span class="line"><span style="color:#24292E;">                k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> j; </span><span style="color:#6A737D;">// 记录最小元素的索引</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将该最小元素与未排序区间的首个元素交换</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> temp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[i];</span></span>
<span class="line"><span style="color:#24292E;">        nums[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[k];</span></span>
<span class="line"><span style="color:#24292E;">        nums[k] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> temp;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_3、插入排序" tabindex="-1">3、插入排序 <a class="header-anchor" href="#_3、插入排序" aria-label="Permalink to &quot;3、插入排序&quot;">​</a></h2><p>「插入排序 insertion sort」是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</p><p>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</p><p>图展示了数组插入元素的操作流程。设基准元素为 <code>base</code> ，我们需要将从目标索引到 <code>base</code> 之间的所有元素向右移动一位，然后再将 <code>base</code> 赋值给目标索引。</p><p><img src="`+c+`" alt="image-20231019141135800"></p><p>插入排序的整体流程如图所示。</p><ol><li>初始状态下，数组的第 1 个元素已完成排序。</li><li>选取数组的第 2 个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>数组的前 2 个元素已排序</strong>。</li><li>选取第 3 个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>数组的前 3 个元素已排序</strong>。</li><li>以此类推，在最后一轮中，选取最后一个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>所有元素均已排序</strong>。</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 插入排序 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">insertionSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 外循环：已排序元素数量为 1, 2, ..., n</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> nums.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> base </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[i], j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 内循环：将 base 插入到已排序部分的正确位置</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> nums[j] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> base) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            nums[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[j]; </span><span style="color:#6A737D;">// 将 nums[j] 向右移动一位</span></span>
<span class="line"><span style="color:#E1E4E8;">            j</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        nums[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> base;        </span><span style="color:#6A737D;">// 将 base 赋值到正确位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 插入排序 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">insertionSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 外循环：已排序元素数量为 1, 2, ..., n</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> nums.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> base </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[i], j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 内循环：将 base 插入到已排序部分的正确位置</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (j </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> nums[j] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> base) {</span></span>
<span class="line"><span style="color:#24292E;">            nums[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[j]; </span><span style="color:#6A737D;">// 将 nums[j] 向右移动一位</span></span>
<span class="line"><span style="color:#24292E;">            j</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        nums[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> base;        </span><span style="color:#6A737D;">// 将 base 赋值到正确位置</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_4、归并排序" tabindex="-1">4、归并排序 <a class="header-anchor" href="#_4、归并排序" aria-label="Permalink to &quot;4、归并排序&quot;">​</a></h2><p>简单的说把一串数从中平等分为两份,再把两份再细分,直到不能细分为止. 这就是分而治之的分的步骤. 再从最小的单元,两两合并,合并的规则是将其按从小到大的顺序放到一个临时数组中,再把这个临时数组替换原数组相应位置,这就是治. 图解如下:</p><p><img src="`+r+'" alt="image-20221206130915912"></p><p><img src="'+E+'" alt="image-20221206130933255"></p><p><img src="'+y+`" alt="image-20221206130941831"></p><p>如图所示，“划分阶段”从顶至底递归地将数组从中点切分为两个子数组。</p><ol><li>计算数组中点 <code>mid</code> ，递归划分左子数组（区间 <code>[left, mid]</code> ）和右子数组（区间 <code>[mid + 1, right]</code> ）。</li><li>递归执行步骤 <code>1.</code> ，直至子数组区间长度为 1 时，终止递归划分。</li></ol><p>“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 合并左子数组和右子数组 */</span></span>
<span class="line"><span style="color:#6A737D;">// 左子数组区间 [left, mid]</span></span>
<span class="line"><span style="color:#6A737D;">// 右子数组区间 [mid + 1, right]</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">merge</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> mid, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化辅助数组</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Arrays.</span><span style="color:#B392F0;">copyOfRange</span><span style="color:#E1E4E8;">(nums, left, right </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 左子数组的起始索引和结束索引</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> leftStart </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> left, leftEnd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> left;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 右子数组的起始索引和结束索引</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> rightStart </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> left, rightEnd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> right </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> left;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// i, j 分别指向左子数组、右子数组的首元素</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> leftStart, j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> rightStart;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过覆盖原数组 nums 来合并左子数组和右子数组</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> left; k </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> right; k</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 若“左子数组已全部合并完”，则选取右子数组元素，并且 j++</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> leftEnd)</span></span>
<span class="line"><span style="color:#E1E4E8;">            nums[k] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp[j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 否则，若“右子数组已全部合并完”或“左子数组元素 &lt;= 右子数组元素”，则选取左子数组元素，并且 i++</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> rightEnd </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> tmp[i] </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> tmp[j])</span></span>
<span class="line"><span style="color:#E1E4E8;">            nums[k] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp[i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 否则，若“左右子数组都未全部合并完”且“左子数组元素 &gt; 右子数组元素”，则选取右子数组元素，并且 j++</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">            nums[k] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp[j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 归并排序 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mergeSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 终止条件</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> right)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;                      </span><span style="color:#6A737D;">// 当子数组长度为 1 时终止递归</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 划分阶段</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> right) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;    </span><span style="color:#6A737D;">// 计算中点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">mergeSort</span><span style="color:#E1E4E8;">(nums, left, mid);      </span><span style="color:#6A737D;">// 递归左子数组</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">mergeSort</span><span style="color:#E1E4E8;">(nums, mid </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, right); </span><span style="color:#6A737D;">// 递归右子数组</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 合并阶段</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">merge</span><span style="color:#E1E4E8;">(nums, left, mid, right);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 合并左子数组和右子数组 */</span></span>
<span class="line"><span style="color:#6A737D;">// 左子数组区间 [left, mid]</span></span>
<span class="line"><span style="color:#6A737D;">// 右子数组区间 [mid + 1, right]</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">merge</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> left, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> mid, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> right) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化辅助数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] tmp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Arrays.</span><span style="color:#6F42C1;">copyOfRange</span><span style="color:#24292E;">(nums, left, right </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 左子数组的起始索引和结束索引</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> leftStart </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> left, leftEnd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mid </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> left;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 右子数组的起始索引和结束索引</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> rightStart </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mid </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> left, rightEnd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> right </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> left;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// i, j 分别指向左子数组、右子数组的首元素</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> leftStart, j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> rightStart;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过覆盖原数组 nums 来合并左子数组和右子数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> left; k </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> right; k</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 若“左子数组已全部合并完”，则选取右子数组元素，并且 j++</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> leftEnd)</span></span>
<span class="line"><span style="color:#24292E;">            nums[k] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tmp[j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 否则，若“右子数组已全部合并完”或“左子数组元素 &lt;= 右子数组元素”，则选取左子数组元素，并且 i++</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (j </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> rightEnd </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> tmp[i] </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> tmp[j])</span></span>
<span class="line"><span style="color:#24292E;">            nums[k] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tmp[i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 否则，若“左右子数组都未全部合并完”且“左子数组元素 &gt; 右子数组元素”，则选取右子数组元素，并且 j++</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">            nums[k] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tmp[j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/* 归并排序 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mergeSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> left, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> right) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 终止条件</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> right)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;                      </span><span style="color:#6A737D;">// 当子数组长度为 1 时终止递归</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 划分阶段</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> mid </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> right) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;    </span><span style="color:#6A737D;">// 计算中点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">mergeSort</span><span style="color:#24292E;">(nums, left, mid);      </span><span style="color:#6A737D;">// 递归左子数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">mergeSort</span><span style="color:#24292E;">(nums, mid </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, right); </span><span style="color:#6A737D;">// 递归右子数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 合并阶段</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">merge</span><span style="color:#24292E;">(nums, left, mid, right);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_5、快速排序" tabindex="-1">5、快速排序 <a class="header-anchor" href="#_5、快速排序" aria-label="Permalink to &quot;5、快速排序&quot;">​</a></h2><p>一次快速排序的操作过程：</p><ol><li>选择待排数列的首部第一个元素为基准元素<code>x</code>，设置两指针，分别指向数列首尾部位置，假设两指针分别设为<code>i</code>和<code>j</code>。</li><li>每次遍历的过程是这样的，首先从<code>右到左</code>遍历指针<code>j</code>所指向的元素，直到<code>j</code>指向的元素值<code>小于</code>基准元素<code>x</code>时，停止遍历，将其放到<code>i</code>的位置(因为<code>i</code>的值已经拷贝成了基准<code>x</code>腾出了位置)</li><li><code>i</code>往右挪一步, <code>i++</code>,接着轮到指针<code>i</code>从<code>左到右</code>遍历,直到<code>i</code>所指向的元素值大于基准元素<code>x</code>时，停止遍历，将其放到<code>j</code>的位置(因为上面一步<code>j</code>的值已经占用到了<code>i</code>的位置,腾出位置了)</li><li>依此类推，两边轮流遍历, 直到指针<code>i</code>与指针<code>j</code>相等或者大于(实际肯定是<code>i==j</code>)时，停止外部循环。此时必定左边都是比<code>x</code>小的, 右边是比<code>x</code>大的.</li><li>最后直接将基准元素<code>x</code>直接放置于指针<code>i</code>所指向的位置即可</li><li>完成分区操作, 从<code>i</code>的位置一分为二, 左边和右边再递归执行上面的操作. 层层细分</li></ol><p><img src="`+i+`" alt="image-20221206130639622"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">quickSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> right </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[left];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> j) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (nums[</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">i] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> x) ;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (nums[</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">j] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> x) ;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> j) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">            nums[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[j];</span></span>
<span class="line"><span style="color:#E1E4E8;">            nums[j] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">quickSort</span><span style="color:#E1E4E8;">(nums, left, j);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">quickSort</span><span style="color:#E1E4E8;">(nums, j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, right);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">quickSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> left, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> right) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> right) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> right </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[left];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> j) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (nums[</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">i] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> x) ;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (nums[</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">j] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> x) ;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> j) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[i];</span></span>
<span class="line"><span style="color:#24292E;">            nums[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[j];</span></span>
<span class="line"><span style="color:#24292E;">            nums[j] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">quickSort</span><span style="color:#24292E;">(nums, left, j);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">quickSort</span><span style="color:#24292E;">(nums, j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, right);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_6、堆排序" tabindex="-1">6、堆排序 <a class="header-anchor" href="#_6、堆排序" aria-label="Permalink to &quot;6、堆排序&quot;">​</a></h2><p>将数据以堆的结构, 或者说类似于二叉树的结构, 每次都整理二叉树将最大值找到, 然后放到数组末尾. 个人感觉有点像<code>选择排序</code>.都是每次遍历选择一个最大值或最小值 <strong>从下往上调整堆, 将最大值放到顶部</strong></p><p><img src="`+F+'" alt="image-20221206131020730"></p><ul><li>把一个数组, 从上往下, 从左到右依次放置成为二叉树</li><li>接着创建最大顶堆, 就是将最大的值调整到顶部.</li><li>然后开始遍历, 把这个[0]的最大值放到最末尾, 然后再次整理二叉树, 当然将最后一位排除在外.然后将截至末尾的下标往前移一位.</li><li>一直遍历, 把最大值放到顶部, 再调换到末尾, 到只剩最后一个元素, <strong>找到最大值后, 放到数组后面, 并设置一个标记, 表示截止后面的都是已排序的元素, 相当于堆删除一个元素</strong></li></ul><p><img src="'+A+`" alt="image-20221206131051430"></p><blockquote><p>因为是树结构, 所以整理一次树的时间复杂度是O(logn), 但是又因为它需要遍历一次挨个整理找到剩下数据中的最大值, 所以它的最坏，最好，平均时间复杂度均为O(nlogn)</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">maxHeapSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] array) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> len </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 构建大顶堆</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> len </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">adjustMaxHeap</span><span style="color:#E1E4E8;">(array, i, len);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 堆顶是最大值，交换堆顶和最后一个数，再重新调整最大堆，下一次循环   i--</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> len </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        array[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">        array[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> temp;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">adjustMaxHeap</span><span style="color:#E1E4E8;">(array, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, i);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">adjustMaxHeap</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] a, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> pos, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> len) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> temp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> child;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (temp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[pos]; </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> pos </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> len; pos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> child) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 数组从0开始，r(i)&gt;=r(2i) r(i)&gt;=r(2i+1)  对应 pos =&gt; 2 * pos + 1 和 2 * pos +2</span></span>
<span class="line"><span style="color:#E1E4E8;">        child </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> pos </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 有右孩子，且右孩子数值更大</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (child </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> len </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> a[child] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> a[child </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            child</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 最大的孩子大于根节点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (a[child] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> temp) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            a[pos] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[child];</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    a[pos] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> temp;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">maxHeapSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] array) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> len </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> array.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 构建大顶堆</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> len </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">adjustMaxHeap</span><span style="color:#24292E;">(array, i, len);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 堆顶是最大值，交换堆顶和最后一个数，再重新调整最大堆，下一次循环   i--</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> len </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> temp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> array[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">        array[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> array[i];</span></span>
<span class="line"><span style="color:#24292E;">        array[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> temp;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">adjustMaxHeap</span><span style="color:#24292E;">(array, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, i);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">adjustMaxHeap</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] a, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> pos, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> len) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> temp;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> child;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (temp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[pos]; </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> pos </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> len; pos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> child) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 数组从0开始，r(i)&gt;=r(2i) r(i)&gt;=r(2i+1)  对应 pos =&gt; 2 * pos + 1 和 2 * pos +2</span></span>
<span class="line"><span style="color:#24292E;">        child </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> pos </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 有右孩子，且右孩子数值更大</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (child </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> len </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> a[child] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> a[child </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) {</span></span>
<span class="line"><span style="color:#24292E;">            child</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 最大的孩子大于根节点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (a[child] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> temp) {</span></span>
<span class="line"><span style="color:#24292E;">            a[pos] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[child];</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    a[pos] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> temp;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_7、桶排序" tabindex="-1">7、桶排序 <a class="header-anchor" href="#_7、桶排序" aria-label="Permalink to &quot;7、桶排序&quot;">​</a></h2><p>「桶排序 bucket sort」是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</p><p>考虑一个长度为 n 的数组，元素是范围 [0,1) 的浮点数。桶排序的流程如图所示。</p><ol><li>初始化 n 个桶，将 n 个元素分配到 n 个桶中。</li><li>对每个桶分别执行排序（本文采用编程语言的内置排序函数）。</li><li>按照桶的从小到大的顺序，合并结果。</li></ol><p><img src="`+D+`" alt="image-20231019173848062"></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 桶排序 */</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">bucketSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">float</span><span style="color:#E1E4E8;">[] nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;List&lt;</span><span style="color:#F97583;">Float</span><span style="color:#E1E4E8;">&gt;&gt; buckets </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> k; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        buckets.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;());</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 将数组元素分配到各个桶中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">float</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) (num </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> k);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将 num 添加进桶 i</span></span>
<span class="line"><span style="color:#E1E4E8;">        buckets.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(i).</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(num);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 2. 对各个桶执行排序</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (List&lt;</span><span style="color:#F97583;">Float</span><span style="color:#E1E4E8;">&gt; bucket </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> buckets) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 使用内置排序函数，也可以替换成其他排序算法</span></span>
<span class="line"><span style="color:#E1E4E8;">        Collections.</span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(bucket);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 3. 遍历桶合并结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (List&lt;</span><span style="color:#F97583;">Float</span><span style="color:#E1E4E8;">&gt; bucket </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> buckets) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">float</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> bucket) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            nums[i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> num;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 桶排序 */</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">bucketSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">float</span><span style="color:#24292E;">[] nums) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;List&lt;</span><span style="color:#D73A49;">Float</span><span style="color:#24292E;">&gt;&gt; buckets </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> k; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        buckets.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;());</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 将数组元素分配到各个桶中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">float</span><span style="color:#24292E;"> num </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> nums) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) (num </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> k);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将 num 添加进桶 i</span></span>
<span class="line"><span style="color:#24292E;">        buckets.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(i).</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(num);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 2. 对各个桶执行排序</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (List&lt;</span><span style="color:#D73A49;">Float</span><span style="color:#24292E;">&gt; bucket </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> buckets) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 使用内置排序函数，也可以替换成其他排序算法</span></span>
<span class="line"><span style="color:#24292E;">        Collections.</span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(bucket);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 3. 遍历桶合并结果</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (List&lt;</span><span style="color:#D73A49;">Float</span><span style="color:#24292E;">&gt; bucket </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> buckets) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">float</span><span style="color:#24292E;"> num </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> bucket) {</span></span>
<span class="line"><span style="color:#24292E;">            nums[i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> num;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>桶排序适用于处理体量很大的数据。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。</p><ul><li><strong>时间复杂度 O(n+k)</strong></li><li><strong>自适应排序</strong>：在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用 O(n^2) 时间。</li><li><strong>空间复杂度 O(n+k)</strong> 、非原地排序**：需要借助 k 个桶和总共 n 个元素的额外空间。</li><li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li></ul><h2 id="_8、计数排序" tabindex="-1">8、计数排序 <a class="header-anchor" href="#_8、计数排序" aria-label="Permalink to &quot;8、计数排序&quot;">​</a></h2><p>「计数排序 counting sort」通过统计元素数量来实现排序，通常应用于整数数组。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* 计数排序 */</span></span>
<span class="line"><span style="color:#6A737D;">// 完整实现，可排序对象，并且是稳定排序</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">countingSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 1. 统计数组最大元素 m</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> m </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        m </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(m, num);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 2. 统计各数字的出现次数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// counter[num] 代表 num 的出现次数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] counter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[m </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        counter[num]</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> m; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        counter[i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> counter[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化数组 res 用于记录结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[n];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">        res[counter[num] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> num; </span><span style="color:#6A737D;">// 将 num 放置到对应索引处</span></span>
<span class="line"><span style="color:#E1E4E8;">        counter[num]</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 令前缀和自减 1 ，得到下次放置 num 的索引</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 使用结果数组 res 覆盖原数组 nums</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        nums[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> res[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* 计数排序 */</span></span>
<span class="line"><span style="color:#6A737D;">// 完整实现，可排序对象，并且是稳定排序</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">countingSort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 1. 统计数组最大元素 m</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> m </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> num </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> nums) {</span></span>
<span class="line"><span style="color:#24292E;">        m </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(m, num);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 2. 统计各数字的出现次数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// counter[num] 代表 num 的出现次数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] counter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[m </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> num </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> nums) {</span></span>
<span class="line"><span style="color:#24292E;">        counter[num]</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> m; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        counter[i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> counter[i];</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化数组 res 用于记录结果</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[n];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> num </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[i];</span></span>
<span class="line"><span style="color:#24292E;">        res[counter[num] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> num; </span><span style="color:#6A737D;">// 将 num 放置到对应索引处</span></span>
<span class="line"><span style="color:#24292E;">        counter[num]</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 令前缀和自减 1 ，得到下次放置 num 的索引</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 使用结果数组 res 覆盖原数组 nums</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> n; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        nums[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> res[i];</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="时间复杂度对比" tabindex="-1">时间复杂度对比 <a class="header-anchor" href="#时间复杂度对比" aria-label="Permalink to &quot;时间复杂度对比&quot;">​</a></h2><table><thead><tr><th></th><th>平均</th><th>最好</th><th>最差</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡</td><td>n2</td><td>n</td><td>n2</td><td>稳定</td></tr><tr><td>插入</td><td>n2</td><td>n</td><td>n2</td><td>稳定</td></tr><tr><td>快排</td><td>nlog2N</td><td>nlog2N</td><td>n2</td><td>不稳定</td></tr><tr><td>堆排</td><td>nlog2N</td><td>nlog2N</td><td>nlog2N</td><td>不稳定</td></tr><tr><td>选择</td><td>n2</td><td>n2</td><td>n2</td><td>不稳定</td></tr></tbody></table><blockquote><p><strong>堆排&gt;快速排序&gt;&gt;归并排序&gt;&gt;&gt;&gt;&gt;插入排序&gt;&gt;选择排序&gt;&gt;冒泡排序</strong></p></blockquote>`,64),u=[m];function g(h,f,C,b,j,k){return n(),a("div",null,u)}const _=s(d,[["render",g]]);export{B as __pageData,_ as default};
