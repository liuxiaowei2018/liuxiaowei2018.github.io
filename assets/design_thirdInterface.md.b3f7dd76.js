import{_ as l,o as i,c as t,Q as o,k as e,a}from"./chunks/framework.8048b864.js";const p="/assets/image-20231024141843818.875cdbaf.png",I=JSON.parse('{"title":"架构设计","description":"","frontmatter":{},"headers":[],"relativePath":"design/thirdInterface.md","filePath":"design/thirdInterface.md","lastUpdated":1698401529000}'),c={name:"design/thirdInterface.md"},r=o('<h1 id="架构设计" tabindex="-1">架构设计 <a class="header-anchor" href="#架构设计" aria-label="Permalink to &quot;架构设计&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#三方接口调用设计方案">三方接口调用设计方案</a><ul><li><a href="#设计方案概述">设计方案概述</a></li></ul></li></ul></nav><h2 id="三方接口调用设计方案" tabindex="-1">三方接口调用设计方案 <a class="header-anchor" href="#三方接口调用设计方案" aria-label="Permalink to &quot;三方接口调用设计方案&quot;">​</a></h2><p>在为第三方系统提供接口的时候，肯定要考虑接口数据的安全问题，比如<strong>数据是否被篡改</strong>，<strong>数据是否已经过时</strong>，<strong>数据是否可以重复提交</strong>等问题</p><p>在设计三方接口调用的方案时，需要考虑到安全性和可用性。以下是一种设计方案的概述，其中包括使用API密钥（Access Key/Secret Key）进行身份验证和设置回调地址。</p><h3 id="设计方案概述" tabindex="-1">设计方案概述 <a class="header-anchor" href="#设计方案概述" aria-label="Permalink to &quot;设计方案概述&quot;">​</a></h3><p><strong>API密钥生成</strong>：为每个三方应用生成唯一的API密钥对（AK/SK），其中AK用于标识应用，SK用于进行签名和加密。</p><blockquote><p>AK：Access Key Id,用于标示用户。 SK：Secret Access Key,是用户用于加密认证字符串和用来验证认证字符串的密钥，其中SK必须保密。 通过使用Access Key Id / Secret Access Key加密的方法来验证某个请求的发送者身份。</p></blockquote><p><strong>接口鉴权</strong>：在进行接口调用时，客户端需要使用AK和请求参数生成签名，并将其放入请求头或参数中以进行身份验证。</p><blockquote><p>淘宝签名和验签： <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.yuque.com%2Fu12226311%2Fttgrez%2Fmxy16ld5h2tw7xhx" target="_blank" rel="noreferrer">淘宝SDK签名算法 (yuque.com)</a></p></blockquote><p><strong>回调地址设置</strong>：三方应用提供回调地址，用于接收异步通知和回调结果。</p><p><strong>接口API设计</strong>：设计接口的URL、HTTP方法、请求参数、响应格式等细节。</p><h4 id="权限划分" tabindex="-1">权限划分 <a class="header-anchor" href="#权限划分" aria-label="Permalink to &quot;权限划分&quot;">​</a></h4><ul><li><p>appID：</p><p>应用的唯一标识</p><blockquote><p>用来标识你的开发者账号的, 即:<code>用户id</code>, 可以在数据库添加索引，方便快速查找，同一个 appId 可以对应多个 appKey+appSecret</p></blockquote></li><li><p>appKey：</p><p>公匙（相当于账号）</p><blockquote><p>公开的，调用服务所需要的密钥。是用户的身份认证标识，用于调用平台可用服务.，可以简单理解成是账号。</p></blockquote></li><li><p>appSecret：</p><p>私匙（相当于密码）</p><blockquote><p>签名的密钥，是跟appKey配套使用的，可以简单理解成是密码。</p></blockquote></li><li><p>token：令牌（过期失效）</p></li></ul><p><strong>使用方法</strong></p><ol><li>向第三方服务器请求授权时，带上<code>AppKey和AppSecret</code>（需存在服务器端）</li><li>第三方服务器验证<code>appKey和appSecret</code>在数据库、缓存中有没有记录</li><li>如果有，生成一串唯一的字符串<code>（token令牌）</code>，返回给服务器，服务器再返回给客户端</li><li>后续客户端每次请求都需要带上token令牌</li></ol><p><strong>为什么 要有appKey + appSecret 这种成对出现的机制呢,?</strong></p><ul><li>因为<code>要加密</code>, <code>通常用在首次验证(类似登录场景)</code>, 用 <code>appKey(标记要申请的权限有哪些)</code> + <code>appSecret(密码, 表示你真的拥有这个权限)</code>来申请一个token, 就是我们经常用到的 <code>accessToken（通常拥有失效时间）</code>, 后续的每次请求都需要提供accessToken 表明验证权限通过。</li></ul><blockquote><p>现在有了统一的appId，此时如果针对同一个业务要划分不同的权限，比如同一功能，某些场景需要只读权限，某些场景需要读写权限。这样提供一个appId和对应的秘钥appSecret就没办法满足需求。 此时就需要<code>根据权限进行账号分配</code>，<code>通常使用appKey和appSecret。</code></p></blockquote><ul><li>由于 <strong><code>appKey 和 appSecret 是成对出现的账号</code>, <code>同一个 appId 可以对应多个 appKey+appSecret,</code> 这样平台就为<code>不同的appKey+appSecret对</code>分配不一样的权限,</strong><ul><li>可以生成两对appKey和appSecret。一个用于删除，一个用于读写，达到权限的细粒度划分。如 : appKey1 + appSecect1 只有删除权限 但是 appKey2+appSecret2 有读写权限… 这样你就可以把对应的权限 放给不同的开发者。其中<code>权限的配置都是直接跟appKey 做关联的</code>, appKey 也需要添加数据库索引, 方便快速查找</li></ul></li></ul><hr><p><strong>简化的场景</strong>:</p><ul><li>第一种场景：通常用于开放性接口，像地图api，<code>会省去app_id和app_key</code>，此时相当于三者相等，合而为一 <code>appId = appKey = appSecret,</code> 。这种模式下，带上app_id的目的仅仅是统计某一个用户调用接口的次数而已了。</li><li>第二种场景: 当每一个用户有且仅有一套权限配置 可以<code>去掉 appKey,</code> , 直接将<code>app_id = app_key</code>, 每个用户分配一个<code>appId+ appSecret</code>就够了。</li></ul><blockquote><p>还可以采用签名(signature)的方式： 当调用方向服务提供方法发起请求时，带上（<code>appKey、时间戳timeStamp、随机数nonce、签名sign</code>） 签名sign 可以使用 <code>(AppSecret + 时间戳 + 随机数)</code>使用<code>sha1、md5</code>生成，服务提供方收到后，生成本地签名和收到的签名比对，如果一致，校验成功</p></blockquote><h4 id="签名流程" tabindex="-1">签名流程 <a class="header-anchor" href="#签名流程" aria-label="Permalink to &quot;签名流程&quot;">​</a></h4><p><img src="'+p+'" alt="image-20231024141843818"></p><h4 id="签名规则" tabindex="-1">签名规则 <a class="header-anchor" href="#签名规则" aria-label="Permalink to &quot;签名规则&quot;">​</a></h4><ol><li><p><strong>分配</strong><code>appId(开发者标识)</code>和<code>appSecret(密钥)</code>，给 <code>不同的调用方</code></p><blockquote><p>可以直接通过平台线上申请，也可以线下直接颁发。appId是全局唯一的，每个appId将对应一个客户，密钥appSecret需要高度保密。</p></blockquote></li><li><p>加入<code>timeStamp</code>（时间戳），以服务端当前时间为准，单位为ms ，5分钟内数据有效</p><blockquote><p>时间戳的目的就是为了减轻DOS攻击。防止请求被拦截后一直尝试请求接口。服务器端设置时间戳阀值，如果<code>服务器时间 减 请求时间戳</code>超过阀值，表示签名超时，接口调用失败。</p></blockquote></li><li><p>加入<strong>临时流水号</strong><code>nonce</code>，<em>至少为10位</em> ，<code>有效期内防重复提交</code>。</p><blockquote><p>随机值nonce 主要是为了<code>增加签名sign的多变性</code>，也可以<code>保护接口的幂等性</code>，相邻的两次请求nonce不允许重复，如果重复则认为是重复提交，接口调用失败。</p><ul><li>针对<strong>查询接口</strong>，流水号只用于日志落地，便于后期日志核查。</li><li>针对<strong>办理类接口</strong>需校验流水号在有效期内的唯一性，以避免重复请求。</li></ul></blockquote><p>通过在接口签名请求参数加上 时间戳timeStamp + 随机数nonce 可以防止 ”重放攻击“ 1.时间戳（timeStamp）: 以服务端当前时间为准，服务端要求客户端发过来的时间戳，必须是最近60秒内（假设值，自己定义）的。 这样，即使这个请求即使被截取了，也只能在60s内进行重放攻击。 2.随机数（nonce）: 但是，即使设置了时间戳，攻击者还有60s的攻击时间呢！ 所以我们需要在客户端请求中再加上一个随机数（中间黑客不可能自己修改随机数，因为有参数签名的校验呢）， 服务端会对一分钟内请求的随机数进行检查，如果有两个相同的，基本可以判定为重放攻击。 因为正常情况下，在短时间内（比如60s）连续生成两个相同nonce的情况几乎为0</p><p>服务端“第一次”在接收到这个nonce的时候做下面行为： 1.去redis中查找是否有key为nonce:{ nonce}的数据 2.如果没有，则创建这个key，把这个key失效的时间和验证timestamp失效的时间一致，比如是60s。 3.如果有，说明这个key在60s内已经被使用了，那么这个请求就可以判断为重放请求。</p></li><li><p>加入签名字段<code>sign</code>，获取调用方传递的签名信息。</p><p>通过在接口签名请求参数加上 时间戳appId + sign 解决身份验证和防止 ”参数篡改“ 1.请求携带参数appId和Sign，只有拥有合法的身份appId和正确的签名Sign才能放行。这样就解决了身份验证和参数篡改问题。 2.即使请求参数被劫持，由于获取不到appSecret（仅作本地加密使用，不参与网络传输），也无法伪造合法的请求。</p></li></ol><p><strong><code>以上字段放在请求头中。</code></strong></p><h4 id="api接口设计" tabindex="-1">API接口设计 <a class="header-anchor" href="#api接口设计" aria-label="Permalink to &quot;API接口设计&quot;">​</a></h4><p>根据你的具体需求和业务场景，以下是一个简单示例的API接口设计：</p><h5 id="_1-获取资源列表接口" tabindex="-1">1. 获取资源列表接口 <a class="header-anchor" href="#_1-获取资源列表接口" aria-label="Permalink to &quot;1. 获取资源列表接口&quot;">​</a></h5><ul><li>URL: /api/resources</li><li>HTTP 方法: GET</li><li>请求参数: <ul><li>page (可选): 页码</li><li>limit (可选): 每页限制数量</li></ul></li><li>响应: <ul><li>成功状态码: 200 OK</li><li>响应体: 返回资源列表的JSON数组</li></ul></li></ul><h5 id="_2-创建资源接口" tabindex="-1">2. 创建资源接口 <a class="header-anchor" href="#_2-创建资源接口" aria-label="Permalink to &quot;2. 创建资源接口&quot;">​</a></h5><ul><li>URL: /api/resources</li><li>HTTP 方法: POST</li><li>请求参数: <ul><li>name (必填): 资源名称</li><li>description (可选): 资源描述</li></ul></li><li>响应: <ul><li>成功状态码: 201 Created</li><li>响应体: 返回新创建资源的ID等信息</li></ul></li></ul><h5 id="_3-更新资源接口" tabindex="-1">3. 更新资源接口 <a class="header-anchor" href="#_3-更新资源接口" aria-label="Permalink to &quot;3. 更新资源接口&quot;">​</a></h5>',36),d=e("ul",null,[e("li",{resourceId:""},"URL: /api/resources/"),e("li",null,"HTTP 方法: PUT"),e("li",null,[a("请求参数: "),e("ul",null,[e("li",null,"resourceId (路径参数, 必填): 资源ID"),e("li",null,"name (可选): 更新后的资源名称"),e("li",null,"description (可选): 更新后的资源描述")])]),e("li",null,[a("响应: "),e("ul",null,[e("li",null,"成功状态码: 200 OK")])])],-1),n=e("h5",{id:"_4-删除资源接口",tabindex:"-1"},[a("4. 删除资源接口 "),e("a",{class:"header-anchor",href:"#_4-删除资源接口","aria-label":'Permalink to "4. 删除资源接口"'},"​")],-1),s=e("ul",null,[e("li",{resourceId:""},"URL: /api/resources/"),e("li",null,"HTTP 方法: DELETE"),e("li",null,[a("请求参数: "),e("ul",null,[e("li",null,"resourceId (路径参数, 必填): 资源ID")])]),e("li",null,[a("响应: "),e("ul",null,[e("li",null,"成功状态码: 204 No Content")])])],-1),u=o('<h4 id="api接口设计补充" tabindex="-1">API接口设计补充 <a class="header-anchor" href="#api接口设计补充" aria-label="Permalink to &quot;API接口设计补充&quot;">​</a></h4><h5 id="_1-使用post作为接口请求方式" tabindex="-1">1.使用POST作为接口请求方式 <a class="header-anchor" href="#_1-使用post作为接口请求方式" aria-label="Permalink to &quot;1.使用POST作为接口请求方式&quot;">​</a></h5><p>一般调用接口最常用的两种方式就是GET和POST。两者的区别也很明显，GET请求会将参数暴露在浏览器URL中，而且对长度也有限制。<strong>为了更高的安全性，所有接口都采用POST方式请求。</strong></p><h5 id="_2-客户端ip白名单" tabindex="-1">2.客户端IP白名单 <a class="header-anchor" href="#_2-客户端ip白名单" aria-label="Permalink to &quot;2.客户端IP白名单&quot;">​</a></h5><p><strong>ip白名单是指<code>将接口的访问权限对部分ip进行开放</code>来避免其他ip进行访问攻击</strong>。</p><ul><li>设置ip白名单缺点就是当你的客户端进行迁移后，就需要重新联系服务提供者添加新的ip白名单。</li><li>设置ip白名单的方式很多，除了传统的防火墙之外，spring cloud alibaba提供的组件sentinel也支持白名单设置。</li><li>为了降低api的复杂度，推荐使用防火墙规则进行白名单设置。</li></ul><h5 id="_3-单个接口针对ip限流" tabindex="-1">3. 单个接口针对ip限流 <a class="header-anchor" href="#_3-单个接口针对ip限流" aria-label="Permalink to &quot;3. 单个接口针对ip限流&quot;">​</a></h5><p><strong>限流是为了更好的维护系统稳定性。</strong></p><ul><li>使用<code>redis</code>进行<code>接口调用次数统计</code>，<code>ip+接口地址作为key，访问次数作为value</code>，<code>每次请求value+1</code>，<code>设置过期时长来限制接口的调用频率。</code></li></ul><h5 id="_4-记录接口请求日志" tabindex="-1">4. 记录接口请求日志 <a class="header-anchor" href="#_4-记录接口请求日志" aria-label="Permalink to &quot;4. 记录接口请求日志&quot;">​</a></h5><p>记录请求日志，快速定位异常请求位置，排查问题原因。(如：用aop来全局处理接口请求)</p><h5 id="_5-敏感数据脱敏" tabindex="-1">5. 敏感数据脱敏 <a class="header-anchor" href="#_5-敏感数据脱敏" aria-label="Permalink to &quot;5. 敏感数据脱敏&quot;">​</a></h5><p>在接口调用过程中，可能会涉及到<code>订单号</code>等敏感数据，这类数据通常需要<code>脱敏处理</code></p><ul><li>最常用的方式就是加密。加密方式使用安全性比较高的<code>RSA非对称加密。</code> 非对称加密算法有<code>两个密钥</code>，这两个密钥<code>完全不同但又完全匹配</code>。<strong>只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。</strong></li></ul><h5 id="_6-幂等性问题" tabindex="-1">6.幂等性问题 <a class="header-anchor" href="#_6-幂等性问题" aria-label="Permalink to &quot;6.幂等性问题&quot;">​</a></h5><p>幂等性是指: <code>任意多次请求的执行结果和一次请求的执行结果所产生的影响相同</code>。</p><ul><li>说的直白一点就是查询操作无论查询多少次都不会影响数据本身，因此查询操作本身就是幂等的。</li><li>但是新增操作，每执行一次数据库就会发生变化，所以它是非幂等的。</li></ul><p>幂等问题的解决有很多思路，这里讲一种比较严谨的。</p><ul><li><code>提供一个生成随机数的接口</code>，随机数全局唯一。调用接口的时候带入随机数。</li><li>第一次调用，业务处理成功后，将随机数作为key，操作结果作为value，存入redis，同时设置过期时长。</li><li>第二次调用，查询redis，如果key存在，则证明是重复提交，直接返回错误。</li></ul><h5 id="_7-版本控制" tabindex="-1">7.版本控制 <a class="header-anchor" href="#_7-版本控制" aria-label="Permalink to &quot;7.版本控制&quot;">​</a></h5><p>一套成熟的API文档，一旦发布是不允许随意修改接口的。这时候如果想新增或者修改接口，就需要加入<code>版本控制</code>，版本号可以是整数类型，也可以是浮点数类型。</p><ul><li><strong>一般接口地址都会带上版本号，<code>http://ip:port//v1/list</code> , <code>http://ip:port//v2/list</code></strong></li></ul><h5 id="_8-响应状态码规范" tabindex="-1">8.响应状态码规范 <a class="header-anchor" href="#_8-响应状态码规范" aria-label="Permalink to &quot;8.响应状态码规范&quot;">​</a></h5><p>一个牛逼的API，还需要提供简单明了的响应值，根据状态码就可以大概知道问题所在。我们采用http的状态码进行数据封装，例如200表示请求成功，4xx表示客户端错误，5xx表示服务器内部发生错误。</p><h5 id="_9-统一响应数据格式" tabindex="-1">9.统一响应数据格式 <a class="header-anchor" href="#_9-统一响应数据格式" aria-label="Permalink to &quot;9.统一响应数据格式&quot;">​</a></h5><p>为了方便给客户端响应，响应数据会包含三个属性，<code>状态码（code）,信息描述（message）,响应数据（data）</code>。客户端根据状态码及信息描述可快速知道接口，如果状态码返回成功，再开始处理数据。</p><h5 id="_10-接口文档" tabindex="-1">10.接口文档 <a class="header-anchor" href="#_10-接口文档" aria-label="Permalink to &quot;10.接口文档&quot;">​</a></h5><p>一个好的API还少不了一个优秀的接口文档。接口文档的可读性非常重要，虽然很多程序员都不喜欢写文档，而且不喜欢别人不写文档。为了不增加程序员的压力，<strong>推荐使用swagger2或其他接口管理工具</strong>，通过简单配置，就可以在开发中测试接口的连通性，上线后也可以生成离线文档用于管理API。</p><h4 id="安全性考虑" tabindex="-1">安全性考虑 <a class="header-anchor" href="#安全性考虑" aria-label="Permalink to &quot;安全性考虑&quot;">​</a></h4><p>为了确保安全性，可以采取以下措施：</p><ul><li>使用HTTPS协议进行数据传输，以保护通信过程中的数据安全。</li><li>在请求中使用AK和签名进行身份验证，并对请求进行验签，在服务端进行校验和鉴权，以防止非法请求和重放攻击。</li><li>对敏感数据进行加密传输，例如使用TLS加密算法对敏感数据进行加密。</li></ul><p>以上是一个简单的设计方案和API接口设计示例。具体的实现细节可能因项目需求而有所不同。在实际开发中，还要考虑错误处理、异常情况处理、日志记录等方面。</p><p>防止重放攻击和对敏感数据进行加密传输都是保护三方接口安全的重要措施。以下是一些示例代码，展示了如何实现这些功能。</p><h5 id="防止重放攻击" tabindex="-1">防止重放攻击 <a class="header-anchor" href="#防止重放攻击" aria-label="Permalink to &quot;防止重放攻击&quot;">​</a></h5><p>抓取报文原封不动重复发送如果是<code>付款接口，或者购买接口</code>就会造成损失，因此需要采用防重放的机制来做请求验证，如请求参数上加上<code>timestamp时间戳+nonce随机数</code>。</p><p>重放攻击是指黑客通过抓包的方式，得到客户端的请求数据及请求连接，重复的向服务器发送请求的行为。</p><blockquote><p>时间戳(tamp) + 数字签名(sign)， 也就是说每次发送请求时多传两个参数，分别为 tamp 和 sign。</p></blockquote><p>数字签名的作用是为了确保请求的有效性。因为签名是经过加密的，只有客户端和服务器知道加密方式及密钥（key），所以第三方模拟不了。我们通过对sign的验证来判断请求的有效性，如果sign验证失败则判定为无效的请求，反之有效。 但是数字签名并不能阻止重放攻击，因为黑客可以抓取你的tamp和sign（不需做任何修改），然后发送请求。这个时候就要对时间戳进行验证。</p><p>时间戳的作用是为了确保请求的时效性。我们将上一次请求的时间戳进行存储，在下一次请求时，将两次时间戳进行比对。如果此次请求的时间戳和上次的相同或小于上一次的时间戳，则判定此请求为过时请求，无效。因为正常情况下，第二次请求的时间肯定是比上一次的时间大的，不可能相等或小于。</p><p>如果修改了时间戳来满足时间的时效性，sign验签就不通过了。</p><p><em>注：如果客户端是js，一定要对js做代码混淆，禁止右键等。</em></p><h5 id="对敏感数据进行加密传输" tabindex="-1">对敏感数据进行加密传输 <a class="header-anchor" href="#对敏感数据进行加密传输" aria-label="Permalink to &quot;对敏感数据进行加密传输&quot;">​</a></h5><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.51cto.com%2Fu_16175496%2F6920098" target="_blank" rel="noreferrer">blog.51cto.com/u_16175496/…</a> 使用TLS（传输层安全）协议可以保证通信过程中的数据加密和完整性。以下是一些基本步骤：</p><ol><li>在服务器上配置TLS证书（包括公钥和私钥）。</li><li>客户端和服务器之间建立TLS连接。客户端向服务器发送HTTPS请求。</li><li>在TLS握手期间，客户端和服务器协商加密算法和密钥交换方法。</li><li>握手成功后，客户端和服务器之间的所有数据传输都会经过加密处理。</li></ol>',44),h=[r,d,n,s,u];function _(b,g,q,k,m,P){return i(),t("div",null,h)}const f=l(c,[["render",_]]);export{I as __pageData,f as default};
