import{_ as s,o as a,c as l,Q as e}from"./chunks/framework.8048b864.js";const k=JSON.parse('{"title":"MySQL-锁","description":"","frontmatter":{},"headers":[],"relativePath":"mysql/mysql锁.md","filePath":"mysql/mysql锁.md","lastUpdated":1719110524000}'),n={name:"mysql/mysql锁.md"},p=e(`<h1 id="mysql-锁" tabindex="-1">MySQL-锁 <a class="header-anchor" href="#mysql-锁" aria-label="Permalink to &quot;MySQL-锁&quot;">​</a></h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库种，除传统的计算机资源（CPU，RAM，I/O）的争用以外，数据也是一种提供多用户共享的资源。如何保证数据并发访问的一致性，有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更复杂。</p><p>按照锁的粒度来分，sql中的锁分为以下三类</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：每次操作锁住对于的行数据。</li></ul><h4 id="全局锁" tabindex="-1">全局锁 <a class="header-anchor" href="#全局锁" aria-label="Permalink to &quot;全局锁&quot;">​</a></h4><p>对整个数据库实例枷锁，枷锁后整个实例就处于制度状态，后续的DML的写语句，DDL语句，以及更新操作的事务提交语句都将被阻塞。通常用于备份数据<code>sqldump</code>。</p><h4 id="表级锁" tabindex="-1">表级锁 <a class="header-anchor" href="#表级锁" aria-label="Permalink to &quot;表级锁&quot;">​</a></h4><p>表级锁，每次操作锁住整张表。锁粒度打，发视锁冲突的概率高，并发度最低，应用在MyISAM，InnoDB等存储引擎中。</p><p>对于表级锁，主要分三类</p><ol><li>表锁</li><li>元数据锁</li><li>意向锁</li></ol><h5 id="表锁" tabindex="-1">表锁 <a class="header-anchor" href="#表锁" aria-label="Permalink to &quot;表锁&quot;">​</a></h5><p>表锁分为2类</p><ol><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ol><p>加锁：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">lock tables </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">read/</span><span style="color:#E1E4E8;">write</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">lock tables </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">read/</span><span style="color:#24292E;">write</span></span></code></pre></div><p>释放锁：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">unlock</span><span style="color:#E1E4E8;"> tables</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">unlock</span><span style="color:#24292E;"> tables</span></span></code></pre></div><h6 id="读锁" tabindex="-1">读锁 <a class="header-anchor" href="#读锁" aria-label="Permalink to &quot;读锁&quot;">​</a></h6><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301626007.png" alt="在这里插入图片描述"></p><p>客户端1在表上加锁，客户端1和其他客户端都只能够查询，不能够写。当客户端1去写入数据会直接提示 <code>Table &#39;xxx&#39; was locked with a READ lock and can&#39;t be updated</code>，当其他客户端写入数据时，会直接阻塞，直到客户端1解锁。</p><h6 id="写锁" tabindex="-1">写锁 <a class="header-anchor" href="#写锁" aria-label="Permalink to &quot;写锁&quot;">​</a></h6><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301626831.png" alt="在这里插入图片描述"></p><p>客户端1在表上加锁，只有客户端1能够读写。当其他客户端读写数据时，都会直接阻塞，直到客户端1解锁。</p><h5 id="元数据锁" tabindex="-1">元数据锁 <a class="header-anchor" href="#元数据锁" aria-label="Permalink to &quot;元数据锁&quot;">​</a></h5><p>元数据锁（meta data lock ), MDL 加锁过程是系统自动控制，无需显示使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML和DDL冲突，保证读写的正确性</strong>。</p><p>在sql 5.5 中引用了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当表结构进行变更操作的时候，加上MDL写锁（排他）。</p><table><thead><tr><th style="text-align:center;">对应SQL</th><th style="text-align:center;">锁类型</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">lock tables xxx read/write</td><td style="text-align:center;">SHARED_READ_ONLY/SHARED_NO_READ_WRITE</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">select ,select... lock in share mode</td><td style="text-align:center;">SHARED_READ</td><td style="text-align:center;">与SHARED_READ，SHARED_WRITE兼容。与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center;">insert ,update, delete, select... for update</td><td style="text-align:center;">SHARED_WRITE</td><td style="text-align:center;">与SHARED_READ，SHARED_WRITE兼容。与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center;">alter table...</td><td style="text-align:center;">EXCLUSIVE</td><td style="text-align:center;">与其他的MDL都互斥</td></tr></tbody></table><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> object_type,object_schema,object_name,lock_type,lock_duration </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">performace_schema</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">metadata_locks</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> object_type,object_schema,object_name,lock_type,lock_duration </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">performace_schema</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">metadata_locks</span><span style="color:#24292E;">;</span></span></code></pre></div><p>当开启一个事务的时候不会产生元数据锁，只有增删查改，修改表结构的时候才会看到自动加锁。</p><h5 id="意向锁" tabindex="-1">意向锁 <a class="header-anchor" href="#意向锁" aria-label="Permalink to &quot;意向锁&quot;">​</a></h5><p>为了避免DML 在执行时，加的行锁与表锁的冲突，在InnoDB 中应如何了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><p>不用逐行检查行锁，而是检查意向锁的情况，如果意向锁和当前加的锁是兼容的，如果兼容直接加锁，如果不兼容就会处于阻塞状态，知道A线程提交事务，解锁意向锁。</p><table><thead><tr><th style="text-align:center;">意向共享锁（IS）</th><th style="text-align:center;">意向拍打锁（IX）</th></tr></thead><tbody><tr><td style="text-align:center;">由语句select ... lock in share mode添加。</td><td style="text-align:center;">由 insert，update，delete，select ... for update添加。</td></tr><tr><td style="text-align:center;">与表锁共享锁read 兼容，与表锁排他write锁互斥</td><td style="text-align:center;">与表锁共享锁read ，表锁排他write锁互斥。意向锁之间不会互斥</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><p>通过以下SQL 查看意向所以及行锁的加锁情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> object_schema,object_name,index_name,lock_type,lock_mode,lock_data </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">performance_schema</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">data_locks</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> object_schema,object_name,index_name,lock_type,lock_mode,lock_data </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">performance_schema</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">data_locks</span><span style="color:#24292E;">;</span></span></code></pre></div><p>意向锁主要解决的问题是在InnoDB 引擎在加表锁和行锁的冲突问题。</p><h4 id="行级锁" tabindex="-1">行级锁 <a class="header-anchor" href="#行级锁" aria-label="Permalink to &quot;行级锁&quot;">​</a></h4><p>行级锁，每次操作锁住对应的行数据。锁的力度小，发生锁冲突的概率低，并发度最高，应用在InnoDB 存储引擎中。</p><p>InnoDB 的数据是基于索引组织的。行锁是通过对表锁上的索引项加锁实现的，而不是对记录加的锁。对于行级锁，主要分一下三类：</p><ul><li><p>行锁（Record Lock）：锁定单个记录的锁，防止其他事务对此进行update 和 delete。在RC、RR 隔离级别下都支持。</p></li><li><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引间隙不变，防止其他事务在这个间隙进行insert ，产生幻读。在RR 隔离级别下都支持。</p></li><li><p>临间锁（Next-key Lock）：行锁和间隙锁的组合，同时锁住数据，并锁住数据前面的间隙Gap 。在RR 隔离级别下支持。</p><p><img src="https://cdn.jsdelivr.net/gh/liuxiaowei2018/image/repo/202405301627191.png" alt="在这里插入图片描述"></p></li></ul><h5 id="行锁" tabindex="-1">行锁 <a class="header-anchor" href="#行锁" aria-label="Permalink to &quot;行锁&quot;">​</a></h5><p>InnoDB 实现了一下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务读取一行，阻止其他事物获得相同数据集的排他锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事物相同数据集的共享锁和排他锁。</li></ul><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">S 共享锁</th><th style="text-align:center;">X 排他锁</th></tr></thead><tbody><tr><td style="text-align:center;">S 共享锁</td><td style="text-align:center;">兼容</td><td style="text-align:center;">冲突</td></tr><tr><td style="text-align:center;">X 排他锁</td><td style="text-align:center;">冲突</td><td style="text-align:center;">冲突</td></tr></tbody></table><table><thead><tr><th style="text-align:center;">SQL</th><th style="text-align:center;">行锁类型</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">INSERT...</td><td style="text-align:center;">排他</td><td style="text-align:center;">自动加锁</td></tr><tr><td style="text-align:center;">UPDATE...</td><td style="text-align:center;">排他</td><td style="text-align:center;">自动加锁</td></tr><tr><td style="text-align:center;">DELETE...</td><td style="text-align:center;">排他</td><td style="text-align:center;">自动加锁</td></tr><tr><td style="text-align:center;">SELECT</td><td style="text-align:center;">不加锁</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">SELECT LOCK IN SHARE MODE</td><td style="text-align:center;">共享</td><td style="text-align:center;">需要手动加LOCK IN SHARE MODE</td></tr><tr><td style="text-align:center;">SELECT FOR UPDATE</td><td style="text-align:center;">排他</td><td style="text-align:center;">需要手动加 FOR UPDATE</td></tr></tbody></table><p>默认情况下，InnoDB 在RR 事物隔离级运行 InnoDB 使用 Next-key Lock 锁进行搜索和索引扫描防止幻读。</p><ol><li>针对唯一所有检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB 的行锁是针对于索引加的锁，不通过索引检索数据，那么InnoDB 将对表中所有的记录加锁，此时就会升级为表锁。</li></ol><h5 id="间隙锁-临键锁" tabindex="-1">间隙锁/临键锁 <a class="header-anchor" href="#间隙锁-临键锁" aria-label="Permalink to &quot;间隙锁/临键锁&quot;">​</a></h5><ul><li>索引上的等值查询（唯一索引）,给不存在的记录加锁，优化为间隙锁。</li><li>索引上的等值查询（普通查询），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询（唯一索引）会访问到不满足条件的第一个值位置。</li></ul><p><strong>注意：间隙锁唯一的目的是防止其他事物插入间隙，间隙锁可以共存，一个事务采用的间隙所不会阻塞另一个间隙上采用的间隙锁。</strong></p><h4 id="锁算法" tabindex="-1">锁算法 <a class="header-anchor" href="#锁算法" aria-label="Permalink to &quot;锁算法&quot;">​</a></h4><h5 id="record-lock" tabindex="-1">Record Lock <a class="header-anchor" href="#record-lock" aria-label="Permalink to &quot;Record Lock&quot;">​</a></h5><blockquote><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p></blockquote><h5 id="gap-lock" tabindex="-1">Gap Lock <a class="header-anchor" href="#gap-lock" aria-label="Permalink to &quot;Gap Lock&quot;">​</a></h5><blockquote><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</span></span></code></pre></div></blockquote><h5 id="next-key-lock" tabindex="-1">Next-Key Lock <a class="header-anchor" href="#next-key-lock" aria-label="Permalink to &quot;Next-Key Lock&quot;">​</a></h5><blockquote><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">(-∞, 10]</span></span>
<span class="line"><span style="color:#e1e4e8;">(10, 11]</span></span>
<span class="line"><span style="color:#e1e4e8;">(11, 13]</span></span>
<span class="line"><span style="color:#e1e4e8;">(13, 20]</span></span>
<span class="line"><span style="color:#e1e4e8;">(20, +∞)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">(-∞, 10]</span></span>
<span class="line"><span style="color:#24292e;">(10, 11]</span></span>
<span class="line"><span style="color:#24292e;">(11, 13]</span></span>
<span class="line"><span style="color:#24292e;">(13, 20]</span></span>
<span class="line"><span style="color:#24292e;">(20, +∞)</span></span></code></pre></div></blockquote><blockquote><p>在 InnoDB 存储引擎中，SELECT 操作的不可重复读问题通过 MVCC 得到了解决</p><p>而 UPDATE、DELETE 的不可重复读问题通过 Record Lock 解决，</p><p>INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决的。</p></blockquote><h4 id="死锁问题" tabindex="-1">死锁问题 <a class="header-anchor" href="#死锁问题" aria-label="Permalink to &quot;死锁问题&quot;">​</a></h4><h5 id="排查死锁问题步骤" tabindex="-1">排查死锁问题步骤 <a class="header-anchor" href="#排查死锁问题步骤" aria-label="Permalink to &quot;排查死锁问题步骤&quot;">​</a></h5><blockquote><p>（1）查看死锁日志</p></blockquote><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">show processlist</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">show processlist</span></span></code></pre></div><p>用于显示当前MySQL服务器上的所有连接和正在执行的查询。这个命令对于查看哪些线程正在运行以及它们的状态非常有用，特别是当你需要诊断系统是否有慢查询或者锁竞争时。</p><p>执行这个命令会返回一个结果集，其中包含以下列：</p><table><thead><tr><th>列</th><th>描述</th></tr></thead><tbody><tr><td>Id</td><td>连接的线程ID</td></tr><tr><td>User</td><td>发起连接的MySQL用户</td></tr><tr><td>Host</td><td>用户连接的主机名和端口号</td></tr><tr><td>db</td><td>当前选定的数据库</td></tr><tr><td>Command</td><td>线程正在执行的命令类型，比如 Query、Sleep、Locked 等</td></tr><tr><td>Time</td><td>当前命令已经执行的秒数</td></tr><tr><td>State</td><td>线程的状态，比如 Sending data、Sorting result、Waiting for table lock 等</td></tr><tr><td>Info</td><td>实际执行的SQL语句或者线程的最后一个SQL语句</td></tr></tbody></table><p>当你发现有问题的连接或查询时，你可以使用 KILL 命令加上连接的线程ID来终止它：</p><p><code>KILL &lt;thread_id&gt;</code></p><p>请谨慎使用 KILL 命令，因为它会立即终止正在执行的查询和相关的MySQL连接。</p><h6 id="mysql-8-0以下版本" tabindex="-1">mysql 8.0以下版本 <a class="header-anchor" href="#mysql-8-0以下版本" aria-label="Permalink to &quot;mysql 8.0以下版本&quot;">​</a></h6><div class="language-mysql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">SELECT * FROM information_schema.innodb_trx;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">SELECT * FROM information_schema.innodb_trx;</span></span></code></pre></div><p>表一行记录，显示了一个事务的状态。这个事务正在等待锁（LOCK WAIT），并且它正在执行一个UPDATE语句。下面是这条记录的一些关键字段的解释：</p><table><thead><tr><th>列</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>trx_id</td><td>29096296</td><td>事务的唯一标识符</td></tr><tr><td>trx_state</td><td>LOCK WAIT</td><td>表示事务正在等待获取锁</td></tr><tr><td>trx_started</td><td>2024-01-12 17:50:21</td><td>事务开始的时间</td></tr><tr><td>trx_requested_lock_id</td><td>140125197551408:5380:1634:76:140114584426816</td><td>事务正在等待的锁的ID</td></tr><tr><td>trx_wait_started</td><td>2024-01-12 17:52:36</td><td>事务开始等待锁的时间</td></tr><tr><td>trx_weight</td><td>4</td><td>事务的权重，通常表示事务修改的行数</td></tr><tr><td>trx_mysql_thread_id</td><td>665022</td><td>执行事务的MySQL线程ID</td></tr><tr><td>trx_query</td><td></td><td>事务当前正在执行的SQL语句</td></tr><tr><td>trx_operation_state</td><td>starting index read</td><td>事务操作的当前状态</td></tr><tr><td>trx_tables_in_use</td><td>1</td><td>事务当前正在使用的表的数量</td></tr><tr><td>trx_tables_locked</td><td>2</td><td>事务当前锁定的表的数量</td></tr><tr><td>trx_lock_structs</td><td>3</td><td>事务持有的锁的数量</td></tr><tr><td>trx_lock_memory_bytes</td><td>1136</td><td>事务锁结构占用的内存量</td></tr><tr><td>trx_rows_locked</td><td>1</td><td>事务锁定的行数</td></tr><tr><td>trx_rows_modified</td><td>1</td><td>事务修改的行数</td></tr><tr><td>trx_isolation_level</td><td>REPEATABLE READ</td><td>事务的隔离级别</td></tr><tr><td>trx_unique_checks</td><td>1</td><td>事务是否正在进行唯一性检查</td></tr><tr><td>trx_foreign_key_checks</td><td>1</td><td>事务是否正在进行外键检查</td></tr></tbody></table><p>为了进一步分析死锁，需要查看trx_requested_lock_id对应的锁信息，这可以通过查询</p><p>information_schema.innodb_locks表来完成。</p><p>同时查看innodb_lock_waits表来确定哪些事务持有锁以及哪些事务正在等待这些锁。</p><p>如果发现死锁是由于多个事务试图以不同的顺序锁定同一组资源造成的，需要重新审视应用程序的事务逻辑，确保所有事务以相同的顺序请求锁，或者减少事务的大小和复杂性，以减少死锁的可能性。</p><p>要确定一个事务正在等待哪个SQL语句的锁，需要结合information_schema中的innodb_lock_waits和innodb_locks表，以及innodb_trx表中的信息。以下是步骤和SQL查询语句：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>查看锁等待关系</td><td>SELECT * FROM information_schema.innodb_lock_waits</td><td>使用innodb_lock_waits表来查看哪些事务正在等待锁，以及它们正在等待哪些事务释放锁。<br>将显示请求锁的事务（REQUESTING_TRX_ID）和持有锁的事务（BLOCKING_TRX_ID）</td></tr><tr><td>查看持有锁的事务</td><td>SELECT * FROM information_schema.innodb_trx WHERE trx_id = &#39;持有锁的事务ID&#39;</td><td>使用BLOCKING_TRX_ID从innodb_trx表中找到持有锁的事务的信息。<br>将显示持有锁的事务的详细信息，包括它正在执行的SQL语句（trx_query）</td></tr><tr><td>分析锁的具体信息</td><td>SELECT * FROM information_schema.innodb_locks WHERE lock_trx_id = &#39;持有锁的事务ID&#39;</td><td>使用innodb_locks表来获取锁的详细信息。<br>将显示锁的类型、模式、索引等信息</td></tr></tbody></table><h6 id="mysql-8-0以上版本" tabindex="-1">mysql 8.0以上版本 <a class="header-anchor" href="#mysql-8-0以上版本" aria-label="Permalink to &quot;mysql 8.0以上版本&quot;">​</a></h6><p>在MySQL 8.0及更高版本中，INNODB_LOCKS和INNODB_LOCK_WAITS表已经从information_schema数据库中移除，</p><p>取而代之的是performance_schema数据库中的数据锁监控表。可以使用以下查询来获取锁的信息：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>查看正在等待的锁</td><td>SELECT * FROM performance_schema.data_lock_waits</td><td></td></tr><tr><td>查看所有锁的信息</td><td>SELECT * FROM performance_schema.data_locks</td><td></td></tr><tr><td>查看特定事务的锁信息</td><td>SELECT * FROM performance_schema.data_locks WHERE ENGINE_TRANSACTION_ID = &#39;transaction_id&#39;;</td><td>将transaction_id替换为从innodb_trx表中获取的trx_id</td></tr></tbody></table><p>这些performance_schema表提供了锁的详细信息，包括哪些事务持有锁，哪些事务正在等待锁，以及锁定的对象</p><p>等信息。通过这些信息，可以分析并确定死锁的原因。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>查找锁信息</td><td>SELECT ENGINE_TRANSACTION_ID, THREAD_ID, OBJECT_SCHEMA, OBJECT_NAME, LOCK_TYPE, LOCK_MODE, LOCK_STATUS FROM performance_schema.data_locks WHERE LOCK_STATUS = &#39;GRANTED&#39;;</td></tr><tr><td>查找等待锁的事务</td><td>SELECT ENGINE_TRANSACTION_ID, THREAD_ID, OBJECT_SCHEMA, OBJECT_NAME, LOCK_TYPE, LOCK_MODE, LOCK_STATUS FROM performance_schema.data_locks WHERE LOCK_STATUS = &#39;WAITING&#39;;</td></tr><tr><td>使用THREAD_ID关联events_statements_current表来找到对应的SQL语句</td><td>SELECT es.THREAD_ID, es.SQL_TEXT FROM performance_schema.events_statements_current es JOIN performance_schema.threads t ON es.THREAD_ID = t.THREAD_ID WHERE t.PROCESSLIST_ID = &#39;THREAD_ID&#39;;</td></tr><tr><td>使用THREAD_ID找到对应的MySQL进程ID(PROCESSLIST_ID)</td><td>SELECT * FROM performance_schema.threads WHERE THREAD_ID in (662285)</td></tr><tr><td>使用KILL命令加上PROCESSLIST_ID来杀死进程</td><td>KILL 661676;</td></tr></tbody></table><h4 id="什么-sql-语句会加行锁" tabindex="-1">什么 SQL 语句会加行锁？ <a class="header-anchor" href="#什么-sql-语句会加行锁" aria-label="Permalink to &quot;什么 SQL 语句会加行锁？&quot;">​</a></h4><p><code>InnoDB</code> 引擎是支持行级锁的，而 MyISAM 引擎不支持行级锁。</p><p>普通的 select 语句是不会对记录加锁，它属于快照读，是通过 MVCC（多版本并发控制）实现的。</p><p>要在查询时对记录加行级锁，可以采用如下方式:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 对读取的记录加共享锁(S型锁)</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> ... lock </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> share mode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 对读取的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> ... </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 对读取的记录加共享锁(S型锁)</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> ... lock </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> share mode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"># 对读取的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> ... </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>1.上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。</p></blockquote><p>除了这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且都是独占锁(X型锁)。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 对操作的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#E1E4E8;">updaet </span><span style="color:#F97583;">table</span><span style="color:#E1E4E8;"> .... </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 对操作的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#F97583;">delete</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">table</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 对操作的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#24292E;">updaet </span><span style="color:#D73A49;">table</span><span style="color:#24292E;"> .... </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"># 对操作的记录加独占锁(X型锁)</span></span>
<span class="line"><span style="color:#D73A49;">delete</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">table</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>共享锁与独占锁的解释:</p><p>1.共享锁（S锁）满足读读共享，读写互斥。</p><p>2.独占锁（X锁）满足写写互斥、读写互斥。</p></blockquote><p>不同<code>隔离级别</code>下，行级锁的种类是不同的。</p><p>在<code>读已提交</code>隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。</p><p>在<code>可重复读</code>隔离级别下(<code>Mysql默认隔离级别</code>)，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻 读），所以行级锁的种类主要有三类:</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><p><code>Record Lock</code></p><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><p>执行如下 sql:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">mysql </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">mysql </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> t_test </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">mysql </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">mysql </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> t_test </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>1.事务会对表中主键 id = 1 的这条记录加上 X 型的记录锁，如果这时候其他事务对这条记录进行删除或者更新操作，那么这些操作都会被阻塞。</p><p>2.其他事务插入一条 id = 1 的新记录并不会被阻塞，会报主键冲突的错误，这是因为主键有唯一性的约束。</p><p>3.当事务执行 commit 后，事务过程中生成的锁都会被释放。</p></blockquote><p><code>Gap Lock</code></p><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><blockquote><p>假设表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p></blockquote><p>间隙锁之间是兼容的，即<code>两个事务可以同时持有包含共同间隙范围的间隙锁</code>，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。</p><p><code>Next-Key Lock</code></p><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><blockquote><p>假设表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务既不能插入 id = 4 记录，也不能修改和删除 id = 5 这条记录。next-key lock 即能保护该记录，又能阻止其他事务将新记录插入到被保护记录前面的间隙中。</p></blockquote><p>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被<code>阻塞</code>的。</p><h4 id="mysql-是怎么加行级锁的" tabindex="-1">MySQL 是怎么加行级锁的？ <a class="header-anchor" href="#mysql-是怎么加行级锁的" aria-label="Permalink to &quot;MySQL 是怎么加行级锁的？&quot;">​</a></h4><p>加锁的对象是<code>索引</code>，加锁的基本单位是 <code>next-key lock</code>，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。</p><p>next-key lock 在一些场景下会<code>退化</code>成记录锁或间隙锁。</p><p>在<code>能使用记录锁或者间隙锁就能避免幻读现象</code>的场景下， next-key lock 就会退化成退化成记录锁或间隙锁。</p><p>举例如下:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">CREATE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">TABLE</span><span style="color:#E1E4E8;"> \`</span><span style="color:#B392F0;">user</span><span style="color:#E1E4E8;">\` (</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">\`id\`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">bigint</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">NOT NULL</span><span style="color:#E1E4E8;"> AUTO_INCREMENT,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">\`name\`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">varchar</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">30</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">COLLATE</span><span style="color:#E1E4E8;"> utf8mb4_unicode_ci </span><span style="color:#F97583;">NOT NULL</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">\`age\`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">NOT NULL</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">PRIMARY KEY</span><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">\`id\`</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">KEY</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">\`index_age\`</span><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">\`age\`</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">USING</span><span style="color:#E1E4E8;"> BTREE</span></span>
<span class="line"><span style="color:#E1E4E8;">) ENGINE</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">InnoDB </span><span style="color:#F97583;">DEFAULT</span><span style="color:#E1E4E8;"> CHARSET</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">utf8mb4 </span><span style="color:#F97583;">COLLATE=</span><span style="color:#E1E4E8;">utf8mb4_unicode_ci;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">CREATE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">TABLE</span><span style="color:#24292E;"> \`</span><span style="color:#6F42C1;">user</span><span style="color:#24292E;">\` (</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">\`id\`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">bigint</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">NOT NULL</span><span style="color:#24292E;"> AUTO_INCREMENT,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">\`name\`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">varchar</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">30</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">COLLATE</span><span style="color:#24292E;"> utf8mb4_unicode_ci </span><span style="color:#D73A49;">NOT NULL</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">\`age\`</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">NOT NULL</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">PRIMARY KEY</span><span style="color:#24292E;"> (</span><span style="color:#032F62;">\`id\`</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">KEY</span><span style="color:#24292E;"> </span><span style="color:#032F62;">\`index_age\`</span><span style="color:#24292E;"> (</span><span style="color:#032F62;">\`age\`</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">USING</span><span style="color:#24292E;"> BTREE</span></span>
<span class="line"><span style="color:#24292E;">) ENGINE</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">InnoDB </span><span style="color:#D73A49;">DEFAULT</span><span style="color:#24292E;"> CHARSET</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">utf8mb4 </span><span style="color:#D73A49;">COLLATE=</span><span style="color:#24292E;">utf8mb4_unicode_ci;</span></span></code></pre></div><blockquote><p>1.id 是主键索引（唯一索引），age 是普通索引（非唯一索引），name 是普通列</p><p>2.实验环境的 MySQL 版本是 8.0.28，隔离级别是「可重复读」。</p></blockquote><p><code>唯一索引等值查询</code></p><p>用唯一索引进行等值查询时:</p><ul><li><p>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的next-key lock 会退化成「记录锁」。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>1.事务 A 会为 id 为 1 的这条记录就会加上 X 型的记录锁。</p></blockquote></li></ul><blockquote><p>2.如果有其他事务，对 id 为 1 的记录进行更新或者删除操作的话，这些操作都会被阻塞，因为更新或者删除操作也会对记录加 X 型的记录锁，而 X 锁和 X 锁之间是互斥关系。</p></blockquote><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 查看事务执行 </span><span style="color:#F97583;">SQL</span><span style="color:#E1E4E8;"> 过程中加锁</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">performance_schema</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">data_locks</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 查看事务执行 </span><span style="color:#D73A49;">SQL</span><span style="color:#24292E;"> 过程中加锁</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">performance_schema</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">data_locks</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><ol><li>LOCK_TYPE 中的 RECORD 表示行级锁,TABLE表示表锁(案例里是X 类型的意向锁)</li><li>如果 LOCK_MODE 为 X ，说明是 next-key 锁</li><li>如果 LOCK_MODE 为 X, REC_NOT_GAP ，说明是记录锁(对应案例查询sql)</li><li>如果 LOCK_MODE 为 X, GAP ，说明是间隙锁；</li></ol></blockquote><p><strong>总结</strong></p><blockquote><p>问题: 为什么唯一索引等值查询并且查询记录存在的场景下，该记录的索引中的 next-key lock 会退化成记录锁？</p><p>原因就是<code>在唯一索引等值查询并且查询记录存在的场景下，仅靠记录锁也能避免幻读</code>的问题。</p><p>幻读的定义就是，当一个事务前后两次查询的结果集，不相同时，就认为发生幻读。所以，要避免幻读就是避免结果集某一条记录被其他事务删除，或者有其他事务插入了一条新记录，这样前后两次查询的结果集就不会出现不相同的情况。</p><ul><li>由于主键具有唯一性，所以其他事务插入 id = 1 的时候，会因为主键冲突，导致无法插入 id = 1 的新记录。事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题</li><li>由于对 id = 1 加了记录锁，其他事务无法删除该记录，这样事务 A 在多次查询 id = 1的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。</li></ul></blockquote><ul><li><p>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">performance_schema</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">data_locks</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">performance_schema</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">data_locks</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>1.从上图可以看到，共加了两个锁，分别是 表锁：X 类型的意向锁 和 行锁：<code>X 类型的间隙锁</code></p></blockquote></li></ul><blockquote><p>2.事务 在 id = 5 记录的主键索引上加的是间隙锁，锁住的范围是 (1, 5)</p><p>3.如果有其他事务插入 id 值为 2、3、4 这一些记录的话，这些插入语句都会发生阻塞。</p><p>4.如果其他事务插入的 id = 1 或者 id = 5 的记录话，并不会发生阻塞，而是报主键冲突的错误，因为表中已经存在 id = 1 和 id = 5 的记录了。</p></blockquote><p><strong>总结</strong></p><blockquote><p>问题: 为什么唯一索引等值查询并且查询记录「不存在」的场景下，在索引树找到第一条大于该查询记录的记录后，要将该记录的索引中的 next-key lock 会退化成「间隙锁」？</p><p>原因就是<code>在唯一索引等值查询并且查询记录不存在的场景下，仅靠间隙锁就能避免幻读</code>的问题。</p><ul><li>为什么 id = 5 记录上的主键索引的锁不可以是 next-key lock？如果是 next-key lock，就意味着其他事务无法删除 id = 5 这条记录，但是这次的案例是查询 id = 2 的记录，只要保证前后两次查询 id = 2 的结果集相同，就能避免幻读的问题了，所以即使 id =5被删除，也不会有什么影响，那就没必须加 next-key lock，因此只需要在 id = 5 加间隙锁，避免其他事务插入 id = 2 的新记录就行了。</li><li>为什么不可以针对不存在的记录加记录锁？锁是加在索引上的，而这个场景下查询的记录是不存在的，自然就没办法锁住这条不存在的记录。</li></ul></blockquote><p><code>唯一索引范围查询</code></p><p>当唯一索引进行范围查询时，会<code>对每一个扫描到的索引加 next-key 锁</code>，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁：</p><ul><li><p>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会退化成记录锁。</p><p><strong>实验一</strong>：针对「大于」的范围查询的情况</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">15</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">15</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>加锁变化过程如下：</p></blockquote></li></ul><blockquote><p>1.最开始要找的第一行是 id = 20，由于查询该记录不是一个等值查询（不是大于等于条件查询），所以对该主键索引加的是范围为 (15, 20] 的 next-key 锁；</p><p>2.由于是范围查找，就会继续往后找存在的记录，虽然我们看见表中最后一条记录是 id =20 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该主键索引加的是范围为 (20, +∞] 的 next-key锁。</p><p>3.停止扫描。</p><p>可以得知，事务 在主键索引上加了两个 X 型 的 next-key 锁：</p><ul><li>在 id = 20 这条记录的主键索引上，加了范围为 (15, 20] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。</li><li>在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞] 的next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。</li></ul></blockquote><p><strong>实验二</strong>：针对「大于等于」的范围查询的情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">15</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">15</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>事务 加锁变化过程如下：</p><p>1.最开始要找的第一行是 id = 15，由于查询该记录是一个等值查询（等于 15），所以该主键索引的 next-key 锁会退化成记录锁，也就是仅锁住 id = 15 这一行记录。</p><p>2.由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 20，于是对该主键索引加的是范围为 (15, 20] 的 next-key 锁；</p><p>3.接着扫描到第三行的时候，扫描到了特殊记录（ supremum pseudo-record），于是对该主键索引加的是范围为 (20, +∞] 的 next-key 锁。</p><p>4.停止扫描。</p></blockquote><ul><li><p>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：</p><ul><li><p>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</p><p><strong>实验一</strong>：针对「小于」的范围查询时，查询条件值的记录「不存在」表中的情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">6</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>事务 加锁变化过程如下：</p></blockquote></li></ul></li></ul><blockquote><p>1.最开始要找的第一行是 id = 1，于是对该主键索引加的是范围为 (-∞, 1] 的 next-key锁；</p><p>2.由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，所以对该主键索引加的是范围为 (1, 5] 的 next-key 锁；</p><p>3.由于扫描到的第二行记录（id = 5），满足 id &lt; 6 条件，而且也没有达到终止扫描的条件，接着会继续扫描。</p><p>4.扫描到的第三行是 id = 10，该记录不满足 id &lt; 6 条件的记录，所以 id = 10 这一行记录的锁会<code>退化成间隙锁</code>，于是对该主键索引加的是范围为 (5, 10) 的间隙锁。</p><p>5.由于扫描到的第三行记录（id = 10），不满足 id &lt; 6 条件，达到了终止扫描的条件，于是停止扫描</p></blockquote><pre><code>&gt;事务  在主键索引上加了三个 X 型的锁:
</code></pre><blockquote><p>1.在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录</p><p>2.在 id = 5 这条记录的主键索引上，加了范围为 (1, 5] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。</p><p>3.在 id = 10 这条记录的主键索引上，加了范围为 (5, 10) 的间隙锁，意味着其他事务无法插入 id 值为 6、7、8、9 的这一些新记录。</p></blockquote><ul><li><p>当条件值的记录在表中，如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁</p><p><strong>实验二</strong>：针对「小于等于」的范围查询时，查询条件值的记录「存在」表中的情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>事务 加锁变化过程如下：</p></blockquote></li></ul><blockquote><ol><li>最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；</li><li>由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，于是对该记录加的是范围为 (1, 5] 的 next-key 锁。</li><li>由于主键索引具有唯一性，不会存在两个 id = 5 的记录，所以不会再继续扫描，于是停止扫描。</li></ol></blockquote><pre><code>**实验三**：再来看针对「小于」的范围查询时，查询条件值的记录「存在」表中的情况。
  
\`\`\`sql
</code></pre><p>begin; select * from user where id &lt; 5 for update;</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">  </span></span>
<span class="line"><span style="color:#e1e4e8;">  &gt;事务 加锁变化过程如下：</span></span>
<span class="line"><span style="color:#e1e4e8;">&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">  &gt;1. 最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；</span></span>
<span class="line"><span style="color:#e1e4e8;">&gt;2. 由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，该记录是第一条不满足 id &lt; 5 条件的记录，于是**该记录的锁会退化为间隙锁，锁范围是(1,5)**。</span></span>
<span class="line"><span style="color:#e1e4e8;">  &gt;3. 由于找到了第一条不满足 id &lt; 5 条件的记录，于是停止扫描。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">\`非唯一索引等值查询\`</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">用非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">- 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key</span></span>
<span class="line"><span style="color:#e1e4e8;">锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。</span></span>
<span class="line"><span style="color:#e1e4e8;">- 当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">**实验一**：针对非唯一索引等值查询时，查询的值不存在的情况</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">​\`\`\`sql</span></span>
<span class="line"><span style="color:#e1e4e8;"># 假设事务对非唯一索引（age）进行了等值查询，且表中不存在 age = 25 的记录。</span></span>
<span class="line"><span style="color:#e1e4e8;">begin;</span></span>
<span class="line"><span style="color:#e1e4e8;">select * from user where age = 25 for update;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">  </span></span>
<span class="line"><span style="color:#24292e;">  &gt;事务 加锁变化过程如下：</span></span>
<span class="line"><span style="color:#24292e;">&gt;</span></span>
<span class="line"><span style="color:#24292e;">  &gt;1. 最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；</span></span>
<span class="line"><span style="color:#24292e;">&gt;2. 由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，该记录是第一条不满足 id &lt; 5 条件的记录，于是**该记录的锁会退化为间隙锁，锁范围是(1,5)**。</span></span>
<span class="line"><span style="color:#24292e;">  &gt;3. 由于找到了第一条不满足 id &lt; 5 条件的记录，于是停止扫描。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">\`非唯一索引等值查询\`</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">用非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">- 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key</span></span>
<span class="line"><span style="color:#24292e;">锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。</span></span>
<span class="line"><span style="color:#24292e;">- 当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">**实验一**：针对非唯一索引等值查询时，查询的值不存在的情况</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">​\`\`\`sql</span></span>
<span class="line"><span style="color:#24292e;"># 假设事务对非唯一索引（age）进行了等值查询，且表中不存在 age = 25 的记录。</span></span>
<span class="line"><span style="color:#24292e;">begin;</span></span>
<span class="line"><span style="color:#24292e;">select * from user where age = 25 for update;</span></span></code></pre></div><blockquote><p>事务 A 加锁变化过程如下： 1.定位到第一条不符合查询条件的二级索引记录，即扫描到 age = 29，于是<strong>该二级索引的 next-key 锁会退化成间隙锁，范围是 (19,29 )</strong>。</p><p>2.停止查询</p></blockquote><blockquote><p>当有一个事务持有二级索引的间隙锁 (19, 29) 时，什么情况下，可以让其他事务的插入age = 19 或者 age = 29 记录的语句成功？又是什么情况下，插入 age = 19 或者 age = 29 记录时的语句会被阻塞？</p><p><strong>插入语句在插入一条记录之前，需要先定位到该记录在 B+树 的位置，如果插入的位置的下一条记录的索引上有间隙锁，才会发生阻塞。</strong></p><p><code>二级索引树是按照二级索引值（age列）按顺序存放的，在相同的二级索引值情况下， 再按主键 id 的顺序存放。知道了这个前提，我们才能知道执行插入语句的时候，插入的位置的下一条记录是谁。</code></p><p>当有一个事务持有二级索引的间隙锁 (19, 29) 时，插入 age = 19 或者 age = 29记录的语句是否可以执行成功，关键还要考虑插入记录的主键值，因为「二级索引值（age列）+主键值（id列）」才可以确定插入的位置，确定了插入位置后，就要<code>看插入的位置的下一条记录是否有间隙锁，如果有间隙锁，就会发生阻塞，如果没有间隙锁，则可以插入成功</code>。</p></blockquote><blockquote><p>LOCK_DATA：29，10 解释:</p><ul><li>LOCK_DATA 第一个数值，也就是 29， 它代表的是 age 值。LOCK_DATA 第一个数值是 next-key 锁和间隙锁锁住的范围的右边界值。</li><li>LOCK_DATA 第二个数值，也就是 10， 它代表的是 id 值。</li></ul><p>之所以 LOCK_DATA 要多显示一个数值（ID值），是因为针对「当某个事务持有非唯一索引的 (19, 29 ) 间隙锁的时候，其他事务是否可以插入 age = 29 新记录」的问题，还需要考虑插入记录的 id 值。而 <code>LOCK_DATA 的第二个数值，就是说明在插入 age = 29 新记录时，哪些范围的 id 值是不可以插入的</code>。</p><p>LOCK_DATA：29，10 + LOCK_MODE : X, GAP 解读:</p><p>事务 在 age = 29 记录的二级索引上（INDEX_NAME: index_age ），加了 age 值范围为 (19, 29) 的 X 型间隙锁，同时<code>针对其他事务插入 age 值为 29 的新记录时，不允许插入的新记录的 id 值小于 10</code>,如果插入的新记录的 id 值大于 20，则可以插入成功。</p></blockquote><p><strong>实验二</strong>：针对非唯一索引等值查询时，查询的值存在的情况。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 假设事务 A 对非唯一索引（age）进行了等值查询，且表中存在 age </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">22</span><span style="color:#E1E4E8;"> 的记录</span></span>
<span class="line"><span style="color:#F97583;">begin</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> user </span><span style="color:#F97583;">where</span><span style="color:#E1E4E8;"> age </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">22</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">update</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 假设事务 A 对非唯一索引（age）进行了等值查询，且表中存在 age </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">22</span><span style="color:#24292E;"> 的记录</span></span>
<span class="line"><span style="color:#D73A49;">begin</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> user </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> age </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">22</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">update</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>事务 加锁变化过程如下：</p><p>1.由于不是唯一索引，所以肯定存在值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，最开始要找的第一行是 age = 22，于是对该二级索引记录加上范围为(19, 22] 的 next-key 锁。同时，因为 age = 22 符合查询条件，于是对 age = 22 的记录的主键索引加上记录锁，即对 id = 20 这一行加记录锁。</p><p>2.接着继续扫描，扫描到的第二行是 age = 29，该记录是第一个不符合条件的二级索引记 录，所以该二级索引的 next-key 锁会退化成间隙锁，范围是 (22, 29)。</p><p>3.停止查询。</p></blockquote><blockquote><p>从上图的分析，可以看到，事务 A 对二级索引（INDEX_NAME: index_age ）加了两个 X 型锁</p></blockquote><p><code>非唯一索引范围查询</code></p><p>非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于<code>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁</code>。</p><p><code>没有加索引的查询</code></p><p>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，<code>每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表</code>，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</p><p>update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。</p>`,159),t=[p];function o(c,r,d,y,i,E){return a(),l("div",null,t)}const u=s(n,[["render",o]]);export{k as __pageData,u as default};
