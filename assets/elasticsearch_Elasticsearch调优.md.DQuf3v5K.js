import{_ as e,c as t,o as a,a4 as r}from"./chunks/framework.PLIGnzYk.js";const b=JSON.parse('{"title":"Elasticsearch调优","description":"","frontmatter":{},"headers":[],"relativePath":"elasticsearch/Elasticsearch调优.md","filePath":"elasticsearch/Elasticsearch调优.md","lastUpdated":1727778851000}'),s={name:"elasticsearch/Elasticsearch调优.md"},d=r('<h1 id="elasticsearch调优" tabindex="-1">Elasticsearch调优 <a class="header-anchor" href="#elasticsearch调优" aria-label="Permalink to &quot;Elasticsearch调优&quot;">​</a></h1><p><img src="https://knowledge-2018.oss-cn-shanghai.aliyuncs.com/img/202410011808553.png" alt="image-20230628180805414"></p><h2 id="写入性能优化" tabindex="-1">写入性能优化 <a class="header-anchor" href="#写入性能优化" aria-label="Permalink to &quot;写入性能优化&quot;">​</a></h2><h3 id="业务优化" tabindex="-1">业务优化 <a class="header-anchor" href="#业务优化" aria-label="Permalink to &quot;业务优化&quot;">​</a></h3><p>在业务上，最常见的优化手段就是变<code>单条写入为批量写入</code>。而es本身支持批量插入，就是<code>bulk操作</code>。</p><p>常用优化方式是：<code>数据接入时，先不写库，而是直接推送到消息队列中（参考rabbitmq）。然后监听该队列，批</code></p><p><code>量拿消息</code>。一次拿1000条，最后将这1000条数据批量写入es。实测结果1000条批量写入耗时和单条写入耗时相差不大。</p><p>除了按数量批量写入外，还可以<code>按照时间</code>。比如<code>每秒写入一次，有多少数量就写入多少</code>。其实这种方法应该更合</p><p>理，像mysql底层数据和日志落盘的策略，其中就有每秒落盘一次的策略。</p><h3 id="底层优化" tabindex="-1">底层优化 <a class="header-anchor" href="#底层优化" aria-label="Permalink to &quot;底层优化&quot;">​</a></h3><p>除了业务优化外，还有就是从底层优化。而底层优化，最常见的就是刷盘策略。因为我们都知道，正在的耗时就是磁盘IO。优化参数，如下：</p><table tabindex="0"><thead><tr><th>参数</th><th>优化后值</th><th>含义</th></tr></thead><tbody><tr><td>index.refresh_interval</td><td>10s</td><td>缓存刷新时间，即10s后数据才能被搜索</td></tr><tr><td>index.translog.durability</td><td>async</td><td>异步</td></tr><tr><td>index.translog.flush_threshold_size</td><td>1024mb</td><td>translog大小达到多大时落盘</td></tr><tr><td>index.translog.sync_interval</td><td>30s</td><td>translog每隔多久落盘</td></tr></tbody></table><p>其中，效果最明显的就是<code>index.translog.durability</code>。它表示的是日志持久化策略，默认情况下是同步策</p><p>略，即写一条数据要等日志落盘后才返回。这种效率慢，但能保证数据安全性。</p><p>将index.translog.durability改为async后，就是异步策略。数据写入缓存后，里面返回，不会等待日志是否落盘</p><p>成功。这种效率很快，但数据安全性差。document模型设计避免复杂的关联查询，大表设计这样。</p><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/7244819106343518268" target="_blank" rel="noreferrer">在工作中 ElasticSearch 的一些使用规范</a></li></ul>',18),c=[d];function o(i,l,n,h,p,_){return a(),t("div",null,c)}const m=e(s,[["render",o]]);export{b as __pageData,m as default};
